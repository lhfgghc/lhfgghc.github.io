<!doctype html><html itemscope lang=en-us itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=5"><meta name=theme-name content="hugoplate"><link rel="shortcut icon" href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_96x0_resize_lanczos_3.png type=image/x-icon><link rel=icon href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_96x0_resize_lanczos_3.png type=image/x-icon><link rel=icon type=image/png sizes=48x48 href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_48x0_resize_lanczos_3.png><link rel=icon type=image/png sizes=96x96 href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_96x0_resize_lanczos_3.png><link rel=apple-touch-icon sizes=144x144 href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_144x0_resize_lanczos_3.png><link rel=manifest href=/manifest.webmanifest><meta name=msapplication-TileColor content="#ddd"><meta name=theme-color content="#ffffff"><base href=https://lhfgghc.github.io/en/blog/cfvp/><title>【算法笔记】Codeforces训练部分记录</title>
<meta name=keywords content="Boilerplate,Hugo"><meta name=description content="this is meta description"><meta name=author content="zeon.studio"><meta property="og:image" content="https://lhfgghc.github.io/images/CFVP/1207C.png"><meta name=twitter:image content="https://lhfgghc.github.io/images/CFVP/1207C.png"><meta name=twitter:card content="summary_large_image"><meta property="og:image:width" content="1917"><meta property="og:image:height" content="827"><meta property="og:image:type" content="image/
        .png
      "><meta property="og:title" content="【算法笔记】Codeforces训练部分记录"><meta property="og:description" content="this is meta description"><meta property="og:type" content="website"><meta property="og:url" content="https://lhfgghc.github.io/en/blog/cfvp/"><meta name=twitter:title content="【算法笔记】Codeforces训练部分记录"><meta name=twitter:description content="this is meta description"><script>let indexURL="https://lhfgghc.github.io/en/searchindex.json",includeSectionsInSearch=["blog"],search_no_results="未找到结果",search_initial_message="输入内容以搜索"</script><meta http-equiv=x-dns-prefetch-control content="on"><link rel=preconnect href=https://use.fontawesome.com crossorigin><link rel=preconnect href=//cdnjs.cloudflare.com><link rel=preconnect href=//www.googletagmanager.com><link rel=preconnect href=//www.google-analytics.com><link rel=dns-prefetch href=https://use.fontawesome.com><link rel=dns-prefetch href=//ajax.googleapis.com><link rel=dns-prefetch href=//cdnjs.cloudflare.com><link rel=dns-prefetch href=//www.googletagmanager.com><link rel=dns-prefetch href=//www.google-analytics.com><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//connect.facebook.net><link rel=dns-prefetch href=//platform.linkedin.com><link rel=dns-prefetch href=//platform.twitter.com><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;600&family=Signika:wght@500;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><link href="/css/style.min.4c1d4c3120637c4b33d33d38988a2525a8e15057b5ab0cfa95ce5147d4c95adc.css" integrity="sha256-TB1MMSBjfEsz0z04mIolJajhUFe1qwz6lc5RR9TJWtw=" rel=stylesheet><link defer async rel=stylesheet href="/css/style-lazy.min.ec14d2549e8e0fbaf9af20dcc88fad37fb352e5bd5978a801dc1c3f5a5922174.css" integrity="sha256-7BTSVJ6OD7r5ryDcyI+tN/s1LlvVl4qAHcHD9aWSIXQ=" media=print onload='this.media="all",this.onload=null'></head><body><header class="header sticky top-0 z-30"><nav class="navbar container"><div class=order-0><a class="navbar-brand block" href=/en/><img fetchpriority=high decoding=async class="img logo-light" width=160 height=32 src=/images/logo-1_hubf409f6fc77577ff09f7cacc73653041_8513_320x0_resize_q80_h2_lanczos_3.webp alt=Hugoplate onerror='this.onerror=null,this.src="/images/logo-1_hubf409f6fc77577ff09f7cacc73653041_8513_320x0_resize_lanczos_3.png"'>
<img fetchpriority=high decoding=async class="img logo-dark" width=160 height=32 src=/images/logo-2_hu06a606f114baa5722e40403b02652855_7961_320x0_resize_q80_h2_lanczos_3.webp alt=Hugoplate onerror='this.onerror=null,this.src="/images/logo-2_hu06a606f114baa5722e40403b02652855_7961_320x0_resize_lanczos_3.png"'></a></div><input id=nav-toggle type=checkbox class=hidden>
<label for=nav-toggle class="order-3 cursor-pointer flex items-center lg:hidden text-dark dark:text-white lg:order-1"><svg id="show-button" class="h-6 fill-current block" viewBox="0 0 20 20"><title>Menu Open</title><path d="M0 3h20v2H0V3zm0 6h20v2H0V9zm0 6h20v2H0V0z"/></svg><svg id="hide-button" class="h-6 fill-current hidden" viewBox="0 0 20 20"><title>Menu Close</title><polygon points="11 9 22 9 22 11 11 11 11 22 9 22 9 11 -2 11 -2 9 9 9 9 -2 11 -2" transform="rotate(45 10 10)"/></svg></label><ul id=nav-menu class="navbar-nav order-3 hidden lg:flex w-full pb-6 lg:order-1 lg:w-auto lg:space-x-2 lg:pb-0 xl:space-x-8"><li class=nav-item><a class=nav-link href=/en/>主页</a></li><li class=nav-item><a class=nav-link href=/en/blog/>学习笔记</a></li><li class=nav-item><a class=nav-link href=/en/about/>个人信息</a></li><li class="nav-item nav-dropdown group relative"><span class="nav-link
inline-flex items-center">其它<svg class="h-4 w-4 fill-current" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></span><ul class="nav-dropdown-list lg:group-hover:visible lg:group-hover:opacity-100"><li class=nav-dropdown-item><a class=nav-dropdown-link href=/en/elements/>样式Draft</a></li><li class=nav-dropdown-item><a class=nav-dropdown-link href=/en/privacy-policy/>相关说明</a></li><li class=nav-dropdown-item><a class=nav-dropdown-link href=/en/categories/>笔记分类</a></li></ul></li></ul><div class="order-1 ml-auto flex items-center md:order-2 lg:ml-0"><button aria-label=search class="border-border text-dark hover:text-primary dark:border-darkmode-border mr-5 inline-block border-r pr-5 text-xl dark:text-white dark:hover:text-darkmode-primary" data-target=search-modal>
<i class="fa-solid fa-search"></i></button><div class="theme-switcher mr-5"><input id=theme-switcher data-theme-switcher type=checkbox>
<label for=theme-switcher><span class=sr-only>theme switcher</span>
<span><svg class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-10 opacity-100 dark:opacity-0" viewBox="0 0 56 56" fill="#fff" height="16" width="16"><path d="M30 4.6c0-1-.9-2-2-2a2 2 0 00-2 2v5c0 1 .9 2 2 2s2-1 2-2zm9.6 9a2 2 0 000 2.8c.8.8 2 .8 2.9.0L46 13a2 2 0 000-2.9 2 2 0 00-3 0zm-26 2.8c.7.8 2 .8 2.8.0.8-.7.8-2 0-2.9L13 10c-.7-.7-2-.8-2.9.0-.7.8-.7 2.1.0 3zM28 16A12 12 0 0016 28a12 12 0 0012 12 12 12 0 0012-12A12 12 0 0028 16zm23.3 14c1.1.0 2-.9 2-2s-.9-2-2-2h-4.9a2 2 0 00-2 2c0 1.1 1 2 2 2zM4.7 26a2 2 0 00-2 2c0 1.1.9 2 2 2h4.9c1 0 2-.9 2-2s-1-2-2-2zm37.8 13.6a2 2 0 00-3 0 2 2 0 000 2.9l3.6 3.5a2 2 0 002.9.0c.8-.8.8-2.1.0-3zM10 43.1a2 2 0 000 2.9c.8.7 2.1.8 3 0l3.4-3.5c.8-.8.8-2.1.0-2.9s-2-.8-2.9.0zm20 3.4c0-1.1-.9-2-2-2a2 2 0 00-2 2v4.9c0 1 .9 2 2 2s2-1 2-2z"/></svg><svg class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-10 opacity-0 dark:opacity-100" viewBox="0 0 24 24" fill="none" height="16" width="16"><path fill="#000" fill-rule="evenodd" clip-rule="evenodd" d="M8.2 2.2c1-.4 2 .6 1.6 1.5-1 3-.4 6.4 1.8 8.7a8.4 8.4.0 008.7 1.8c1-.3 2 .5 1.5 1.5v.1A10.3 10.3.0 0112.4 22 10.3 10.3.0 013.2 6.7c1-2 2.9-3.5 4.9-4.4z"/></svg></span></label></div><script>var darkMode=!1,themeSwitch;window.matchMedia("(prefers-color-scheme: dark)").matches&&(darkMode=!0),localStorage.getItem("theme")==="dark"?darkMode=!0:localStorage.getItem("theme")==="light"&&(darkMode=!1),darkMode&&document.documentElement.classList.toggle("dark"),themeSwitch=document.querySelectorAll("[data-theme-switcher]"),document.addEventListener("DOMContentLoaded",()=>{[].forEach.call(themeSwitch,function(e){e.checked=!!darkMode,e.addEventListener("click",()=>{document.documentElement.classList.toggle("dark"),localStorage.setItem("theme",document.documentElement.classList.contains("dark")?"dark":"light")})})})</script></div></nav></header><div class=search-modal aria-hidden=true style=--color-primary:#121212><div data-target=close-search-modal class=search-modal-overlay></div><div class=search-wrapper data-image=true data-description=true data-tags=true data-categories=true><div class=search-wrapper-header><label for=search-modal-input style=margin-top:-1px><span class=sr-only>search icon</span>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-icon" data-type="search"><path fill="currentcolor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-reset" data-type="reset"><path fill="currentcolor" d="M256 512A256 256 0 10256 0a256 256 0 100 512zM175 175c9.4-9.4 24.6-9.4 33.9.0l47 47 47-47c9.4-9.4 24.6-9.4 33.9.0s9.4 24.6.0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6.0 33.9s-24.6 9.4-33.9.0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9.0s-9.4-24.6.0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6.0-33.9z"/></svg>
</label><input id=search-modal-input type=text data-search-input autocomplete=off aria-label=Search placeholder=搜索></div><div class=search-wrapper-body><div class=search-result data-search-result></div><span class=search-result-empty>输入内容以搜索</span></div><div class=search-wrapper-footer><span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16"><path d="M3.204 11h9.592L8 5.519 3.204 11zm-.753-.659 4.796-5.48a1 1 0 011.506.0l4.796 5.48c.566.647.106 1.659-.753 1.659H3.204a1 1 0 01-.753-1.659z"/></svg>
</kbd><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" style="margin-top:1px" viewBox="0 0 16 16"><path d="M3.204 5h9.592L8 10.481 3.204 5zm-.753.659 4.796 5.48a1 1 0 001.506.0l4.796-5.48c.566-.647.106-1.659-.753-1.659H3.204a1 1 0 00-.753 1.659z"/></svg>
</kbd>导航
</span><span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentcolor" style="display:inline-block" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14.5 1.5a.5.5.0 01.5.5v4.8a2.5 2.5.0 01-2.5 2.5H2.707l3.347 3.346a.5.5.0 01-.708.708l-4.2-4.2a.5.5.0 010-.708l4-4a.5.5.0 11.708.708L2.707 8.3H12.5A1.5 1.5.0 0014 6.8V2a.5.5.0 01.5-.5z"/></svg>
</kbd>选择
</span><span class=search-result-info></span>
<span data-target=close-search-modal><kbd>ESC</kbd> 关闭</span></div></div></div><main><section class="section pt-7"><div class=container><div class="row justify-center"><article class=lg:col-10><div class=mb-10><picture><source srcset=/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_545x0_resize_q80_h2_lanczos_3.webp media="(max-width: 575px)"><source srcset=/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_600x0_resize_q80_h2_lanczos_3.webp media="(max-width: 767px)"><source srcset=/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_700x0_resize_q80_h2_lanczos_3.webp media="(max-width: 991px)"><source srcset=/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_1110x0_resize_q80_h2_lanczos_3.webp><img loading=lazy decoding=async src=/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_1110x0_resize_lanczos_3.png class="w-full rounded img" alt=【算法笔记】Codeforces训练部分记录 width=1917 height=827></picture></div><h1 class="h2 mb-4">【算法笔记】Codeforces训练部分记录</h1><ul class=mb-4><li class="mr-4 inline-block"><a href=/en/authors/liang-hangfeng/><i class="fa-regular fa-circle-user mr-2"></i>Liang Hangfeng</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-folder mr-2"></i>
<a href=/en/categories/%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b/>算法竞赛</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-clock mr-2"></i>
February 11, 2022</li></ul><div class="content mb-10"><h1 id=codeforces-virtual-participation-record>Codeforces Virtual participation Record</h1><h2 id=by-coisini_lhf>By Coisini_LHF</h2><h2 id=contest1200-578div2>Contest1200 #578(Div2)</h2><h3 id=a-模拟>A 模拟</h3><p>水题。</p><h3 id=b-模拟贪心>B 模拟+贪心</h3><p>注意数据非负性的处理。</p><h3 id=c-推式子分组>C 推式子+分组</h3><p>推有关LCM的式子，对于分式的LCM，可以同时乘上分母的LCM。即：
$$
\frac{lcm(\frac{1}{n},\frac{1}{m})}{\frac{1}{n}}=\frac{lcm(\frac{lcm(n.m)}{n},\frac{lcm(n.m)}{m})}{\frac{lcm(n.m)}{n}}=\frac{lcm(\frac{m}{gcd(n,m)},\frac{n}{gcd(n,m)})}{\frac{n}{gcd(n,m)}}=\frac{\frac{m}{gcd(n,m)}}{gcd(\frac{m}{gcd(n,m)},\frac{n}{gcd(n,m)})}
$$
分组，通过ceil完成，n个为1组时，当编号为x的元素位于ceil(1.0L*x/n)组，x为ll故使用long double。</p><h3 id=d-思维二维差分>D 思维+二维差分</h3><p>题意：给定一块n*n的黑白棋盘，可以选定一个规格为k的子棋盘，将其设为白色，问一次操作后最多有几行几列全白。</p><p>预处理每行每列，差分的方式记录可能使其变得全白的子棋盘端点，最后前缀和回来找最大收益的端点。</p><h3 id=e-kmp>E KMP</h3><p>题意：找最长公共前后缀，依次将字符串拼接。</p><p>利用KMP找字串过程中模式串指针的移动最远位置以确定最长公共区域所在的位置。substr拼接即可。</p><p>同时要限制匹配范围要在主串的最后一个长度等于模式串的子串中，最优情况即该子串被完全匹配。</p><h2 id=contest1201-577div2>Contest1201 #577(Div2)</h2><h3 id=a-贪心>A 贪心</h3><p>题意：给定一系列选择题的作答结果以及每题的分数，就最大可能获得的总分。</p><p>贪心分配每一题的答案，将每题答案设为该题出现最多的那个选项。</p><h3 id=b-思维>B 思维</h3><p>题意：给定一系列数，一次操作可以选定两个不同索引的数并将它们同时减一，问是否可能将数组全置零。</p><p>考虑一次操作后，总和减少2，若原数组总和为奇数，必无法全置零。若总和的一半以上都在最大的那个数上，则无法将这数消去，无法置零，若满足max&lt;=sum/2，则可以通过选取最大值所在索引和其余别的索引的方法逐步将最大值消去。</p><h3 id=c-贪心模拟>C 贪心＋模拟</h3><p>题意：给定一组数，每次可以选择一个数将其加一，给定在k次操作下，求该数组的中位数的最大可能值。</p><p>考虑到将数组排序后，将操作置于较小一半部分并不会对答案造成贡献，因此只考虑将中后部分数据进行加一操作。此时考虑贪心，每一系列操作下尽可能的在不改变原顺序下将中位数改变，当且仅当相邻两数不一样时进行操作，计算操作数及创造的收益。若将所有可能的操作执行完了，此时必定满足中位数与最大值一至，再考虑将未进行的操作执行，从后往前尝试靠近中位数，即再在答案上加上k/mid，其中k为剩余操作数，mid为后半部分的数字个数。</p><h3 id=d-贪心类dp>D 贪心+类DP</h3><p>题意：给定一个方格，其中有若干宝藏，角色初始位于左下角，每次移动可选择向上、左、右，但向上移动只能在给定的“安全列”中进行，求收集所有宝藏的最小步数。</p><p>记录每一行的端点宝藏位置，只考虑取到端点宝藏即可。 考虑到每次取完一层的宝藏后，所处的位置仅有两种情况，即最左与最右，此时再次往上走的策略有8种情况，即：停在最左时，从其左边最近的安全列向上，到上一行最左或最右，从其右边最近的安全列向上，到上一行最左或最优，停在最右时同理，此时记录每一行位于最左或者最右端情况下的移动距离，进行DP递推即可。最后答案需加上纵向长度。</p><p>Tips: long long的无穷大还是用0x3f3f3f3f3f3f3f3f为妙。</p><h2 id=contest1202-educational-round-70-div2>Contest1202 Educational Round 70 (Div2)</h2><h3 id=a-二进制贪心>A 二进制+贪心</h3><p>题意：给定两个二进制数A与B，求一个整数K，使得A+B*(2^K)所对应的二进制字符的翻转字典序最小。</p><p>考虑乘上2的幂相当于将二进制数整体左移，翻转后字典序最小，则考虑将翻转后的二进制串的最靠前的1给消除即可，因此寻找第二个串翻转后的第一个1的位置pos，并找到第一个串翻转后再pos之后的第一个1的位置，考虑将这两个1放在同一位即可相加相消，移动的距离即为两个1的距离，即最终的K值。</p><h3 id=b-暴力预处理最短路>B 暴力预处理+最短路</h3><p>题意：给定两个数x,y，并对一个数z进行操作，z初始为0，一轮操作时，将z的个位数输出，并将x和y中的任意一个数加到z上，反复操作可以生成一个输出序列。现给定一个输出序列，该序列可能被抹去一些数据，现需输出一个10*10的矩阵，第x行y列的元素代表当给定数为x,y时，其可能输出序列距离给定的输出序列的最小差距。</p><p>考虑暴力预处理各x,y下两数之间的最小间隔操作次数，如x,y分别为2,3时，从0到5需要的操作次数为2，由于只要考虑0到9各数之间的转换次数，则建立最短路模型，从u到(u+x)%10以及从u到(u+y)%10之间的距离为1，随后通过简单Floyd算法得到各数之间的最小操作间隔。</p><p>随后遍历原序列，判断两个相邻数之间的最小操作次数为多少，若无法到达则该x,y下无法生成该序列，反之将距离-1累加即可。</p><p>需注意在构造最短路时，一个数到其本身的操作次数不为0，不能初始距离为0。</p><h3 id=c>C</h3><h3 id=d-构造贪心二分>D 构造+贪心+二分</h3><p>题意：给定一个数n，构造一个含1、3、7的串，要求其中子序列“1337”的个数恰好为n。</p><p>考虑到3对答案的贡献最大，若3的个数为k，对答案的贡献为k*(k-1)/2，记该贡献为d，则考虑找到一个最大的d满足d&lt;=n，可通过二分查找，此时剩余需求答案为n-d，则考虑将答案构造为"133"+(n-d)个"7"+(d-2)个"3"+&ldquo;7&rdquo;，这样“133”+n-d个“7”对答案产生贡献仅为n-d，前部分的“133”与后续d-2个“3”与最后的“7”，产生贡献d，最终满足子序列个数为n-d+d=n。</p><h2 id=contest1203-579-div3>Contest1203 #579 (Div3)</h2><h3 id=a-模拟-1>A 模拟</h3><p>题意：给定一个序列，判定其是否能按照顺时针或者逆时针成环。</p><p>找出最小值所在位置，向前向后构建数组，判定是否存在顺序情况即可。</p><h3 id=b-特判>B 特判</h3><p>题意：给定一个数n，以及4*n根木棍，判定是否能恰好组成n个面积相同的矩阵。</p><p>考虑矩形对边边长相等，因此可将原4n个木棍长度进行排序，并两两配对，若存在无法配对的情况则无法组成矩形。经过配对后，依次将最小、最大的木棍组成矩形的长宽，计算面积，最后判定所有存在的面积是否一致即可。</p><h3 id=c-整除>C 整除</h3><p>题意：给定一个数字序列，求能够整除所有的元素的数的个数。</p><p>求所有数的公约数，最后判定存该公约数存在多少个因数即可，包括本身及1。</p><h3 id=d1-暴力枚举>D1 暴力枚举</h3><p>题意：给定一个主串与模式串，要求在主串中截取一个区间后，剩余的字符串仍能够匹配模式串，求该区间的最大值。</p><p>Easy version数据范围较小，可枚举区间，判断截取后是否能够形成匹配，并记录最大区间宽度即可。</p><h3 id=d2-预处理思维>D2 预处理+思维</h3><p>题意：如D1，数据范围增至2e5。</p><p>考虑截取情况有三：一是截取开头若干部分，剩余能够匹配，二是截取结尾若干部分，剩余能够匹配，三是截取中间部分，求以上三者的最大值即可。故可预处理模式串中每一个字符最早被匹配的位置以及最迟被匹配的位置。随后答案先在last[1]-1，lens-pre[lent]当中取最大值，分别代表截取开头部分至模式串首字符最迟被匹配的位置，以及截取结尾部分至模式串结尾字符最早被匹配位置。随后遍历模式串，枚举区间存在于模式串的哪两个字符之间，求前一个字符最早被匹配的位置到后一个字符最迟被匹配的位置之间的距离，统计答案即可。</p><p>其中最早匹配位置可顺序遍历进行匹配查找，最迟匹配位置可以倒序遍历匹配即可。</p><h3 id=e-贪心>E 贪心</h3><p>题意：给定一个数字序列，对于每一个数字可以执行加一、减一操作中的其中一个，但不能减至0，求如何操作使得序列中数字个数最大，即有最多不同的数字。</p><p>排序序列，通过map或者开桶记录某一个数是否有生成，若降序排序，优先考虑+1操作，若能不重复地进行则进行，否则后续考虑不变以及减少，并不断通过map记录数据产生即可。</p><h2 id=contest1204-581-div2>Contest1204 #581 (Div2)</h2><h3 id=a-二进制>A 二进制</h3><p>题意：给定一个二进制数，求小于该数的4的幂的个数。</p><p>考虑到4的幂对应的二进制的1出现在奇数位，直接统计在该二进制数长度下最多能在奇数位放下几个1即可，需特判若最高位为奇数位，且较低位没有出现1的话，不能将这个最高奇数位计入答案。</p><h3 id=b-贪心>B 贪心</h3><p>题意：给定一个数n，和一个区间[l,.r]，生成一个长度为n的序列，其中不同的元素个数在该区间内，且对于每一个元素，要么为1，要么为偶数且满足其二分之一也在序列中，求最大与最小序列元素和。</p><p>考虑到元素性质，数的生成必定满足1，2，4，8&mldr;进行，考虑最小元素和，按照2的幂生成出l个元素，随后剩余长度用1填充，对于最大元素和，同理按照2的幂生成出r个元素，剩余用最大元素填充，生成过程中统计答案即可。</p><h3 id=c-最短路思维>C 最短路+思维</h3><p>题意：给定一张图G，和一个序列P，求一个P的最小子序列D，满足在路径D下，所经过的最短路径仍为P。</p><p>考虑一个序列ABC，若A到C中存在一个更短的路径，则B必须被包含在答案中，否则在最短路径下，路径为AC，不满足与原序列ABC一致，反之若AC之间的最短路径必定等于2，即需要走路径ABC，则B可以被去除，去除后A到C的最短路为ABC，仍与原序列一致。因此考虑对原图求最短路后，其中起点和终点需要被加入答案序列，依次遍历序列元素X，若满足答案序列的最后一个元素cnt到X的距离加上X到X+1的距离等于2，即最短路唯一，元素X可不被加入答案序列，反之若存在cnt到X+1的更短路，则X必须被加入答案序列。</p><h3 id=d-思维lis>D 思维+LIS</h3><p>题意：给定一个01序列s，求另一个01序列t，满足对于任意区间[l,r]，s与t在该区间中的最长LIS长度一样。且保障t序列中的0是最多的。</p><p>考虑将原序列s中的1变成0，若在该位后面的最长LIS是以1开头的，则改变后对LIS长度变化无影响，若最长LIS为0开头的，则将1变成0则对LIS的长度产生了一个贡献，因此考虑对每一个1进行操作抉择时，其后面的最长LIS必定是1开头的。对于最长LIS开头必为1，其充要条件为后面的1的个数大于等于0的个数，若0的个数较大，则该部分0就能组成最长LIS。故倒序统计01个数，在遍历到1时，若1的个数大于等于0的个数则将该1变为0即可。</p><h2 id=contest1206-580-div2>Contest1206 #580 (Div2)</h2><h3 id=a-暴力枚举>A 暴力枚举</h3><p>题意：给定两个数组A，B，问A与B是否存在元素a，b，使得a+b即不出现在A中也不出现在B中。</p><p>map记录各数组的数字出现情况，暴力枚举各种组合，判断是否同时不出现即可。</p><h3 id=b-贪心-1>B 贪心</h3><p>题意：给定一个数组，可对每个元素进行加一减一的操作，问最小操作次数使得所有元素的乘积为1。</p><p>考虑将其变成全1或者其中包含偶数个-1。对原数组进行升序排序，遍历数组，若元素值为0，则进行一次加一操作，若元素为负数，则考虑将其本身与其下一个元素也变成-1，这样比到1的距离要小，若最后一个元素也为负数，只能变成1了，若为正数则直接变成1，过程中记录操作次数即可。</p><h3 id=c-思维构造>C 思维+构造</h3><p>题意：给定一个数n，求是否存在一个长度为2*n的环，将环上所有连续n个数的和组成一个集合，该集合元素的最大最小值之差不超过1。</p><p>考虑n为环的长度的一半，每次将连续长度为n的序列进行1位偏移，生成的新序列和与原序列和之间的差值不超过1，则考虑两端元素差值不超过1，即为相邻元素，且距离最远，因此考虑相邻元素按照最远距离分配，手动构造若干样例易知，当n为偶数时无法完成构造，当n为奇数时，考虑将相邻元素按照最远距离分配，可分奇偶进行分配，代码如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>n;i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>) {       	<span style=color:#75715e>//保证2*i-1与2*i之间距离最大
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ans[i]<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            ans[i<span style=color:#f92672>+</span>n]<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>i;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            ans[i]<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>i;		<span style=color:#75715e>//通过模拟可知这样的操作能够保证序列和的平衡，将本组较小与上组较大靠近
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ans[i<span style=color:#f92672>+</span>n]<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#75715e>//生成过程：1xx2xx -&gt; 14x23x -&gt; 145236  分奇偶一正一反
</span></span></span></code></pre></div><h3 id=d-鸽巢思维最小环>D 鸽巢思维+最小环</h3><p>题意：给定一个长度为n数组，若存在两个数组元素满足其按位与的结果不为0，则在他们之间连接一个长度为1的边，求最终组成的图上的最小环。</p><p>关键需考虑到，如果对于某一位，有大于等于3个元素该位为1，则最小环必为3，这样的特性能够降低许多情况的判定，考虑极限情况，63位中每一位为1的数都有两个，此时已有126个数，若再多一个数，根据容斥原理，此时必能够产生某一位有大于等于3个元素该位为1，因此当非0数的个数大于126时，直接判定结果为3即可。</p><p>反之进行最小环求解，问题规模仅有126，可用Floyd求解最小环。</p><p>对于Floyd求解最小环，当遍历到中间点k时，此时所有点之间的最短路G(i,j)的具体路径都不包含k，此时求一下G(i,j)+dis(j,k)+dis(k,i)即当前环，记录最小值即可。其中G(i,j)代表i,j之间不经过k的最短路，dis(j,k)与dis(k,i)代表原来的距离，相当于求路径i->j->k->i这样一个环的长度。代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>ll ans<span style=color:#f92672>=</span>INF;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;k<span style=color:#f92672>&lt;=</span>n;k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;</span>k;i<span style=color:#f92672>++</span>) {	<span style=color:#75715e>//枚举范围[1,k) 先记忆 后续可逐步理解
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span>i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;j<span style=color:#f92672>&lt;</span>k;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                ans<span style=color:#f92672>=</span>min(ans,<span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>G[i][j]<span style=color:#f92672>+</span>dis[j][k]<span style=color:#f92672>+</span>dis[k][i]);  <span style=color:#75715e>//防爆加上1ll*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>n;i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;j<span style=color:#f92672>&lt;=</span>n;j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                G[i][j]<span style=color:#f92672>=</span>min(G[i][j],G[i][k]<span style=color:#f92672>+</span>G[k][j]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(ans<span style=color:#f92672>==</span>INF) ans<span style=color:#f92672>=-</span><span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><h2 id=contest1207-educational-round-71-div2>Contest1207 Educational Round 71 (Div2)</h2><h3 id=a-枚举>A 枚举</h3><p>题意：给定面包的数量b，牛肉p，鸡肉f，并给出牛肉堡和鸡肉堡的价格，求最大收益。</p><p>暴力枚举制作的个数，注意枚举范围要从0开始，记录最大值即可。</p><h3 id=b-模拟>B 模拟</h3><p>题意：给定一个n行m列的01矩阵，定义一次操作可以选定一个2*2的子矩阵并将其全置为1，问是否存在一种操作方案使得一个n行m列的全0矩阵变成输入的01矩阵。</p><p>遍历原矩阵，若以枚举点为左上角的子矩阵为全1，记录该点，随后根据记录的点，将一个全0矩阵进行操作，最后判断操作后矩阵与原输入矩阵是否一致，若一致则输出记录点即可。</p><h3 id=c-dp贪心>C DP/贪心</h3><p>题意：给定一个数轴0~n，一共有n个区间[x,x+1]，其中x为整数，范围为0~n-1，每一个区间有一个01值，若为1，则代表该位有一个十字路口，现需要在整个数轴上搭建管道，若区间为十字路口，必须将管道抬升至2，否则高度可以是1，但高度从1到0或者从0到1都需要1个单位的多余管道，且在每个整数点都需要搭建支柱来支撑管道，且每个单位的支柱个管道都有单独的花费，求最小的花费。如下图为例。</p><div align=center><img src=/images/CFVP/1207C.png alt=1207C style=zoom:25%></div><p>DP解决，定义dp数组dp[x][u]，其中u取值为0，1，dp[x][1]代表第x个节点下抬高水管的最小花费，dp[x][0]代表在第x个节点下不抬高水管的最小花费，初始状态为dp[0][0]=b,dp[0][1]=INF，代表在第0个节点下，只能够不抬高，此时花费为一个单位的支柱，抬高花费为INF。随后遍历01序列，若为0则将对应节点下的抬高与不抬高的情况都考虑，反之则只考虑抬高情况，将不抬高情况设置为INF，具体转移方程如代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>	dp[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span>b; 			<span style=color:#75715e>//a为单位水管的价格 b为单位支柱的价格
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    dp[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span><span style=color:#ae81ff>1e15</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(s[i]<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;0&#39;</span>) {   <span style=color:#75715e>//若为0，则两种都考虑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span>min(dp[i][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>+</span>a<span style=color:#f92672>+</span>b,dp[i][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>a<span style=color:#f92672>+</span>b);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//0-&gt;0考虑一单位支柱和一单位水管   1-&gt;0考虑一单位支柱和两单位水管
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span>min(dp[i][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>a<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>b,dp[i][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>+</span>a<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>b);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//0-&gt;1考虑两单位水管和两单位支柱   1-&gt;1考虑两单位支柱和一单位水管
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>//若为1，必须抬高 且从前一个支柱开始就应当抬高 如图可看出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span>dp[i][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>+</span>a<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>b;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//只从1转移到1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span><span style=color:#ae81ff>1e15</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//对应的0直接设置为无穷大
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>dp[n][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span></code></pre></div><h3 id=d-容斥组合>D 容斥+组合</h3><p>题意：给定一个数对序列(ai,bi)，可对该序列进行随意排序，并定义一个序列中所有数对的第一个元素单调不减或者第二个元素单调不减，则称该序列为bad序列，求所有非bad序列的排列情况数。</p><p>正难则反，非bad序列数=总排列数-bad序列数=总排列数-(第一个元素单调不减序列数+第二个元素单调不减序列数-两个元素均单调不减序列数)。预处理到n的阶乘，总排列数位n的阶乘。随后将序列按照第一个元素进行升序排序，遍历序列，统计可能产生的序列数（不断乘上连续相同的数的个数的阶乘，即将连续相同的数进行排列的情况），同理按照第二个元素进行升序统计可能的序列数。最后按照主次排序进行升序排序，判断是否满足都为单调不减序列，若不是，则两个元素均单调不减序列数为0，反之按照以上手法（乘上两个数都相同的个数的阶乘），统计可能产生的序列数。最后计算答案即可，注意减法减后要加上模数(a-b)%mod=(a-b+mod)%mod。</p><h2 id=contest1213-582-div3>Contest1213 #582 (Div3)</h2><h3 id=a-枚举-1>A 枚举</h3><p>题意：给定一个序列，对每个元素可进行加减1操作，花费为1，加减2操作，花费为0，求最少花费使得所有元素相等。</p><p>暴力枚举达到点，相距奇数则记花费，统计最小花费即可。</p><h3 id=b-模拟-1>B 模拟</h3><p>题意：给定一个序列，求满足在其之后存在更小值的元素个数。</p><p>倒序遍历数组，记录最小值，若满足元素大于所记录的最小值则答案加一。</p><h3 id=c-简单计数>C 简单计数</h3><p>题意：给定一本n页的书，每翻m页记录一次页码，求所有页码的个位数之和。</p><p>考虑到页码的个位数每十次必有一次循环，先记录一次循环的贡献sig，总共有d=n/m个被记录的页码，答案则为sig*d，再加上剩余不成一次循环的个位数贡献。</p><h3 id=d-预处理>D 预处理</h3><p>题意：给定一个序列，对每个元素可进行除二下取整操作，求最小操作次数，使得该序列中有k个相同的元素。</p><p>简单版本枚举终点暴力计算即可。</p><p>预处理每一个数到其能到达的所有数的操作次数并记录，该复杂度为log级别，对于每一个可能的数到达的数，使用vector记录序列元素到它的距离。随后遍历终点，若对应的vector规格小于k则跳过，反之取vector中最小的k个元素的和，记录最小值作为答案。该复杂度为O(nlogW)+O(W)。</p><h3 id=e--字符串构造>E 字符串构造？</h3><h3 id=g-离线kruskal思想>G 离线+Kruskal思想</h3><p>题意：给定一颗有n个节点的树，每条边有边权，给定m次询问，每次询问给定一个w，求点对(u,v)的个数，使得该点对的路径上的最大值小于等于w。</p><p>对询问离线计算。记录所有询问以及边的信息，按照询问的权值以及边的权值进行排序，遍历询问，对于一次询问w，遍历所有小于该w的边，（此时需记录边的遍历开头位置，下一个询问时不能从头开始遍历边），对边连接的两个节点进行判定，若不为同一个集合，则将其对应的集合的集合元素个数siz相乘记录于答案中，并将其合并即可。</p><p>需注意合并过程中需要将记录集合元素个数的数组siz更新。即为s[v]=u;siz[u]+=siz[v];siz[v]=0; 即将v接到u上，将信息记录在u上面。</p><hr><h2 id=数据结构>数据结构</h2><h4 id=1791f-区间记录操作性质判定-1500>1791F 区间记录+操作性质判定 1500</h4><h5 id=题意>题意</h5><p>给定一个长度为n的数组，进行q次操作，操作1为将区间[l,r]中的数变成其数位和，操作2为求第x个数的值。</p><h5 id=分析>分析</h5><p>对于任意一个数，进行至少三次求数位和操作后便保持不变，因此考虑使用线段树记录每个数的操作次数，该操作次数不会超过三次，对于操作2，单点查询目标的操作次数，直接暴力求结果即可。</p><h5 id=补充>补充</h5><p>对于线段树维护区间某一操作结果的时候，通常考虑该操作本身具有的性质，一般会有收敛。</p><h2 id=构造>构造</h2><h4 id=1806c-分类讨论构造-1600>1806C 分类讨论+构造 1600</h4><h5 id=题意-1>题意</h5><p>给定一个数m以及一个长度为2*m的数组，取其中m个元素，使得其乘积与剩下m个元素之和相等，则称该数组为good，求原数组到一个good数组的最短距离。</p><h5 id=分析-1>分析</h5><p>考虑到对于任意的m，[0,0,&mldr;,0]一定是一个good数组。当m等于1时，[x,x]也为一个good数组，当m等于2时，[2,2,2,2]和[-1,-1,-1,2]也为good数组，当m为偶数时，对于任意的m，都存在一个good数组为[-1,-1,-1&mldr;.,m]，而m为奇数时则无另外解。</p><p>good数组的解仅有以上若干种情况，依次讨论计算原数组与其的距离即可。</p><h4 id=1758d-分奇偶构造-1800>1758D 分奇偶构造 1800</h4><h5 id=题意-2>题意</h5><p>构造一个长度为n的序列，使得序列最大最小值之差等于序列和的根号</p><h5 id=分析-2>分析</h5><p>构造方法：对于偶数，取最大值最小值的差为n，两边关于n对称即可。如n=6时，3，4，5，7，8，9，即为[n-n/2,n-1],[n+1,n+n/2].</p><p>对于奇数，不妨取最大最小值的差为n+1，分为两段[n+2-(n+1)/2,n],[n+3,n+2+(n+1)/2]。</p><h2 id=数学>数学</h2><h4 id=1766d-整数性质gcd分析-1600>1766D 整数性质+gcd分析 1600</h4><h5 id=题意-3>题意</h5><p>对于两个数x，y，找到一个最小的自然数k使得gcd(x+k,y+k)！=1，若找不到则输出-1。</p><h5 id=分析-3>分析</h5><p>不妨设k存在，则存在一个m>=2，使得m|(x+k)，m|(y+k)。</p><p>由整除的性质可得m|(x+k-y-k)，即m|(x-y)，设x-y＝d，即m|d。</p><p>问题转化为在d的因子中找一个m使得k最小。</p><p>则遍历d的质因子即可，对于一个质因子w，满足w|(x+k)，则对应的一个k可以表示为w-x%w，记录最小的k即可。</p><h5 id=补充-1>补充</h5><p>对于快速遍历一个数的质因子，可以考虑在埃氏筛中将vis数组赋值为其对应的最小质因子，即vis[x]代表x的最小质因子，每次不断除vis[x]即可。</p><p>满足w|(x+k)，则对应的一个k可以表示为w-x%w。（w-x%w+x）整除w恒成立。</p><h2 id=图>图</h2><h4 id=1362d-拓扑序验证-1700>1362D 拓扑序验证 1700</h4><h5 id=题意-4>题意</h5><p>给定n个博客以及m条引用关系，给定n个数，代表每条博客的期望主题号p，且需满足对于每一个博客发布时，所有小于它的主题号p均要被发布，请给出一个博客发出顺序，若无法发出则-1。</p><h5 id=分析-4>分析</h5><p>即拓扑序的验证，对于每一个节点，遍历其邻居，若邻居中没有所有小于他的权值的节点则-1，若存在一样的权值也是-1。完成验证后，仅需要根据主题号p进行排序输出id即可。</p><h4 id=1805d-树的直径>1805D 树的直径</h4><h5 id=题意-5>题意</h5><p>给定一颗树以及一张图G，对于树上两个节点u，v，如果其距离大于等于k，则这两个节点在图中有一条连边，求不同的k下，图上的连通块个数。</p><h5 id=分析-5>分析</h5><p>对于树的直径d，如果k大于d，即树上最远的距离都比k小，则对应的图无连边，所有节点孤立。设该直径的起始点为st和ed，对于树上任意一点，其到直径两个端点的距离如果都小于k，证明该点肯定无法进行连边，属于一个孤立节点，因此只需要计算所有点到两个直径端点的最大值dis，将其升序排序。随后遍历k，对于每一个k，找到所有dis小于k的个数，加一后即为当前的连通块数目。</p><h5 id=补充-2>补充</h5><p>对于树的直径求法，从任意一点dfs找到最大深度点，再从该点进行dfs找到另一最大深度点，这两点之间的距离即为树的直径。</p><h2 id=搜索>搜索</h2><h4 id=1365d-bfs预先处理-1700>1365D BFS+预先处理 1700</h4><h5 id=题意-6>题意</h5><p>给定一张地图，其中包含好人和坏人以及障碍，问是否存在一种放置障碍的方式，使得所有好人能到终点但是坏人不行。</p><h5 id=分析-6>分析</h5><p>简单BFS，将所有坏人围起来然后从终点跑BFS，看看能不能跑到所有好人即可。</p><h2 id=位运算>位运算</h2><h4 id=1775c-的性质位模拟-1600>1775C &的性质+位模拟 1600</h4><h5 id=题意-7>题意</h5><p>给出两个正整数n，x，找出一个最小的整数m使得n&(n+1)&(n+2)&mldr;&amp;m==x。</p><h5 id=分析-7>分析</h5><p>模拟分析即可。对于x->y，若y的某一位是1但是x的某一位是0，则必定无法完成操作。对于某一位x，y都是1的，找最高位都是1的，将它的高一位变成1，后面全变成0即可。如果在x，y都是1的位的再高位还有x为1，y为0的位，则必然不能完成操作，反之也记录该最高位即可。</p><h2 id=杂项>杂项</h2><h4 id=1792c-双指针-1500>1792C 双指针 1500</h4><h5 id=题意-8>题意</h5><p>给定一个排列，每次操作可以任取其中两个数，将较小者放到第一位，将较大者放到最后一位，求将排列变得递增的最小操作次数。</p><h5 id=分析-8>分析</h5><p>考虑使用双指针操作，一开始将头指针指向第一个数，将尾指针指向最后一个数，每一次循环时，若数已经出现过则将指针进行移动，同时记录一个全局的now，若头指针指向的数不为now或者尾指针指向的数不为n-now+1，则代表now和n-now+1并未配对或者不在位置，需要进行一次操作并进行标记，同时now加一。仅需要考虑now和n-now+1是否配对即可，具体每对的顺序可以进行独立调整。</p><h5 id=代码>代码</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>//2 1 4 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (vis[a[l]]) l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (vis[a[r]]) r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&gt;=</span> r) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a[l] <span style=color:#f92672>!=</span> now <span style=color:#f92672>||</span> a[r] <span style=color:#f92672>!=</span> n <span style=color:#f92672>-</span> now <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) ans <span style=color:#f92672>=</span> now;
</span></span><span style=display:flex><span>    vis[now] <span style=color:#f92672>=</span> vis[n <span style=color:#f92672>-</span> now <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    now<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=1779c-前缀和分析优先队列-1600>1779C 前缀和分析+优先队列 1600</h4><h5 id=题意-9>题意</h5><p>给定一个长度为n的数组a，对于每一次操作，可以选择其中一个数将其置反，同时给定一个m，要求前缀和sum[1,m]为所有前缀和中最小的，求最小的操作次数。</p><h5 id=分析-9>分析</h5><p>对于式子sum[1,m]&lt;=sum[1,1]，sum[1,m]&lt;=sum[1,2]，sum[1,m]&lt;=sum[1,3]&mldr;sum[1,m]&lt;=sum[1,m-1]，可以将其转化为以下形式，</p><p>sum[2,m]&lt;=0,sum[3,m]&lt;=0,sum[m,m]&lt;=0，同理有sum[m+1,n]>=0,sum[m+2,n]>=0,sum[n,n]>=0。</p><p>则分别从m+1到n运算前缀和，若前缀和出现小于0，则在优先队列中弹出最小的负数将其置反；从m到2运算前缀和，即m向左开始累加，若出现大于0，则从优先队列中弹出最大的正数取反。</p><h4 id=1781c-字符串暴力枚举-1600>1781C 字符串+暴力枚举 1600</h4><h5 id=题意-10>题意</h5><p>给出一个长度为n的字符串(1&lt;=n&lt;=1e5)，每个字符都是小写字母。你可以多次对其进行操作：选择任意一个位置的字母将其变为另一个任意字母，要求最终字符串中所有出现过的字母的出现次数相同。求满足条件所需要的最小操作数。</p><h5 id=分析-10>分析</h5><p>出现次数越多的字符越容易被留下，考虑对字符的出现次数进行即降序排序，且最终出现次数一定是字符串长度n的因子，考虑枚举最终答案，对于最终每个字符出现次数x，遍历数量最多的n/x个字符，记录其比最终答案的差距，剩余字符全部记录于多余字符部分，随后不断将多了字符分配到较小字符处即可。</p><h4 id=1783c-排序贪心-1700>1783C 排序+贪心 1700</h4><h5 id=题意-11>题意</h5><p>有n个选手，编号从1到n，大编号者本身能战胜小编号者，现给定时间m，若要打败选手i，需要花费时间a[i]，在循环赛后，即两两打斗，依据胜场数来排名次，求最小名次。</p><h5 id=分析-11>分析</h5><p>考虑贪心，能战胜的场数越多越好，因此考虑将花费时间a进行排序，循环在m的时限内最多能够战胜的人数，倘若能够战胜x个人了（按照a升序的前x个人），如果不打前面那个第x个人，但是能够战胜第x+1人（原顺序的第x+1人），则可以考虑将前面最后一个打的人转移到打这个人，如果能打过，名次还能够继续上升。</p><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></div><div class="row items-start justify-between"><div class="lg:col-5 mb-10 flex items-center lg:mb-0"><h5 class=mr-3>标签 :</h5><ul><li class=inline-block><a class="bg-theme-light hover:bg-primary dark:bg-darkmode-theme-light dark:hover:bg-darkmode-primary dark:hover:text-dark m-1 block rounded px-3 py-1 hover:text-white" href=/en/tags/%e8%ae%ad%e7%bb%83%e8%ae%b0%e5%bd%95/>训练记录</a></li></ul></div></div></article></div></div></section></main><footer class="bg-theme-light dark:bg-darkmode-theme-light"><div class=container><div class="row items-center py-10"><div class="lg:col-3 mb-8 text-center lg:mb-0 lg:text-left"><a class="navbar-brand inline-block" href=/en/><img fetchpriority=high decoding=async class="img logo-light" width=160 height=32 src=/images/logo-1_hubf409f6fc77577ff09f7cacc73653041_8513_320x0_resize_q80_h2_lanczos_3.webp alt=Hugoplate onerror='this.onerror=null,this.src="/images/logo-1_hubf409f6fc77577ff09f7cacc73653041_8513_320x0_resize_lanczos_3.png"'>
<img fetchpriority=high decoding=async class="img logo-dark" width=160 height=32 src=/images/logo-2_hu06a606f114baa5722e40403b02652855_7961_320x0_resize_q80_h2_lanczos_3.webp alt=Hugoplate onerror='this.onerror=null,this.src="/images/logo-2_hu06a606f114baa5722e40403b02652855_7961_320x0_resize_lanczos_3.png"'></a></div><div class="lg:col-6 mb-8 text-center lg:mb-0"><ul><li class="m-3 inline-block"><a href=/en/about/>个人信息</a></li><li class="m-3 inline-block"><a href=/en/blog/>学习笔记</a></li><li class="m-3 inline-block"><a href=/en/privacy-policy/>相关说明</a></li></ul></div><div class="lg:col-3 mb-8 text-center lg:mb-0 lg:mt-0 lg:text-right"><ul class=social-icons><li><a target=_blank aria-label=github rel="nofollow noopener" href=https://www.github.com/COOOIKX><i class="fab fa-github"></i></a></li><li><a target=_blank aria-label=csdn rel="nofollow noopener" href="https://blog.csdn.net/m0_59701064?spm=1000.2115.3001.5343"><i class="fas fa-home-lg"></i></a></li></ul></div></div></div><div class="border-border dark:border-darkmode-border border-t py-7"><div class="text-light dark:text-darkmode-light container text-center"><p>Designed by Zeon Studio and Developed by LHF</p></div></div></footer><script crossorigin=anonymous integrity="sha256-YQerunHGeT7hXzxweSqFUXgOHHxFceSjmMy/kmnAHWU=" src=/js/script.min.6107abba71c6793ee15f3c70792a8551780e1c7c4571e4a398ccbf9269c01d65.js></script><script defer async crossorigin=anonymous integrity="sha256-w+aS42D2+B+Jix+joZ7pAua1vbu/pRK/IhoP55b8n3w=" src=/js/script-lazy.min.c3e692e360f6f81f898b1fa3a19ee902e6b5bdbbbfa512bf221a0fe796fc9f7c.js></script><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></body></html>