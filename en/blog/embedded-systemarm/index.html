<!doctype html><html itemscope lang=en-us itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=5"><meta name=theme-name content="hugoplate"><link rel="shortcut icon" href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_96x0_resize_lanczos_3.png type=image/x-icon><link rel=icon href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_96x0_resize_lanczos_3.png type=image/x-icon><link rel=icon type=image/png sizes=48x48 href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_48x0_resize_lanczos_3.png><link rel=icon type=image/png sizes=96x96 href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_96x0_resize_lanczos_3.png><link rel=apple-touch-icon sizes=144x144 href=/images/favicon_hueb84ecec72665a83aae8c940dfe71474_1906_144x0_resize_lanczos_3.png><link rel=manifest href=/manifest.webmanifest><meta name=msapplication-TileColor content="#ddd"><meta name=theme-color content="#ffffff"><base href=https://lhfgghc.github.io/en/blog/embedded-systemarm/><title>【课程笔记】嵌入式系统-ARM部分</title>
<meta name=keywords content="Boilerplate,Hugo"><meta name=description content="this is meta description"><meta name=author content="zeon.studio"><meta property="og:image" content="https://lhfgghc.github.io/images/og-image.png"><meta name=twitter:image content="https://lhfgghc.github.io/images/og-image.png"><meta name=twitter:card content="summary_large_image"><meta property="og:image:width" content="900"><meta property="og:image:height" content="600"><meta property="og:image:type" content="image/
        .png
      "><meta property="og:title" content="【课程笔记】嵌入式系统-ARM部分"><meta property="og:description" content="this is meta description"><meta property="og:type" content="website"><meta property="og:url" content="https://lhfgghc.github.io/en/blog/embedded-systemarm/"><meta name=twitter:title content="【课程笔记】嵌入式系统-ARM部分"><meta name=twitter:description content="this is meta description"><script>let indexURL="https://lhfgghc.github.io/en/searchindex.json",includeSectionsInSearch=["blog"],search_no_results="未找到结果",search_initial_message="输入内容以搜索"</script><meta http-equiv=x-dns-prefetch-control content="on"><link rel=preconnect href=https://use.fontawesome.com crossorigin><link rel=preconnect href=//cdnjs.cloudflare.com><link rel=preconnect href=//www.googletagmanager.com><link rel=preconnect href=//www.google-analytics.com><link rel=dns-prefetch href=https://use.fontawesome.com><link rel=dns-prefetch href=//ajax.googleapis.com><link rel=dns-prefetch href=//cdnjs.cloudflare.com><link rel=dns-prefetch href=//www.googletagmanager.com><link rel=dns-prefetch href=//www.google-analytics.com><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//connect.facebook.net><link rel=dns-prefetch href=//platform.linkedin.com><link rel=dns-prefetch href=//platform.twitter.com><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;600&family=Signika:wght@500;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><link href="/css/style.min.4c1d4c3120637c4b33d33d38988a2525a8e15057b5ab0cfa95ce5147d4c95adc.css" integrity="sha256-TB1MMSBjfEsz0z04mIolJajhUFe1qwz6lc5RR9TJWtw=" rel=stylesheet><link defer async rel=stylesheet href="/css/style-lazy.min.ec14d2549e8e0fbaf9af20dcc88fad37fb352e5bd5978a801dc1c3f5a5922174.css" integrity="sha256-7BTSVJ6OD7r5ryDcyI+tN/s1LlvVl4qAHcHD9aWSIXQ=" media=print onload='this.media="all",this.onload=null'></head><body><header class="header sticky top-0 z-30"><nav class="navbar container"><div class=order-0><a class="navbar-brand block" href=/en/><img fetchpriority=high decoding=async class="img logo-light" width=160 height=32 src=/images/logo-1_hubf409f6fc77577ff09f7cacc73653041_8513_320x0_resize_q80_h2_lanczos_3.webp alt=Hugoplate onerror='this.onerror=null,this.src="/images/logo-1_hubf409f6fc77577ff09f7cacc73653041_8513_320x0_resize_lanczos_3.png"'>
<img fetchpriority=high decoding=async class="img logo-dark" width=160 height=32 src=/images/logo-2_hu06a606f114baa5722e40403b02652855_7961_320x0_resize_q80_h2_lanczos_3.webp alt=Hugoplate onerror='this.onerror=null,this.src="/images/logo-2_hu06a606f114baa5722e40403b02652855_7961_320x0_resize_lanczos_3.png"'></a></div><input id=nav-toggle type=checkbox class=hidden>
<label for=nav-toggle class="order-3 cursor-pointer flex items-center lg:hidden text-dark dark:text-white lg:order-1"><svg id="show-button" class="h-6 fill-current block" viewBox="0 0 20 20"><title>Menu Open</title><path d="M0 3h20v2H0V3zm0 6h20v2H0V9zm0 6h20v2H0V0z"/></svg><svg id="hide-button" class="h-6 fill-current hidden" viewBox="0 0 20 20"><title>Menu Close</title><polygon points="11 9 22 9 22 11 11 11 11 22 9 22 9 11 -2 11 -2 9 9 9 9 -2 11 -2" transform="rotate(45 10 10)"/></svg></label><ul id=nav-menu class="navbar-nav order-3 hidden lg:flex w-full pb-6 lg:order-1 lg:w-auto lg:space-x-2 lg:pb-0 xl:space-x-8"><li class=nav-item><a class=nav-link href=/en/>主页</a></li><li class=nav-item><a class=nav-link href=/en/blog/>学习笔记</a></li><li class=nav-item><a class=nav-link href=/en/about/>个人信息</a></li><li class="nav-item nav-dropdown group relative"><span class="nav-link
inline-flex items-center">其它<svg class="h-4 w-4 fill-current" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></span><ul class="nav-dropdown-list lg:group-hover:visible lg:group-hover:opacity-100"><li class=nav-dropdown-item><a class=nav-dropdown-link href=/en/elements/>样式Draft</a></li><li class=nav-dropdown-item><a class=nav-dropdown-link href=/en/privacy-policy/>相关说明</a></li><li class=nav-dropdown-item><a class=nav-dropdown-link href=/en/categories/>笔记分类</a></li></ul></li></ul><div class="order-1 ml-auto flex items-center md:order-2 lg:ml-0"><button aria-label=search class="border-border text-dark hover:text-primary dark:border-darkmode-border mr-5 inline-block border-r pr-5 text-xl dark:text-white dark:hover:text-darkmode-primary" data-target=search-modal>
<i class="fa-solid fa-search"></i></button><div class="theme-switcher mr-5"><input id=theme-switcher data-theme-switcher type=checkbox>
<label for=theme-switcher><span class=sr-only>theme switcher</span>
<span><svg class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-10 opacity-100 dark:opacity-0" viewBox="0 0 56 56" fill="#fff" height="16" width="16"><path d="M30 4.6c0-1-.9-2-2-2a2 2 0 00-2 2v5c0 1 .9 2 2 2s2-1 2-2zm9.6 9a2 2 0 000 2.8c.8.8 2 .8 2.9.0L46 13a2 2 0 000-2.9 2 2 0 00-3 0zm-26 2.8c.7.8 2 .8 2.8.0.8-.7.8-2 0-2.9L13 10c-.7-.7-2-.8-2.9.0-.7.8-.7 2.1.0 3zM28 16A12 12 0 0016 28a12 12 0 0012 12 12 12 0 0012-12A12 12 0 0028 16zm23.3 14c1.1.0 2-.9 2-2s-.9-2-2-2h-4.9a2 2 0 00-2 2c0 1.1 1 2 2 2zM4.7 26a2 2 0 00-2 2c0 1.1.9 2 2 2h4.9c1 0 2-.9 2-2s-1-2-2-2zm37.8 13.6a2 2 0 00-3 0 2 2 0 000 2.9l3.6 3.5a2 2 0 002.9.0c.8-.8.8-2.1.0-3zM10 43.1a2 2 0 000 2.9c.8.7 2.1.8 3 0l3.4-3.5c.8-.8.8-2.1.0-2.9s-2-.8-2.9.0zm20 3.4c0-1.1-.9-2-2-2a2 2 0 00-2 2v4.9c0 1 .9 2 2 2s2-1 2-2z"/></svg><svg class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-10 opacity-0 dark:opacity-100" viewBox="0 0 24 24" fill="none" height="16" width="16"><path fill="#000" fill-rule="evenodd" clip-rule="evenodd" d="M8.2 2.2c1-.4 2 .6 1.6 1.5-1 3-.4 6.4 1.8 8.7a8.4 8.4.0 008.7 1.8c1-.3 2 .5 1.5 1.5v.1A10.3 10.3.0 0112.4 22 10.3 10.3.0 013.2 6.7c1-2 2.9-3.5 4.9-4.4z"/></svg></span></label></div><script>var darkMode=!1,themeSwitch;window.matchMedia("(prefers-color-scheme: dark)").matches&&(darkMode=!0),localStorage.getItem("theme")==="dark"?darkMode=!0:localStorage.getItem("theme")==="light"&&(darkMode=!1),darkMode&&document.documentElement.classList.toggle("dark"),themeSwitch=document.querySelectorAll("[data-theme-switcher]"),document.addEventListener("DOMContentLoaded",()=>{[].forEach.call(themeSwitch,function(e){e.checked=!!darkMode,e.addEventListener("click",()=>{document.documentElement.classList.toggle("dark"),localStorage.setItem("theme",document.documentElement.classList.contains("dark")?"dark":"light")})})})</script></div></nav></header><div class=search-modal aria-hidden=true style=--color-primary:#121212><div data-target=close-search-modal class=search-modal-overlay></div><div class=search-wrapper data-image=true data-description=true data-tags=true data-categories=true><div class=search-wrapper-header><label for=search-modal-input style=margin-top:-1px><span class=sr-only>search icon</span>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-icon" data-type="search"><path fill="currentcolor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18" width="18" class="search-reset" data-type="reset"><path fill="currentcolor" d="M256 512A256 256 0 10256 0a256 256 0 100 512zM175 175c9.4-9.4 24.6-9.4 33.9.0l47 47 47-47c9.4-9.4 24.6-9.4 33.9.0s9.4 24.6.0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6.0 33.9s-24.6 9.4-33.9.0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9.0s-9.4-24.6.0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6.0-33.9z"/></svg>
</label><input id=search-modal-input type=text data-search-input autocomplete=off aria-label=Search placeholder=搜索></div><div class=search-wrapper-body><div class=search-result data-search-result></div><span class=search-result-empty>输入内容以搜索</span></div><div class=search-wrapper-footer><span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" viewBox="0 0 16 16"><path d="M3.204 11h9.592L8 5.519 3.204 11zm-.753-.659 4.796-5.48a1 1 0 011.506.0l4.796 5.48c.566.647.106 1.659-.753 1.659H3.204a1 1 0 01-.753-1.659z"/></svg>
</kbd><kbd><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentcolor" style="margin-top:1px" viewBox="0 0 16 16"><path d="M3.204 5h9.592L8 10.481 3.204 5zm-.753.659 4.796 5.48a1 1 0 001.506.0l4.796-5.48c.566-.647.106-1.659-.753-1.659H3.204a1 1 0 00-.753 1.659z"/></svg>
</kbd>导航
</span><span><kbd><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentcolor" style="display:inline-block" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14.5 1.5a.5.5.0 01.5.5v4.8a2.5 2.5.0 01-2.5 2.5H2.707l3.347 3.346a.5.5.0 01-.708.708l-4.2-4.2a.5.5.0 010-.708l4-4a.5.5.0 11.708.708L2.707 8.3H12.5A1.5 1.5.0 0014 6.8V2a.5.5.0 01.5-.5z"/></svg>
</kbd>选择
</span><span class=search-result-info></span>
<span data-target=close-search-modal><kbd>ESC</kbd> 关闭</span></div></div></div><main><section class="section pt-7"><div class=container><div class="row justify-center"><article class=lg:col-10><h1 class="h2 mb-4">【课程笔记】嵌入式系统-ARM部分</h1><ul class=mb-4><li class="mr-4 inline-block"><a href=/en/authors/liang-hangfeng/><i class="fa-regular fa-circle-user mr-2"></i>Liang Hangfeng</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-folder mr-2"></i>
<a href=/en/categories/%e8%af%be%e7%a8%8b%e7%ac%94%e8%ae%b0/>课程笔记</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-clock mr-2"></i>
March 2, 2024</li></ul><div class="content mb-10"><h2 id=arm体系结构>ARM体系结构</h2><h3 id=一嵌入式系统概述>一、嵌入式系统概述</h3><h4 id=概念>概念</h4><ol><li>以应用为中心，以计算机技术为基础、软件硬件可裁剪、适应于各种应用系统专用计算机。</li><li>嵌入式系统是设计完成复杂功能的硬件和软件，并使其紧密耦合在一起的能完成特定功能计算机系统。</li></ol><h4 id=发展历史>发展历史</h4><ol><li>以单芯片为核心的可编程控制器形式的系统</li><li>以嵌入式CPU为基础、以简单操作系统为核心的嵌入式系统</li><li>以嵌入式操作系统为标志的嵌入式系统</li><li>以物联网为标志的嵌入式系统</li></ol><h4 id=嵌入式处理器的分类>嵌入式处理器的分类</h4><ol><li>嵌入式微处理器：基础是通用计算机中的CPU，具有体积小、重量轻、成本低、可靠性高的优点，但是在电路板上必须包括ROM、RAM、总线接口、各种外设等器件，从而降低了系统的可靠性，技术保密性也较差。</li><li>嵌入式微控制器：嵌入式微控制器又称单片机，它是将<strong>整个计算机系统</strong>集成到一块芯片中</li><li>嵌入式DSP处理器：数字信号处理，对系统结构和指令进行了特殊设计，使其适合于执行DSP算法，编译效率较高，指令执行速度也较高</li><li>嵌入式片上系统（SOC）：SoC（System on Chip）称为系统级芯片或片上系统，它指的是一个具有专用目标的集成电路产品，其中包含了完整系统以及嵌入软件的全部内容。</li></ol><h4 id=实时操作系统rtos>实时操作系统RTOS</h4><p>特点：异步的事件响应、切换时间和中断延迟时间确定 、优先级中断和调度、抢占式调度、内存锁定</p><p>在RTOS中， 每个任务均有一个优先级，RTOS根据各个任务的优先级，动态地切换各个任务，保证对实时性的要求。</p><p>相关概念：</p><ol><li>内核：内核负责管理各个任务，或者说为每个任务分配CPU时间，并且负责任务之间的通信。内核提供的基本服务是<strong>任务切换</strong>。</li><li>调度：调度是内核的主要职责之一。调度就是决定该轮到哪个任务运行了。</li><li>非抢占式内核：非占先式内核要求每个任务自我放弃CPU 的所有权。非占先式调度法也称作合作型多任务，各个任务彼此合作共享一个CPU。</li><li>占先式内核：最高优先级的任务一旦就绪，总能得到CPU的控制权。</li><li>中断：中断是一种硬件机制，通知CPU有个异步事件发生了；中断服务子程序做事件处理。</li></ol><h4 id=常见的嵌入式操作系统>常见的嵌入式操作系统</h4><p>嵌入式Linux（uCLinux）、WinCE、VxWorks、μC/OS-II</p><h3 id=二arm体系结构>二、ARM体系结构</h3><h4 id=arm简介>ARM简介</h4><p>Advanced RISC Machines。具有RISC的特点：有大量通用存储器、独特的装载-保存结构、简单的寻址模式、统一的固定长度的指令格式。【P29 ARM体系结构的主要特征】</p><p>ARM处理器的产品系列非常广，包括ARM7、ARM9、ARM9E、ARM10E、ARM11、Cortex。</p><p>ARM7系列广泛应用于多媒体和嵌入式设备，包括Internet设备、网络和调制解调器设备，以及移动电话、PDA等无线设备。</p><p>ARM9系列主要应用于引擎管理、仪器仪表、安全系统和机顶盒等领域。</p><p>ARM10E核心在于使用向量浮点（VFP）单元VFP10提供高性能的浮点解决方案，从而极大提高了处理器的整型和浮点运算性能。可以用于视频游戏机和高性能打印机等场合。</p><h4 id=cortex>Cortex</h4><p>基于ARMv7架构，包含三个子系列：A应用处理器（Application Processor）、R实时控制处理器（Real Time Control）、M微控制器（Micro Controller）</p><p>Cortex-M3：首款基于ARMv7-M架构的处理器，采用了纯Thumb2指令的执行方法，主要应用于汽车车身系统。</p><p>Cortex-R4：首款基于ARMv7架构的高级嵌入式处理器，应用于硬盘、喷墨型打印机等。</p><p>Cortex-A8：基于ARMv7架构的首款应用级处理器。</p><h4 id=arm7>ARM7</h4><p>ARM7TDMI是基于ARM体系结构V4版本的低端ARM核。</p><p>后缀（ARM7TDMI-S）：T（支持高密度16位的Thumb指令集）、D（支持片上调试）、M（支持64位乘法）、I（支持EmbededICE观察硬件）、S（版本软核）</p><h5 id=基本数据类型>基本数据类型</h5><p>ARM采用的是32位架构。</p><p>从偶数地址开始的连续2个字节构成一个<strong>半字</strong>；</p><p>以能被4整除的地址开始的连续4个字节构成一个<strong>字</strong>；</p><p>ARM指令的长度刚好是一个字（32位），Thumb指令的长度刚好是一个半字（16位）。</p><p>如果一个数据是从偶地址开始的连续存储，那么它就是<strong>半字对齐</strong>（低位为0），否则就是非半字对齐；如果一个数据是以能被4整除的地址开始的连续存储，那么它就是<strong>字对齐</strong>（低两位为0），否则就是非字对齐。</p><h5 id=三级流水线>三级流水线</h5><p>ARM7TDMI流水线分为三级：取指、译码、执行。在执行一条指令的同时对下一条(第二条)指令进行译码，并将第三条指令从存储器中取出。（PC指向的指令刚被取指、PC-4指向的指令被译码、PC-8指向的指令正在执行）</p><h4 id=arm处理器状态>ARM处理器状态</h4><p>ARM状态：32位，执行ARM指令，默认为此状态；Thumb状态：16位，执行半字方法的Thumb指令。</p><p>状态的切换不影响处理器模式或者寄存器内容。</p><p>使用<strong>BX</strong>指令进行内核状态切换，例如以下程序实现ARM状态到Thumb状态的切换。Label为跳转地址的标号，目标地址处于16位指令中，地址最低位为1，表示切换到Thumb状态。</p><pre tabindex=0><code>	CODE32
	LDR R0, =Label+1
	BX R0
	CODE16
Label Mov....
</code></pre><p>同理从Thumb状态切换到ARM状态的程序代码如下：</p><pre tabindex=0><code>	CODE16
	LDR R0, =Label
	BX R0
	CODE32
Label Mov...
</code></pre><h4 id=arm处理器模式>ARM处理器模式</h4><p>用户模式（User）、快中断模式（FIQ）、外部中断模式（IRQ）、管理（特权）模式（Supervisor）、中止模式（Abort）、未定义模式（Undef）、系统模式（System）共七个。【Cortex-A9有监控模式（Monitor）】</p><p><img alt=image-1 src=/images/ARM/image-1.png></p><p>除了用户模式外其它都为特权模式，特权模式中除了系统模式外其它都为异常模式。</p><p>处理器遇到没有定义或者不支持的指令时进入未定义模式。</p><p>处理器访问存储器失败时进入数据访问中止模式。</p><p>处理器复位（或软中断指令执行时）之后进入管理模式，操作系统内核通常处于管理模式。</p><p>对于非异常模式，不能由异常进入，想要进入必须修改CPSR，而且他们使用完全相同的寄存器组。</p><h4 id=arm内部寄存器>ARM内部寄存器</h4><p>37个用户可访问的寄存器，31个通用32位寄存器和6个状态寄存器。</p><p>寄存器R0~R7为未分组的通用寄存器，在任何处理器模式都对应于相同的32位物理寄存器。</p><p>寄存器R8~R12有两组，各5个，一个用于除FIQ模式外的所有模式，另一组用于FIQ模式。在发生FIQ后，处理器不必为了保护寄存器而浪费时间，从而加速了FIQ的处理速度。</p><p>寄存器R13、R14分别有六组，一组用于用户模式和系统模式，剩余5个分别用于5个异常模式。</p><p>寄存器R13通常作为堆栈指针（SP），用于保存待使用的寄存器的内容。</p><p><em>寄存器R14（链接寄存器LR）</em>：1.当BL指令调用子程序时，返回的地址将存入R14；2.当发生异常时，将R14对应的异常模式版本设置为异常返回地址。</p><p>寄存器R15：程序计数器PC</p><p>寄存器CPSR为当前程序状态寄存器，在异常模式中，另一个寄存器SPSR（程序状态保存寄存器）可以被访问，每种异常都有自己的SPSR，在进入异常时它保存CPSR的当前值，异常退出时通过它恢复CPSR。</p><h5 id=thumb状态下的寄存器>Thumb状态下的寄存器</h5><p>可以直接访问：8个通用寄存器R0~R7、PC（R15）、SP（R13）、LR（R14）、CPSR。</p><p>每个异常模式，SP通常指向各异常模式的专用堆栈。在发生异常时，处理器自动进入ARM状态。</p><p>Thumb状态CPSR和ARM状态CPSR相同。</p><p>在Thumb状态中，高端寄存器（R8-R12）是受到限制的，只有MOV、CMP、ADD指令可以对其访问，用于数据的快速暂存。</p><h5 id=因异常而导致的状态切换>因异常而导致的状态切换</h5><p><img alt=image-2 src=/images/ARM/image-2.png></p><h4 id=cpsr>CPSR</h4><p>即当前程序状态寄存器（Current Program Status Register，CPSR）。</p><p>包含：</p><p>4个条件代码标志（负标志N，零标志Z，进位标志C，溢出标志V）</p><p>2个中断禁止位（IRQ禁止和FIQ禁止）</p><p>1个用于指示当前执行的是ARM指令还是Thumb指令。</p><p>5个对当前处理器模式进行编码的位（M[4:0]）。</p><p><img alt=image-3 src=/images/ARM/image-3.png></p><p>当控制位I置位时，IRQ被禁止；当控制位F置位时，FIQ禁止。</p><p>当状态位T置位时，处理器正在Thumb状态下运行，不能强制修改CPSR的状态位T，否则处理器会进入无法预测的状态。</p><h5 id=模式编码位m>模式编码位M</h5><p>M[4:0]=10000用户模式；M[4:0]=10001快速中断模式；M[4:0]=10010中断模式；M[4:0]=10011管理模式；M[4:0]=10111中止模式；M[4:0]=11011未定义模式；M[4:0]=11111系统模式</p><p>如果将非法值写入M[4:0]，会使得处理器进入一个无法恢复的模式。</p><h4 id=arm体系的异常>ARM体系的异常</h4><p>只要正常的程序流被暂时中止，处理器就进入异常模式。如果同时发生多个异常，则按照固定的顺序来处理。</p><p>基本原则：无论发生什么异常（除复位），内核总是会首先将 PC-4 放到R14（LR）寄存器中</p><table><thead><tr><th style=text-align:center>异常或入口</th><th style=text-align:center>返回指令</th><th style=text-align:center>返回地址</th></tr></thead><tbody><tr><td style=text-align:center>未定义的指令</td><td style=text-align:center>MOVS PC,R14_und</td><td style=text-align:center>R14</td></tr><tr><td style=text-align:center>SWI软中断指令</td><td style=text-align:center>MOVS PC,R14_svc</td><td style=text-align:center>R14</td></tr><tr><td style=text-align:center>预取中止</td><td style=text-align:center>SUBS PC,R14_abt,#4</td><td style=text-align:center>R14-4</td></tr><tr><td style=text-align:center>快速中断</td><td style=text-align:center>SUBS PC,R14_fiq,#4</td><td style=text-align:center>R14-4</td></tr><tr><td style=text-align:center>中断</td><td style=text-align:center>SUBS PC,R14_irq,#4</td><td style=text-align:center>R14-4</td></tr><tr><td style=text-align:center>数据中止</td><td style=text-align:center>SUBS PC,R14_abt,#8</td><td style=text-align:center>R14-8</td></tr></tbody></table><p>以未定义的指令为例，当前执行PC，取指的为PC-8，存下PC-4到R14中，PC为未定义跳过，下一条则应该为R14中的指令，直接MOVS即可。</p><h5 id=异常向量表>异常向量表</h5><table><thead><tr><th style=text-align:center>地址</th><th style=text-align:center>异常</th><th style=text-align:center>进入时的模式</th><th style=text-align:center>进入时的I</th><th style=text-align:center>进入时的F</th></tr></thead><tbody><tr><td style=text-align:center>0x00000000</td><td style=text-align:center>复位</td><td style=text-align:center>管理</td><td style=text-align:center>禁止</td><td style=text-align:center>禁止</td></tr><tr><td style=text-align:center>0x00000004</td><td style=text-align:center>未定义指令</td><td style=text-align:center>未定义</td><td style=text-align:center>I</td><td style=text-align:center>F</td></tr><tr><td style=text-align:center>0x00000008</td><td style=text-align:center>软件中断异常</td><td style=text-align:center>管理</td><td style=text-align:center>禁止</td><td style=text-align:center>F</td></tr><tr><td style=text-align:center>0x0000000C</td><td style=text-align:center>中止（预取）</td><td style=text-align:center>中止</td><td style=text-align:center>I</td><td style=text-align:center>F</td></tr><tr><td style=text-align:center>0x00000010</td><td style=text-align:center>中止（数据）</td><td style=text-align:center>中止</td><td style=text-align:center>I</td><td style=text-align:center>F</td></tr><tr><td style=text-align:center>0x00000014</td><td style=text-align:center>保留</td><td style=text-align:center>保留</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:center>0x00000018</td><td style=text-align:center>IRQ</td><td style=text-align:center>中断</td><td style=text-align:center>禁止</td><td style=text-align:center>F</td></tr><tr><td style=text-align:center>0x0000001C</td><td style=text-align:center>FIQ</td><td style=text-align:center>快速中断</td><td style=text-align:center>禁止</td><td style=text-align:center>禁止</td></tr></tbody></table><h5 id=异常优先级>异常优先级</h5><p>复位>数据中止>FIQ>IRQ>预取指中止>未定义指令中止=软件中断异常</p><h5 id=异常的进入>异常的进入</h5><ol><li>将异常处理程序的返回地址保存到相应异常模式下的LR；</li><li>将CPSR的当前值保存到相应异常模式下的SPSR；</li><li>设置CPSR为相应的异常模式；</li><li>设置PC为相应异常处理程序的中断入口向量地址，跳转到相应的异常中断处理程序执行；</li></ol><h5 id=异常的退出>异常的退出</h5><ol><li>返回到发生异常中 指令的下一条指令处执行，即就是说将LR中的值减去偏移量后移入PC；</li><li>将SPSR的值复制回CPSR；</li><li>清零在入口处置位的中断禁止标志。</li></ol><h5 id=复位的操作>复位的操作</h5><p>复位也是一种异常，当nRESET信号被拉低时，ARM放弃正在执行的指令，等到nRESET信号再次变高时，处理器执行以下操作：</p><ol><li>强制M[4:0]变为b10011，系统进入管理模式；</li><li>将CPSR中的标志位I和F置位，IRQ和FIQ中断被禁止；</li><li>将CPSR中的标志位T清零，处理器处于ARM状态；</li><li>强制PC从地址0x00开始对下一条指令进行取指；</li><li>返回到ARM状态并恢复执行；</li></ol><h5 id=中断请求异常>中断请求异常</h5><p>在CPSR的相应中断屏蔽位被清除时才能发生IRQ异常，由nIRQ输入端的低电平所产生的正常中断。</p><p>中断异常模式下的R14保存的是PC的值。</p><p>正在执行的（PC-8）不会被中断，当前取指的（PC）被保存在R14中作为异常返回地址。</p><p>进入IRQ异常模式：</p><ol><li>R15→R14_irq</li><li>CPSR→SPSR_irq</li><li>修改CPSR，I=1禁止新的IRQ产生，T=0进入ARM状态，M的mod修改为IRQ模式</li><li>R15←0x0018异常向量地址</li><li>将IRQ中断异常模式的栈顶指针保存到R13_irq中，之后软件处理程序调用中断服务程序为中断源服务。</li></ol><p>退出IRQ异常模式：</p><ol><li>从R13_irq中获取IRQ中断异常模式的栈顶指针；</li><li>SPSR_irq→CPSR</li><li>R14_irq-4→R15</li></ol><h5 id=快速中断请求异常>快速中断请求异常</h5><p>由于ARM状态中有八个专用状态，可以快速响应突发事件（上下文切换速度加快）</p><p>中断返回：R14_fiq-4→R15</p><p>在特权模式中，可以通过将CPSR的F位置1来禁止FIQ异常。</p><h5 id=未定义的指令异常>未定义的指令异常</h5><p>存下PC-4到R14中，进入中断处理程序，同时软件可使用这一机制通过仿真未定义的协处理器指令来扩展ARM指令集。</p><p>仿真失败的指令后，R14_und→R15，跳转到下一条指令进行执行。</p><h5 id=中止异常>中止异常</h5><p>分为预取指中止（由程序存储器引起的中止异常）和数据中止（由数据存储器引起的中止异常）。</p><p>当发生<em>预取指中止</em>时，ARM内核将预取的指令标记为无效，但在指令到达流水线的执行阶段时才进入异常。如果指令在流水线中因为发生分支而没有被执行，中止将不会发生。</p><p>当发生<em>数据中止异常</em>时，异常会在“导致异常的指令”执行后的下一条指令发生。在这种情况下，理想的状况是进入数据中止异常的ISR，然后在内存中挑选出问题，再重新执行导致异常的指令。</p><h5 id=软件中断异常swi>软件中断异常SWI</h5><p>软件中断异常(SWI)用于进入管理模式，通常用于请求一个特定的管理函数。</p><p>MOVS PC,R14_svc，恢复了PC和CPSR并返回到SWI之后的指令。</p><h5 id=中断延迟>中断延迟</h5><p>中断延迟即从外部中断请求信号发出到执行对应的中断服务程序ISR的第1条指令所需要的时间。</p><p>通过软件程序设计来缩短中断延迟的方法有：中断优先级和中断嵌套。</p><h4 id=arm体系结构的存储系统>ARM体系结构的存储系统</h4><p>采用冯诺依曼结构，指令、数据和I/O统一编址，只有装载、保存和交换指令可以访问存储器中的数据。</p><p>一般在处理器核和外部存储器之间有一个存储器管理部件将ARM7的局部总线信号和时序转换为外部芯片厂商的外部总线的信号和时序。</p><h5 id=地址空间>地址空间</h5><p>ARM结构使用单个平面的$2^{32}$个8位字节地址空间。地址空间可以看作是包含$2^{30}$个32位字，或$2^{31}$个16位半字。</p><p>如果在取指操作时地址发生溢出，只要没有执行预取的无效指令，就不会导致异常。</p><h5 id=存储器格式>存储器格式</h5><p>位于地址A的字包含的字节位于地址A，A+1，A+2和A+3，半字位于A和A+1。</p><p>小端：高位存高地址，例如0x12345678的12为高位，存到A+4高地址中。</p><h5 id=非对齐的存储器访问>非对齐的存储器访问</h5><p>非对齐的指令取指：将一个非字（半字）对齐的地址写入ARM（Thumb）状态的R15寄存器</p><p>非对齐的数据访问：在一个非字（半字）对齐的地址读写一个字（半字）</p><h4 id=cortex-a9>Cortex-A9</h4><h5 id=工作模式>工作模式</h5><p>Cortex-A特有模式：Monitor监控模式，是为了安全而扩展出的用于执行安全监控代码的模式；一种特权模式</p><h5 id=存储器的层次结构>存储器的层次结构</h5><p><img alt=image-31 src=/images/ARM/image-3-1.png></p><h5 id=协处理器cp15>协处理器CP15</h5><p>在ARM系统中，要实现对存储系统的管理通常使用协处理器CP15，它通常也被称为系统控制协处理器。ARM处理器支持16个协处理器。CP15包含16个32位寄存器。</p><h5 id=存储管理单元mmu>存储管理单元MMU</h5><p>MMU提供的一个关键服务是使各个任务作为各自独立的程序在自己的私有存储空间中运行。</p><h5 id=高速缓冲存储器cache>高速缓冲存储器Cache</h5><p>对于程序员来说，Cache是透明的，它自动决定保存哪些数据、覆盖哪些数据。</p><p>Cache经常与写缓存器（Writer Buffer）一起使用。</p><h5 id=寄存器>寄存器</h5><p>Cortex-A多出三个寄存器，Monitor模式下的r13、r14、SPSR。</p><h3 id=三arm指令系统>三、ARM指令系统</h3><h4 id=简介>简介</h4><p>ARM是RISC。</p><p>ARM7TDMI(-S)具有32位ARM指令集和16位Thumb指令集。</p><h4 id=arm处理器的寻址方式>ARM处理器的寻址方式</h4><ol><li><p>寄存器寻址； 2. 立即寻址； 3. 寄存器移位寻址； 4. 寄存器间接寻址；</p></li><li><p>基址寻址； 6. 多寄存器寻址； 7. 堆栈寻址； 8. 相对寻址；</p></li></ol><h5 id=寄存器寻址>寄存器寻址</h5><p>地址码字段指出的是寄存器编号，如MOV R1, R2将R2的值存入R1</p><h5 id=立即寻址>立即寻址</h5><p>指令给出了立即可以使用的操作数，如SUBS R0,R0,#1</p><h5 id=寄存器移位寻址>寄存器移位寻址</h5><p>是ARM指令集特有的寻址方式。如MOV R0, R2, LSL #3，将R2的值左移3位后放入R0</p><h5 id=寄存器间接寻址>寄存器间接寻址</h5><p>如LDR R1,[R2]，将R2指向的存储单元的数据读出保存到R1</p><h5 id=基址寻址>基址寻址</h5><p>将基址寄存器中的内容与偏移量相加，形成操作数的有效地址。如LDR R2, [R3, #0x0C]，读取R3+0x0C所对应地址的存储单元中的内容，并放入R2。</p><p>STR R1, [R0 #-4]! 先R0=R0-4，然后把R1保存到R0指定的存储单元中。</p><h5 id=多寄存器寻址>多寄存器寻址</h5><p>一次可传送多个寄存器值，允许一条指令传送16个寄存器的任何子集或者寄存器。</p><p>LDMIA R1!, {R2-R7,R12}，将R1指向的单元中的数据读出到R2-R7、R12中，同时R1自动加1。</p><p>STMIA R0!, {R2-R7,R12}，将R2-R7、R12的值保存到R0指向的存储单元中，R0自动加1。</p><h5 id=堆栈寻址>堆栈寻址</h5><p>使用一个专门的寄存器（堆栈指针）指向一块存储区域，指针指向的存储单元是堆栈的栈顶。</p><p>递增堆栈：向高地址方向生长（向上增长）；递减堆栈：向低地址方向生长（向下增长）；</p><p>满堆栈：堆栈指针指向最后压入的堆栈的有效数据项；空堆栈：堆栈指针指向下一个待压入数据的空位置。</p><p>可以组合成以下四种堆栈方式。</p><ol><li>满递增：指令如LDMFA，STMFA。</li><li>空递增：指令如LDMEA，STMEA。</li><li>满递减：指令如LDMFD，STMFD。</li><li>空递增：指令如LDMED，STMED。</li></ol><h5 id=相对寻址>相对寻址</h5><p>是基址寻址的一种变通。由程序计数器PC提供基准地址，指令中的地址码字段为偏移量，相加后得到的地址即为操作数的有效地址。</p><h4 id=指令集介绍>指令集介绍</h4><h5 id=一个简单的arm程序>一个简单的ARM程序</h5><pre tabindex=0><code class=language-assembly data-lang=assembly>;文件名：TEST1.S
;功能：实现两个寄存器相加
;说明 使用ARMulate软件仿真调试
	AREA Example1,CODE,READONLY	;声明代码段Example1
	ENTRY	;标识程序入口
	CODE32	;声明32位ARM指令
START MOV R0,#0		;设置参数
	MOV R1,#10		
LOOP BL ADD_SUB		;调用子程序ADD_SUB
	B LOOP			;跳转到LOOP
ADD_SUB
	ADDS R0,R0,R1	;R0=R0+R1
	MOV PC,LR		;子程序返回
	END				;文件结束
</code></pre><h5 id=arm指令集>ARM指令集</h5><h6 id=基本格式>基本格式</h6><pre tabindex=0><code class=language-assembly data-lang=assembly>&lt;opcode&gt; {&lt;cond&gt;} {S}  &lt;Rd&gt;, &lt;Rn&gt;{,&lt;operand2&gt;}
</code></pre><p>operand2可以有如下形式：</p><p>#immed_8r：常数表达式； Rm：寄存器方法； Rm,shift：寄存器移位方式</p><h6 id=常数表达式immed_8r>常数表达式immed_8r</h6><p>该常数必须是一个<strong>8位</strong>的常数通过循环右移偶数位可以得到的数。</p><p>例如：MOV R1,#0xC000; 0xC000可以由0x03循环右移16位得到</p><h6 id=寄存器移位方法rmshift>寄存器移位方法Rm,shift</h6><p>Rm的值保持不变，移位结果作为操作数</p><table><thead><tr><th style=text-align:center>操作码</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td style=text-align:center>ASR #n</td><td style=text-align:center>算数右移n位</td></tr><tr><td style=text-align:center>LSL #n</td><td style=text-align:center>逻辑左移n位</td></tr><tr><td style=text-align:center>LSR #n</td><td style=text-align:center>逻辑右移n位</td></tr><tr><td style=text-align:center>ROR #n</td><td style=text-align:center>循环右移n位</td></tr><tr><td style=text-align:center>RRX</td><td style=text-align:center>带拓展的循环右移1位</td></tr><tr><td style=text-align:center>Type Rs</td><td style=text-align:center>Rs为偏移量寄存器，低8位有效</td></tr></tbody></table><p>如：ADD R1,R1,R1,LSL #3； 即R1=R1+R1*8=9R1</p><h6 id=条件码>条件码</h6><p>例如以下C代码if(a>b) a++; else b++;对应的汇编代码为</p><pre tabindex=0><code class=language-assembly data-lang=assembly>CMP R0,R1
ADDHI R0,R0,#1	;若R0&gt;R1则R0=R0+1
ADDLS R1,R1,#1	;若R0&lt;=R1
</code></pre><p><img alt=image-4 src=/images/ARM/image-4.png></p><h5 id=存储器访问指令>存储器访问指令</h5><p>分为单寄存器操作指令和多寄存器操作指令。</p><h6 id=单寄存器存取>单寄存器存取</h6><p>装载指令：LDR 目标寄存器,源地址（目标寄存器←源地址）</p><p>存储指令：STR 源寄存器,目标地址（源寄存器→目标地址）</p><p>搭配不同的后缀实现不同方式的单寄存器存取操作。</p><p>装载、存储指令的后缀搭配如下。</p><table><thead><tr><th style=text-align:center>助记符</th><th style=text-align:center>说明</th><th style=text-align:center>操作</th><th style=text-align:center>条件码位置</th></tr></thead><tbody><tr><td style=text-align:center>LDR Rd, add</td><td style=text-align:center>加载字数据</td><td style=text-align:center>Rd←[add]</td><td style=text-align:center>LDR{cond}</td></tr><tr><td style=text-align:center>LDRB Rd, add</td><td style=text-align:center>加载无符号字节数据</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>LDRT Rd, add</td><td style=text-align:center>以用户模式加载字数据</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>LDRBT Rd, add</td><td style=text-align:center>以用户模式加载无符号字节数据</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>LDRH Rd, add</td><td style=text-align:center>加载无符号半字数据</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>LDRSB Rd, add</td><td style=text-align:center>加载有符号字节数据</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>LDRSH Rd, add</td><td style=text-align:center>加载有符号半字数据</td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><table><thead><tr><th style=text-align:center>助记符</th><th style=text-align:center>说明</th><th style=text-align:center>操作</th><th style=text-align:center>条件码位置</th></tr></thead><tbody><tr><td style=text-align:center>STR Rd, add</td><td style=text-align:center>存储字数据</td><td style=text-align:center>[add]←Rd</td><td style=text-align:center>STR{cond}</td></tr><tr><td style=text-align:center>STRB Rd, add</td><td style=text-align:center>存储字节数据</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>STRT Rd, add</td><td style=text-align:center>用户模式存储字数据</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>STRBT Rd, add</td><td style=text-align:center>以用户模式存储字节数据</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>STRH Rd, add</td><td style=text-align:center>存储半字数据</td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>B：字节数据 T：用户模式 H：半字数据 S：有符号数据 默认：字数据</p><h6 id=地址形式>地址形式</h6><p>立即数：这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值。LDR R1,[R0,<strong>#0x12</strong>]</p><p>寄存器：LDR R1,[R0,<strong>R2</strong>]</p><p>寄存器及移位常数：LDR R1,[R0,<strong>R2,LSL #2</strong>]</p><h6 id=寻址方式>寻址方式</h6><p>零偏移：LDR Rd,[Rn] 【寄存器寻址】</p><p>前索引偏移：LDR Rd,[Rn,#0x04]! 【在索引前偏移，先Rn:=Rn+#0x04，后寻址】</p><p>程序相对偏移：LDR Rd,labe1</p><p>后索引偏移：LDR Rd,[Rn],#0x04 【在索引之后偏移，先按照Rn寻址，之后再Rn:=Rn+#0x04】</p><h6 id=单存储器的转载与保存>单存储器的转载与保存</h6><p>例如：LDR R2,[R5] 即将R5指向地址的字数据存入R2</p><p>STR R1, [R2,#0x04] 将R1的数据存储到R2+0x04的地址中，但是最后R2保持不变</p><h6 id=多寄存器存取>多寄存器存取</h6><p>LDM为加载多个寄存器；STM为存储多个寄存器。允许一条指令传送16个寄存器的任何子集或所有寄存器。</p><p>装载指令：LDM 源地址, 目标寄存器列表（源地址→目标寄存器列表）</p><p>存储指令：STM 目标地址, 源寄存器列表（目标地址←源寄存器列表）</p><p>后缀：IA每次传输后地址加4；IB：每次传输前地址加4； BA：每次传输后地址减4；DB：每次传输前地址减4</p><p>举例子：STMDA R1!,{R5-R7}，R1跟着修改，由于是D，地址减，先放的是R7。【高地址放后面的寄存器】</p><h6 id=多寄存器存取-堆栈>多寄存器存取-堆栈</h6><p>满递减FD、满递增FA、空递减ED、空递增EA</p><p>Full栈：堆栈指针指向栈顶元素。</p><p>Empty栈：堆栈指针指向下一个可用元素。</p><p>特别的：LDMFD SP!,{R0-R7,PC}^ 带状态恢复的出栈操作，把SPSR移动到CPSR 为满递减，栈往低地址增长，栈顶指针指向栈顶元素，从栈顶开始的元素依次存到R0-R7、PC。</p><h6 id=寄存器和存储器交换指令>寄存器和存储器交换指令</h6><p>SWP Rd,Rm,Rn Rd←[Rn], [Rn]←Rm 添加后缀B表示交换字节数据</p><p>例如 SWP R2,R1[R0]，将R0寄存器指向的内存单元值给R2，然后R1赋值到该内存单元中。</p><h5 id=arm数据处理指令>ARM数据处理指令</h5><p>数据传送指令、算术逻辑运算指令、比较指令</p><p>数据处理指令只能对寄存器的内容进行操作，而不能对内存中的数据进行操作。所有ARM数据处理指令均可选择使用S后缀，并影响状态标志。</p><h6 id=数据传送指令>数据传送指令</h6><p>MOV Rd, 操作数</p><p>MVN 将操作数取反后送至目标寄存器</p><p>例如MOV R3, R1, LSL #3 为R3 = 8 * R1</p><p>MOV 和LDR的区别：MOV不能访问内存、LDR可以将内存数据读入到寄存器</p><h6 id=算术逻辑运算指令>算术逻辑运算指令</h6><p>个数为 Opcode 结果寄存器, 运算寄存器, 第二操作数。</p><p>下表均直接影响CPSR</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>操作</th><th style=text-align:center>备注</th></tr></thead><tbody><tr><td style=text-align:center>ADD</td><td style=text-align:center>加法操作</td><td style=text-align:center></td></tr><tr><td style=text-align:center>ADC</td><td style=text-align:center>带进位的加法操作</td><td style=text-align:center>加上CPSR的C</td></tr><tr><td style=text-align:center>SUB</td><td style=text-align:center>减法操作</td><td style=text-align:center></td></tr><tr><td style=text-align:center>RSB</td><td style=text-align:center>逆向减法运算</td><td style=text-align:center>后面减前面</td></tr><tr><td style=text-align:center>SBC</td><td style=text-align:center>带进位的减法运算</td><td style=text-align:center>再减去C的反码</td></tr><tr><td style=text-align:center>RSC</td><td style=text-align:center>带进位的逆向减法运算</td><td style=text-align:center></td></tr><tr><td style=text-align:center>AND</td><td style=text-align:center>逻辑与</td><td style=text-align:center></td></tr><tr><td style=text-align:center>ORR</td><td style=text-align:center>逻辑或</td><td style=text-align:center></td></tr><tr><td style=text-align:center>EOR</td><td style=text-align:center>逻辑异或</td><td style=text-align:center></td></tr><tr><td style=text-align:center>BIC</td><td style=text-align:center>位清除</td><td style=text-align:center>后者反码与Rn进行与操作</td></tr></tbody></table><h6 id=比较指令>比较指令</h6><p>比较指令将两个数值进行的特定运算，根据运算结果<em>影响CPSR的相关标志位</em>，用于后面程序的条件执行，但是运算结果不予保存。</p><table><thead><tr><th style=text-align:center>指令</th><th style=text-align:center>操作</th><th style=text-align:center>备注</th></tr></thead><tbody><tr><td style=text-align:center>CMP</td><td style=text-align:center>数值比较</td><td style=text-align:center>CMP R1,R2 R1-R2并影响标志位</td></tr><tr><td style=text-align:center>CMN</td><td style=text-align:center>负数比较</td><td style=text-align:center></td></tr><tr><td style=text-align:center>TEQ</td><td style=text-align:center>相等测试</td><td style=text-align:center>TST R3,R2，R3与#0x02异或，只能判等，不影响C、V位</td></tr><tr><td style=text-align:center>TST</td><td style=text-align:center>位测试</td><td style=text-align:center>TST R3,#0x02，R3与#0x02相与并影响标志位</td></tr></tbody></table><p>CMP Rn,#0 的标志位C为1， CMN Rn, #0的标志位C为0</p><h6 id=乘法指令>乘法指令</h6><table><thead><tr><th style=text-align:center>助记符</th><th style=text-align:center>说明</th><th style=text-align:center>操作</th></tr></thead><tbody><tr><td style=text-align:center>MUL Rd,Rm,Rs</td><td style=text-align:center>32位乘法指令</td><td style=text-align:center>Rd:=Rm*Rs(Rm!=Rd)</td></tr><tr><td style=text-align:center>MLA Rd,Rm,Rs,Rn</td><td style=text-align:center>32位乘加指令</td><td style=text-align:center>Rd:=Rm*Rs+Rn</td></tr><tr><td style=text-align:center>UMULL RdLo,RdHi,Rm,Rs</td><td style=text-align:center>64位无符号乘法</td><td style=text-align:center>(RdLo,RdHi):=Rm*Rs</td></tr><tr><td style=text-align:center>UMLAL RdLo,RdHi,Rm,Rs</td><td style=text-align:center>64位无符号乘加</td><td style=text-align:center>(RdLo,RdHi):=Rm*Rs+(RdLo,RdHi)</td></tr><tr><td style=text-align:center>SMULL RdLo,RdHi,Rm,RS</td><td style=text-align:center>64位有符号乘法</td><td style=text-align:center>(RdLo,RdHi):=Rm*Rs</td></tr><tr><td style=text-align:center>SMLAL RdLo,RdHi,Rm,Rs</td><td style=text-align:center>64位有符号乘加</td><td style=text-align:center>(RdLo,RdHi):=Rm*Rs+(RdLo,RdHi)</td></tr></tbody></table><h6 id=分支指令>分支指令</h6><p>有两种跳转方法，一种是修改PC，另一种是使用分支指令</p><p>B：分支指令 BX：带状态切换的分支指令 BL：带链接的分支指令</p><p>B/BL指令只有24来表示目标地址</p><p>BL指令除了具有跳转功能，还能在跳转之前将<strong>下一条指令</strong>的地址拷贝到R14(即LR) 链接寄存器中，它适用于子程序调用。【记录返回地址】当子程序执行结束后，将LR寄存器内容存入PC，返回调用函数继续执行</p><p>BX指令跳转检查地址最低位是否为1，若位1则切换到Thumb模式。</p><p>例如：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>ADRL	R0,T_Fun + 1	;	将Thumb程序的入口地址加1存入R0
BX R0		;
</code></pre><h6 id=协处理器指令>协处理器指令</h6><p><img alt=image-5 src=/images/ARM/image-5.png></p><table><thead><tr><th style=text-align:center>助记符</th><th style=text-align:center>说明</th><th></th></tr></thead><tbody><tr><td style=text-align:center>CDP coproc, opcode1, CRd,CRn,CRm,{,opcode2}</td><td style=text-align:center>协处理器数据操作指令</td><td></td></tr><tr><td style=text-align:center>LDC{L} coproc, CRd,&lt;地址></td><td style=text-align:center>协处理器数据读取指令</td><td></td></tr><tr><td style=text-align:center>STC{L} coproc, CRd,&lt;地址></td><td style=text-align:center>协处理器数据写入指令</td><td></td></tr><tr><td style=text-align:center>MCR coproc,opcode1,Rd,CRn,CRm{,opcode2}</td><td style=text-align:center>ARM寄存器到协处理器寄存器的数据传送指令</td><td></td></tr><tr><td style=text-align:center>MRC coproc,opcode1,Rd,CRn,CRm{,opcode2}</td><td style=text-align:center>协处理器寄存器到ARM寄存器到的数据传送指令</td><td></td></tr></tbody></table><p>举例：</p><p>MCR p14, 1, r7, c7, c12, 6</p><p>将r7中的值传送到协处理器p14的寄存器c7中，第一操作数opcode_1=1，第二操作数opcode_2=6</p><p>MRC p15. 5, r4, c0, c2, 3</p><p>协处理器源寄存器为c0和c2，目的寄存器的ARM寄存器为r4， 第一操作数opcode_1=5，第二操作数opcode_2=3</p><h6 id=软中断指令swi>软中断指令SWI</h6><p>SWI指令用于产生软中断，主要用于用户程序调用操作系统的系统服务。执行该指令后，处理器将完成以下动作：</p><ol><li><p>切换到管理模式</p></li><li><p>将CPSR备份到管理模式下的SPSR寄存器</p></li><li><p>程序跳转到软件中断入口</p></li></ol><p>通常将任务放在用户模式执行，以限制其权限；如中断开关等重要操作，使用软件中断指令即可完成系统功能调用</p><p>SWI指令格式：<strong>SWI immed_24</strong> 向中断服务程序传递参数，比如请求的服务类型</p><p>两种参数传递方式：</p><ol><li>请求服务类型由参数给出：</li></ol><pre tabindex=0><code class=language-assembly data-lang=assembly>MOV R0,#34		;设置子功能号为34 
SWI    12		;调用12号软中断 
</code></pre><ol start=2><li>不传参，服务类型由R0给出</li></ol><pre tabindex=0><code class=language-assembly data-lang=assembly>MOV    R0,#12		;调用12号软中断 
MOV    R1,#34		;设置子功能号为34 
SWI    0 
</code></pre><p>在SWI异常中断处理程序中，取出SWI指令中立即数的步骤如下：</p><ol><li>确定引起软中断的SWI指令是ARM指令还是Thumb指令，这可通过对SPSR访问得到；</li><li>然后取得该SWI指令的地址，这可通过访问LR寄存器得到；（LR的上一条指令）</li><li>读出SWI指令，分解出立即数</li></ol><p><img alt=image-61 src=/images/ARM/image-6-1.png></p><h6 id=状态寄存器读写指令>状态寄存器读写指令</h6><p>在ARM处理器中，只有<strong>MRS指令</strong>可以对状态寄存器CPSR和SPSR进行<strong>读</strong>操作。通过读CPSR可以了解当前处理器的工作状态。读SPSR寄存器可以了解到进入异常前的处理器状态。</p><p>例如MRS R0, SPSR</p><p>在ARM处理器中，只有<strong>MSR指令</strong>可以对状态寄存器CPSR和SPSR进行<strong>写</strong>操作。</p><p>寄存器被分为四个8位的域：状态位s、扩展位x、条件标志位f、控制位c</p><p>操作数可以是立即数或者寄存器。</p><p>写入控制位：MSR CPSR_c,R0</p><p>Problem：使用MSR和MRS指令，通过修改CPSR寄存器，实现打开/关闭IRQ中断的两个子程序，注意不能影响其它位？</p><pre tabindex=0><code class=language-assembly data-lang=assembly>;使能IRQ中断 
MRS	R0,CPSR
BIC R0,R0,#0x80
MSR	CPSR_c,R0
MOV PC,LR
;禁止IRQ中断
MRS R0,CPSR
ORR	R0,R0,#0x80
MSR CPSR_c,R0
MOV PC,LR
</code></pre><h5 id=伪指令>伪指令</h5><p>ARM伪指令不属于ARM指令集中的指令，是为了编程方便而定义的。伪指令可以像其它ARM指令一样使用，但在编译时这些指令将被等效的ARM指令代替。</p><ol><li>小范围地址读取指令：ADR</li><li>中等范围地址读取指令：ADRL</li><li>大范围地址读取指令：LDR</li><li>空操作：NOP</li></ol><h6 id=adr>ADR</h6><p>ADR 目标寄存器，表达式</p><p>地址表达式expr的取指范围：</p><ol><li><p>当地址不是字对齐时，其取值范围为±255</p></li><li><p>当地址值是字对齐时，其取指范围为±1020</p></li><li><p>当地址值是16字节对齐时，其取指范围将更大。</p></li></ol><p>举例：ADR R0,Delay ；将程序标号Delay的地址存入R0</p><pre tabindex=0><code class=language-assembly data-lang=assembly>; 查表应用
      ADR    R0,DISP_TAB	; 加载转换表地址
      LDRB   R1,[R0,R2]		; 使用R2作为参数，进行查表
      …
DISP_TAB
      DCB   0xC0,0xF9,0xA4,0xB0,0x99, 0x92,0x82,0xF8
</code></pre><h6 id=adrl>ADRL</h6><p>地址表达式expr的取指范围：</p><ol><li><p>当地址不是字对齐时，其取值范围为±16k</p></li><li><p>当地址值是字对齐时，其取指范围为±256k</p></li><li><p>当地址值是16字节对齐时，其取指范围将更大。</p></li></ol><h6 id=ldr>LDR</h6><p>LDR伪指令用于加载32位的立即数或一个地址值到指定寄存器。</p><p>LDR 目标寄存器,**＝**表达式</p><p>地址表达式expr的取指范围为任意值</p><p>LDR伪指令被汇编成一条LDR指令，并在文字池中定义了一个常量，该常量为Delay标号的地址，文字池和LDR指令之间的地址差异必须小于4KB。</p><h6 id=nop>NOP</h6><p>NOP伪指令在汇编时将会被代替成ARM中的空操作，比如可能是“MOV R0,R0”指令等。NOP可用于延时操作。</p><p>延时子程序：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>Delay
       NOP		 ;空操作
       NOP
       NOP
       SUBS    R0,R0,#1 	 ;循环次数减一
       BNE      Delay	 ;如果循环未结束,跳转Delay继续
       MOV     PC,LR	 ;子程序返回
</code></pre><h5 id=thumb指令集>Thumb指令集</h5><p>一个简单的Thumb程序</p><p>需要用CODE16在Thumb程序段之前进行声明</p><p><img alt=image-6 src=/images/ARM/image-6.png></p><p>Thumb指令集较ARM指令集有如下限制：</p><ol><li><p>只有B指令可以条件执行，其它指令都不能条件执行；</p></li><li><p>分支指令的跳转范围有更多限制；</p></li><li><p>数据处理指令的操作结果必须放入其中一个；</p></li><li><p>单寄存器访问指令，只能操作R0～R7；</p></li><li><p>LDM和STM指令可以对R0～R7的任何子集进行操作；</p></li></ol><p>C语言编程中声明变量的几个重要关键词:</p><p>__packed：用于将一个结构体在存储器中紧凑存储，会降低结构体成员的访问速度</p><p>volatile：用于告诉编译器不要将对该变量的操作优化掉</p><p>__align(n)：用于控制变量的n字节对齐存储</p><p>DCD：分配一片连续的字存储单元</p><h3 id=四arm汇编语言程序设计>四、ARM汇编语言程序设计</h3><h4 id=数据定义伪操作>数据定义伪操作</h4><table><thead><tr><th style=text-align:center>伪指令名</th><th style=text-align:center>含义</th><th style=text-align:center>举例</th></tr></thead><tbody><tr><td style=text-align:center>.byte</td><td style=text-align:center>单字节定义</td><td style=text-align:center>.byte 0x12,’a’,23</td></tr><tr><td style=text-align:center>.short</td><td style=text-align:center>定义双字节数据</td><td style=text-align:center>.short 0x1234,65535</td></tr><tr><td style=text-align:center>.long /.word</td><td style=text-align:center>定义4字节数据</td><td style=text-align:center>.word 0x12345678</td></tr><tr><td style=text-align:center>.quad</td><td style=text-align:center>定义8字节数据</td><td style=text-align:center>.quad 0x1234567812345678</td></tr><tr><td style=text-align:center>.float</td><td style=text-align:center>定义浮点数</td><td style=text-align:center>.float 0f3.2</td></tr><tr><td style=text-align:center>.string/.asciz/.ascii</td><td style=text-align:center>定义字符串</td><td style=text-align:center>.ascii “abcd\0”(.ascii要加\0)</td></tr></tbody></table><h4 id=控制伪操作>控制伪操作</h4><p>.if、.else、.endif</p><p>当.if后面的逻辑表达式为真，则执行.if后的指令序列，否则执行.else后的指令序列； .if、.else、.endif伪指令可以嵌套使用。</p><p>如：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>.if  logical-expressing
…
.else
…
.endif
</code></pre><p>.macro，.endm</p><p>宏指令，然后就可以在程序中通过宏指令多次调用该段代码。</p><p>.macro macroname {$parameter{,$parameter}…}</p><p>……..code</p><p>.endm</p><h4 id=杂项伪指令>杂项伪指令</h4><table><thead><tr><th style=text-align:center>伪指令名</th><th style=text-align:center>含义</th><th style=text-align:center>举例</th></tr></thead><tbody><tr><td style=text-align:center>.arm</td><td style=text-align:center>.arm</td><td style=text-align:center>定义一下代码使用ARM指令集编译</td></tr><tr><td style=text-align:center>.thumb</td><td style=text-align:center>.thumb</td><td style=text-align:center>定义一下代码使用Thumb指令集编译</td></tr><tr><td style=text-align:center>.section</td><td style=text-align:center>.section</td><td style=text-align:center>expr 定义一个段。expr可以使.text .data. .bss</td></tr><tr><td style=text-align:center>.text</td><td style=text-align:center>.text {subsection}</td><td style=text-align:center>将定义符开始的代码编译到代码段</td></tr><tr><td style=text-align:center>.data</td><td style=text-align:center>.data {subsection}</td><td style=text-align:center>将定义符开始的代码编译到数据段,初始化数据段</td></tr><tr><td style=text-align:center>.bss</td><td style=text-align:center>.bss {subsection}</td><td style=text-align:center>将变量存放到.bss段,未初始化数据段</td></tr><tr><td style=text-align:center>.align</td><td style=text-align:center>.align{alignment}{,fill}{,max}</td><td style=text-align:center>通过用零或指定的数据进行填充来使当前位置与指定边界对齐</td></tr><tr><td style=text-align:center>.org</td><td style=text-align:center>.org offset{,expr}</td><td style=text-align:center>指定从当前地址加上offset开始存放代码，并且从当前地址到当前地址加上,offset之间的内存单元，用零或指定的数据进行填充</td></tr><tr><td style=text-align:center>_start</td><td style=text-align:center></td><td style=text-align:center>汇编程序的缺省入口是_ start标号,用户也可以在连接脚本文件中用ENTRY标志指明其它入口点.</td></tr><tr><td style=text-align:center>.globl</td><td style=text-align:center>.globl</td><td style=text-align:center>用来声明一个全局的符号</td></tr><tr><td style=text-align:center>.end</td><td style=text-align:center></td><td style=text-align:center>文件结束</td></tr></tbody></table><p>.include 格式：.include “filename”</p><p>包含指定的头文件, 可以把一个汇编常量定义放在头文件中</p><p>.equ 格式：<strong>.equ symbol, expression</strong></p><p>把某一个符号(symbol)定义成某一个值(expression).</p><p>该指令并不分配空间.(c语言的 #define)</p><h4 id=aapcs过程调用标准>AAPCS过程调用标准</h4><p>为了使不同编译器的程序之间能够互相调用，必须为子程序之间的调用规定一定的规则，AAPCS就是这样的标准。</p><p>R0-R3用于子程序之间的传参。更多的用堆栈传参。</p><p>R4-R11用于保存局部变量，在Thumb中只能R4-R7。</p><h4 id=c汇编的混合编程>C/汇编的混合编程</h4><h5 id=优势>优势</h5><p>C和汇编能很容易的混合:</p><ol><li><p>可实现在c中无法实现的处理器功能</p></li><li><p>使用新的或不支持的指令</p></li><li><p>产生更高效的代码</p></li></ol><p>直接链接变量和程序</p><ol><li><p>确定符合程序调用规范</p></li><li><p>输入/输出相关的符号</p></li></ol><p>编译器也可保留内嵌汇编</p><ol><li><p>大多数arm指令都可实现</p></li><li><p>内嵌汇编代码可由编译器的优化器来传递</p></li></ol><h5 id=在c语言中调用汇编>在C语言中调用汇编</h5><p><img alt=image-7 src=/images/ARM/image-7.png></p><h5 id=gcc内联汇编>GCC内联汇编</h5><p>Gcc 通过关键字“asm”来声明内联汇编。</p><p>asm(code : output operand list : input operand list : clobber list);</p><p>每一个asm语句被冒号（:）分成了四个部分。</p><ol><li>指令</li><li>[符号名]“限制字符串”(C变量)</li><li>输入操作符</li><li>破坏符列表</li></ol><p><img alt=image-8 src=/images/ARM/image-8.png></p><h4 id=heading></h4><h3 id=五gpio通用io接口>五、GPIO通用IO接口</h3><h4 id=gpio相关寄存器描述>GPIO相关寄存器描述</h4><p>IOxPIN：状态读出</p><p>IOxSET：1则置位为1</p><p>IOxCLR：1则置位为0</p><p>IOxDIR：0输入，1输出</p><h5 id=例子读取p00引脚状态>例子——读取P0.0引脚状态</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>uint32 PinStat;
</span></span><span style=display:flex><span>PINSEL0 <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0xFFFFFFFC</span>	<span style=color:#75715e>//P0.0为GPIO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>IO0DIR	<span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0xFFFFFFFE</span>	<span style=color:#75715e>//设置P0.0方向设置为输入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>PinStat <span style=color:#f92672>=</span> IO0DIR
</span></span></code></pre></div><h4 id=gpio常用寄存器分类>GPIO常用寄存器分类</h4><ol><li>引脚控制寄存器GPxCON</li><li>引脚数据寄存器GPxDAT</li><li>引脚上下拉设置寄存器GPxPUD</li><li>引脚驱动能力寄存器GPxDRV</li><li>低功耗模式引脚功能控制寄存器GPxCONPDn</li><li>低功耗引脚上下拉设置寄存器GPxPUDPDN</li></ol><h4 id=gpio点亮led实验>GPIO点亮LED实验</h4><h5 id=涉及寄存器>涉及寄存器</h5><ol><li>GPIO引脚控制寄存器GPX2CON</li></ol><p>四位为一组，分为GPX2CON[0至7]，赋值0x0为输入，0x1为输出，0x2为保留</p><ol start=2><li>GPIO数据引脚寄存器GPX2DAT</li></ol><p>七位，对应位决定了引脚的电平</p><ol start=3><li>GPIO引脚上下拉设置寄存器GPX2PUD</li></ol><p>初始状态0x5555，位[2n+1:2n]，0x0禁止上下拉，0x1使能下拉，0x2保留，0x3使能上拉</p><h5 id=实验图>实验图</h5><p><img alt=image-9 src=/images/ARM/image-9.png></p><h5 id=代码>代码</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;exynos_4412.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>// delay
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mydelay_ms</span>(<span style=color:#66d9ef>int</span> ms) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> i, j;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (ms<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>514</span>; j<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// GPX2_7:	output LED2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// GPX1_0:	output LED3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// GPF3_4:	output LED4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// GPF3_5:	output LED5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 模式设置，每个占四位二进制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// GPX2CON[7] = 0x1 	Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPX2.CON <span style=color:#f92672>=</span> (GPX2.CON <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0xf</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>)) <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// GPX1CON[0] = 0x1 	Output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPX1.CON <span style=color:#f92672>=</span> (GPX1.CON <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0xf</span>)) <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// GPF3CON[4] = GPF3CON[5] = 0x1 	Outout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPF3.CON <span style=color:#f92672>=</span> (GPX3.CON <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0xf</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>0xf</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>20</span>)) <span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>//Turn on LED2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// GPX2DAT[7] = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPX2.DAT <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>		mydelay_ms(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//Turn on LED3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// GPX1DAT[0] = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPX1.DAT <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//Turn off LED2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// GPX1DAT[7] = 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPX2.DAT <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>		mydelay_ms(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//Turn on LED5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// GPF3DAT[5] = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPF3.DAT <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//Turn off LED3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// GPX1DAT[0] = 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPX1.DAT <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span><span style=color:#ae81ff>0x1</span>;
</span></span><span style=display:flex><span>		mydelay_ms(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//Turn on LED4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// GPF3DAT[4] = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPF3.DAT <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//Turn off LED5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// GPF3DAT[5] = 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPF3.DAT <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>		mydelay_ms(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//Turn off LED4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// GPF3DAT[4] = 0;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPF3.DAT <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=六异常与中断>六、异常与中断</h3><h4 id=异常>异常</h4><p>ARM处理器有7种类型的异常，按照优先级从高到低的排列如下</p><ol><li>复位异常</li><li>数据异常</li><li>快速中断异常</li><li>外部中断异常</li><li>预取异常</li><li>软中断异常</li><li>未定义指令异常</li></ol><h5 id=向量表>向量表</h5><p>在异常发生时，处理器会把PC设置为一个特定的存储器地址，这一地址被放在<strong>向量表</strong>的特定地址范围内，向量表的入口是一些跳转指令，跳转到专门处理某个异常（中断）的子程序。</p><p>存储器映射地址0x00000000是为向量表保留的。</p><table><thead><tr><th style=text-align:center>异常类型</th><th style=text-align:center>执行低地址</th><th style=text-align:center>执行高地址</th></tr></thead><tbody><tr><td style=text-align:center>复位异常</td><td style=text-align:center>0x00000000</td><td style=text-align:center>0xFFFF0000</td></tr><tr><td style=text-align:center>未定义指令异常</td><td style=text-align:center>0x00000004</td><td style=text-align:center>0xFFFF0004</td></tr><tr><td style=text-align:center>软中断异常</td><td style=text-align:center>0x00000008</td><td style=text-align:center>0xFFFF0008</td></tr><tr><td style=text-align:center>预取异常</td><td style=text-align:center>0x0000000C</td><td style=text-align:center>0xFFFF000C</td></tr><tr><td style=text-align:center>数据异常</td><td style=text-align:center>0x00000010</td><td style=text-align:center>0xFFFF0010</td></tr><tr><td style=text-align:center>外部中断异常</td><td style=text-align:center>0x00000018</td><td style=text-align:center>0xFFFF0018</td></tr><tr><td style=text-align:center>快速中断异常</td><td style=text-align:center>0x0000001C</td><td style=text-align:center>0xFFFF001C</td></tr></tbody></table><h5 id=处理步骤>处理步骤</h5><h5 id=arm异常响应的流程>ARM异常响应的流程</h5><h4 id=中断向量控制器>中断向量控制器</h4><h5 id=概述>概述</h5><p>ARM7TDMI内核具有两个中断输入，分别为IRQ中断和FIQ中断。**向量中断控制器（VIC）**负责管理芯片的中断源，最多可以管理32个中断输入请求。</p><h5 id=cpsr与vic的关系>CPSR与VIC的关系</h5><p>ARM内核通过CPSR来监视和控制内部的操作，CPSR中的“I”位和“F”位分别用来控制IRQ模式和FIQ模式的使能。</p><h5 id=中断分类>中断分类</h5><p>FIQ中断：最高优先级</p><p>向量IRQ中断：中等优先级</p><p>非向量IRQ中断：最低优先级</p><h5 id=fiq中断硬件处理流程>FIQ中断硬件处理流程</h5><ol><li>发生FIQ异常事件</li><li>SPSR_fiq=CPSR</li><li>切换到FIQ模式</li><li>禁止IRQ和FIQ中断，即I=F=1</li><li>保存返回地址LR_fiq=PC</li><li>设置FIQ异常入口地址PC=0x1C</li></ol><h5 id=irq中断响应流程>IRQ中断响应流程</h5><ol><li>发生IRQ异常事件</li><li>SPSR_irq=CPSR</li><li>切换到IRQ模式</li><li>禁止IRQ中断，即I=1</li><li>保存返回地址LR_irq=PC</li><li>设置IRQ异常入口地址PC=0x18</li></ol><h5 id=控制寄存器描述>控制寄存器描述</h5><table><thead><tr><th style=text-align:center>名称</th><th style=text-align:center>描述</th><th style=text-align:center>访问</th><th style=text-align:center>复位值</th><th style=text-align:center>地址</th></tr></thead><tbody><tr><td style=text-align:center>VICIntEnable</td><td style=text-align:center>中断使能寄存器，控制32个中断请求的使能</td><td style=text-align:center>R/W</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F010</td></tr><tr><td style=text-align:center>VICIntEnClr</td><td style=text-align:center>中断使能清零寄存器，将中断使能寄存器中的一个或多个位清零</td><td style=text-align:center>W</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F014</td></tr><tr><td style=text-align:center>VICIntSelect</td><td style=text-align:center>中断选择寄存器，将32个中断请求的每个中断分配为FIQ或者IRQ</td><td style=text-align:center>R/W</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F00C</td></tr><tr><td style=text-align:center>VICSoftInt</td><td style=text-align:center>软件中断寄存器，控制对应通道产生软件中断</td><td style=text-align:center>R/W</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F018</td></tr><tr><td style=text-align:center>VICSoftIntClear</td><td style=text-align:center>软件中断清零寄存器，禁止对应通道的软件中断</td><td style=text-align:center>W</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F01C</td></tr></tbody></table><p>VICIntEnalbe、VICIntEnClr：使能（禁止）中断源产生中断</p><p>VICIntSelect：中断类型选择FIQ&amp;IRQ</p><p>VICSoftInt、VICSoftIntClear：软件中断设置寄存器</p><h5 id=参数设置寄存器描述>参数设置寄存器描述</h5><table><thead><tr><th style=text-align:center>名称</th><th style=text-align:center>描述</th><th style=text-align:center>复位值</th><th style=text-align:center>地址</th></tr></thead><tbody><tr><td style=text-align:center>VICVectCntl0~VICVectCntl15</td><td style=text-align:center>向量控制0寄存器~向量控制15寄存器</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F200~0xFFFF F23C</td></tr><tr><td style=text-align:center>VICVectAddr0~VICVectAddr15</td><td style=text-align:center>向量地址0寄存器~向量地址15寄存器</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F100~0xFFFF F13C</td></tr><tr><td style=text-align:center>VICDefVectAddr</td><td style=text-align:center>默认向量地址寄存器</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F034</td></tr><tr><td style=text-align:center>VICVectAddr</td><td style=text-align:center>向量地址寄存器</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F030</td></tr></tbody></table><h5 id=irq中断特点>IRQ中断特点</h5><p>向量IRQ中断：支持16个向量IRQ中断、有16个优先级、每个优先级指定一个服务程序入口地址</p><p>非向量IRQ中断：支持1个非向量IRQ中断；所有非向量IRQ的入口地址都相同</p><p>区别：向量IRQ中断能为每个非向量IRQ中断源设置服务程序地址；所有的非向量IRQ中断都公用一个相同的服务程序入口地址。</p><p>对于中断产生后的服务程序地址</p><p>向量IRQ中断：发生向量IRQ中断后，VIC将对应的<strong>向量地址寄存器</strong>中的数据存入VICVectAddr寄存器中。
非向量IRQ中断：发生非向量IRQ中断后，VIC将<strong>默认向量地址寄存器</strong>中的数据存入VICVectAddr寄存器中。</p><h5 id=irq中断相关寄存器>IRQ中断相关寄存器</h5><table><thead><tr><th style=text-align:center>寄存器名称</th><th style=text-align:center>功能</th></tr></thead><tbody><tr><td style=text-align:center>VICVectCntl0~15</td><td style=text-align:center>为中断源分配向量IRQ中断的优先级</td></tr><tr><td style=text-align:center>VICVectAddr0~15</td><td style=text-align:center>为该中断优先级设置服务程序入口地址</td></tr><tr><td style=text-align:center>VICDefVectAddr</td><td style=text-align:center>设置非向量中断服务程序的入口地址</td></tr></tbody></table><p>如果将同一个中断源分配给多个使能的向量IRQ中断，那么该中断源发生中断时，会使用最高优先级（最低编号）的寄存器设置。</p><h5 id=状态寄存器描述>状态寄存器描述</h5><table><thead><tr><th style=text-align:center>名称</th><th style=text-align:center>描述</th><th style=text-align:center>访问</th><th style=text-align:center>复位值</th><th style=text-align:center>地址</th></tr></thead><tbody><tr><td style=text-align:center>VICIRQStatus</td><td style=text-align:center><strong>IRQ状态寄存器</strong>，该寄存器读出定义为IRQ并使能的中断的状态</td><td style=text-align:center>R</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F000</td></tr><tr><td style=text-align:center>VICFIQStatus</td><td style=text-align:center><strong>FIQ状态请求</strong>，该寄存器读出定义为FIQ并使能的中断的状态</td><td style=text-align:center>R</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F004</td></tr><tr><td style=text-align:center>VICRawIntr</td><td style=text-align:center>所有中断的状态寄存器</td><td style=text-align:center>R</td><td style=text-align:center>0</td><td style=text-align:center>0xFFFF F008</td></tr></tbody></table><p>注意：读取VICRawIntr寄存器将得到所有32个中断请求和软件中断的状态，它不管中断是否使能或分类</p><h5 id=保护使能寄存器>保护使能寄存器</h5><p>VICProtection，当该位为1时，只能在特权模式下访问VIC寄存器。</p><h5 id=fiq的中断处理>FIQ的中断处理</h5><h6 id=硬件处理>硬件处理</h6><ol><li>SPSR_fiq = CPSR</li><li>CPSR = nzcvqIFt_fiq</li><li>LR_fiq = PC</li><li>PC=0x1C</li></ol><h6 id=软件处理>软件处理</h6><ol><li>中断服务程序</li><li>设置返回地址</li><li>恢复CPSR</li></ol><p>SUBS PC, LR, #4</p><h5 id=irq的中断处理>IRQ的中断处理</h5><h6 id=硬件处理-1>硬件处理</h6><ol><li>SPSR_irq = CPSR</li><li>CPSR = nzcvqlft_irq</li><li>VICVectAddr = VICVectAddrn</li><li>LR_irq = PC</li><li>PC = 0x18</li></ol><h6 id=软件处理-1>软件处理</h6><ol><li>获取中断服务程序地址【PC:=[VICVectAddr], LDR PC,[PC,#-0xff0]】</li><li>执行中断处理程序</li><li>设置返回地址</li><li>恢复CPSR</li></ol><p>SUBS PC, LR, #4</p><h5 id=irq中断的发生过程>IRQ中断的发生过程</h5><ol><li>正在执行用户程序</li><li>外部中断0发生中断</li><li>VIC硬件将中断服务程序地址装入VICVectAddr寄存器【VICVectAddr()→VICVectAddr】</li><li>程序跳转至异常向量表中IRQ入口<strong>0x0018</strong>处</li><li>执行指令跳转至VICVectAddr寄存器中的中断服务地址；</li><li>中断服务程序执行完毕，返回被中断的用户程序继续执行被中断的代码；</li></ol><h5 id=注意要点>注意要点</h5><ol><li>如果在片内RAM中调试程序，并使用了中断，那么必须将存储器映射控制设置为内部RAM模式；</li><li>将多个中断源设置为FIQ，将增加中断响应延时，所以建议FIQ中断只有一个中断源；</li><li>ADS1.2规定在定义中断服务函数时必须加入关键字“__irq”，保证函数返回时会切换处理器模式；</li><li>在退出中断服务程序时要清零相应外设的中断标志，以及VICVectAddr寄存器，为响应下次中断作好准备。</li></ol><h5 id=vic相关启动代码分析>VIC相关启动代码分析</h5><p>在LPC2100、LPC2200的启动代码中包含有VIC初始化程序，默认是禁止所有中断。</p><p>VICIntEnClr = 0xffffffff;</p><p>VICVectAddr = 0;</p><p>VICIntSelect = 0;</p><p>默认关闭IRQ和FIQ，如果要使用这两个中断，需要设置CPSR寄存器。最简单的方法是在启动代码中设置（修改0xdf值）。</p><p>IRQ：向量表0x0018地址； FIQ：跳转到向量表0x001C地址执行指令，然后跳转到FIQ_Handler代码段</p><h4 id=外部中断输入>外部中断输入</h4><h5 id=中断类型>中断类型</h5><p>边沿触发：（上升沿、下降沿）、电平触发（高电平、低电平）</p><h5 id=独立中断输入>独立中断输入</h5><p>外部中断含有四个独立的中断输入。中断源14-17。</p><h4 id=系统控制模块功能汇总>系统控制模块功能汇总</h4><h5 id=寄存器汇总>寄存器汇总</h5><table><thead><tr><th style=text-align:center>名称</th><th style=text-align:center>描述</th><th style=text-align:center>访问</th><th style=text-align:center>复位值</th><th style=text-align:center>地址</th></tr></thead><tbody><tr><td style=text-align:center>EXTINT</td><td style=text-align:center>外部中断标志寄存器</td><td style=text-align:center>R/W</td><td style=text-align:center>0</td><td style=text-align:center>0xE01FC140</td></tr><tr><td style=text-align:center>EXTWAKE</td><td style=text-align:center>外部中断唤醒寄存器</td><td style=text-align:center>R/W</td><td style=text-align:center>0</td><td style=text-align:center>0xE01FC144</td></tr><tr><td style=text-align:center>EXTMODE</td><td style=text-align:center>外部中断方式寄存器</td><td style=text-align:center>R/W</td><td style=text-align:center>0</td><td style=text-align:center>0xE01FC148</td></tr><tr><td style=text-align:center>EXTPOLAR</td><td style=text-align:center>外部中断极性寄存器</td><td style=text-align:center>R/W</td><td style=text-align:center>0</td><td style=text-align:center>0xE01FC14C</td></tr></tbody></table><p>EXTINT[0-3]对应为1代表出现指定的外部中断，写入1可以进行清零。</p><p>EXTWAKE[0-3]写入1，允许外部中断将CPU从掉电模式唤醒</p><p>EXTMODE ：0电平触发，1边沿触发</p><p>EXTPOLAR ：电平触发下，0为低电平触发；边沿触发下，0为下降沿触发</p><p>通过设置PINSELx寄存器选择对应引脚为外部中断引脚。</p><h5 id=外部中断与vic的关系>外部中断与VIC的关系</h5><p>外部中断0位于VIC的通道14，VICIntEnable[14]=0时，中断禁止；</p><p>VICIntSelect[14]=1时分配为FIQ中断。</p><h4 id=gic中断系统>GIC中断系统</h4><p>Exynos4412集成了通用中断控制器GIC</p><p><img alt=image-10 src=/images/ARM/image-10.png></p><h5 id=gic中断控制器中断类型>GIC中断控制器中断类型</h5><ol><li>软中断SGI：软件生成的中断，通过软件写入软中断产生中断寄存器（ICDSGIR）。常用在核间通信。软中断能以所有核为目标或选定的一组系统中的核心为目标。中断号0-15为SGI保留。</li><li>专用外设中断PPI：由外设产生的，是专由特定核心处理的中断。中断号码16-31为PPI保留。</li><li>共享外设中断SPI：这是由外设产生的可以发送给一个或多个核心处理的中断源。中断号32-1020用于共享外设中断。</li></ol><h5 id=gic中断状态>GIC中断状态</h5><ol><li>Inactive无效</li><li>Pending待处理</li><li>Active正在处理</li><li>Active and pending 处理和待处理</li></ol><h5 id=gic中断处理流程>GIC中断处理流程</h5><ol><li>跳转到异常向量表，PC寄存器获取对应异常向量并执行中断处理函数</li><li>先读取GIC控制器CPU接口中的中断响应寄存器ICCIAR，获取需要处理的中断ID号进行具体的中断处理；同时作为ARM核心对GIC发来的中断信号的应答，GIC接受应答，GIC分配器会把对应中断源状态设置为Active</li><li>执行结束后，中断处理函数需要写入相同的中断ID号和GIC控制器CPU接口模块中的中断结束寄存器ICCEOIR，作为给GIC控制器的中断处理结束信号，状态设置为Inactive，GIC控制器CPU接口模块继续提交一个优先级最高的Pending中断到ARM核心进行中断处理。</li><li>如果在次中断处理过程中，又有相同中断触发，状态设置为Inactive and Pending。</li></ol><h4 id=gic中断实验>GIC中断实验</h4><h5 id=编程流程>编程流程</h5><ol><li>设置GPX1_1、GPX1_2两个管脚没有内部上下拉属性，然后配置为中断模式；</li><li>设置中断触发方式；</li><li>GPIO 控制器中关闭屏蔽、使能中断；</li><li>在 GIC 中断控制器中使能中断；</li><li>设置中断优先级；</li><li>使能 GIC；</li><li>选择中断发送给 CPU0；</li><li>等待中断产生，然后进入中断处理器函数；</li><li>清除中断源的挂起状态</li></ol><h5 id=实验图-1>实验图</h5><p><img alt=image-11 src=/images/ARM/image-11.png></p><p>实验效果：当按下 Key2 或 Key3 的时候观察 LED2 和 LED3 的亮灭情况，通过串口中断也可以看到对应的打印信息。</p><h5 id=代码-1>代码</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;exynos_4412.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_irq</span>(<span style=color:#66d9ef>void</span> ) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> irq_num;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 读取GIC控制器CPU接口中的中断响应寄存器ICCIAR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 获取需要处理的中断ID号进行具体的中断处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	irq_num <span style=color:#f92672>=</span> (CPU0.ICCIAR <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3FF</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> (irq_num) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 判断中断类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>58</span><span style=color:#f92672>:</span> <span style=color:#75715e>//控制数据寄存器关闭LED3，打开LED2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPX2.GPX2DAT <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>		GPX1.GPX1DAT <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span><span style=color:#ae81ff>0x1</span>;
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 打印信息提示
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		printf(<span style=color:#e6db74>&#34;IRQ interrupt !! turn on LED2; turn off LED3</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 清除GPIO控制器中断挂起位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		EXT_INT41_PEND <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 清中断控制模块GIC的中断标志（即清除分配器中的58号中断标志）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		ICDICPR.ICDICPR1 <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>26</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>57</span><span style=color:#f92672>:</span> <span style=color:#75715e>//控制数据寄存器打开LED3，关闭LED2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPX2.GPX2DAT <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>		GPX1.GPX1DAT <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span>;
</span></span><span style=display:flex><span>		printf(<span style=color:#e6db74>&#34;IRQ interrupt !! Turn on LED3; Turn off LED2</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 清除GPIO控制器中断挂起位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  		EXT_INT41_PEND <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>		ICDICPR.ICDICPR1 <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>26</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 中断返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	CPU0.ICCEOIR <span style=color:#f92672>=</span> (CPU0.ICCEOIR <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1FF</span>)) <span style=color:#f92672>|</span> irq_num;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mydelay_ms</span>(<span style=color:#66d9ef>int</span> ms) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> i, j;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(ms<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>514</span>; j<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//LED2 GPX2_7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 	GPX2.GPX2CON <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>//LED3 GPX1_0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPX1.GPX1CON <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>//LED4 GPF3_4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPF3.GPF3CON <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//Key_2  Interrupt  GPX1_1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 2位一组，0x3禁止上下拉
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPX1.GPX1PUD <span style=color:#f92672>=</span> GPX1.GPX1PUD <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x3</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 4位一组，0xF设置中断WAKEUP_INT1[1](对应EXT_INT41[1])
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPX1.GPX1CON <span style=color:#f92672>=</span> (GPX1.GPX1CON <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0xF</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>)) <span style=color:#f92672>|</span> (<span style=color:#ae81ff>0xF</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>); 
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 中断配置寄存器，先与~(0x7 &lt;&lt; 4)清空位，设置位0010（触发方式下降沿）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	EXT_INT41_CON <span style=color:#f92672>=</span> (EXT_INT41_CON <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x7</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>)) <span style=color:#f92672>|</span> <span style=color:#ae81ff>0x2</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 中断使能寄存器，第一位为0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	EXT_INT41_MASK <span style=color:#f92672>=</span> (EXT_INT41_MASK <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>)); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//Key_3  Interrupt  GPX1_2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 2位一组，0x3禁止上下拉
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPX1.GPX1PUD <span style=color:#f92672>=</span> GPX1.GPX1PUD <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x3</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>); 
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 4位一组，0xF设置中断WAKEUP_INT1[2](对应EXT_INT41[2])
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPX1.GPX1CON <span style=color:#f92672>=</span> (GPX1.GPX1CON <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0xF</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>)) <span style=color:#f92672>|</span> (<span style=color:#ae81ff>0xF</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 中断配置寄存器，先与~(0x7 &lt;&lt; 8)清空位，设置位0010
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	EXT_INT41_CON <span style=color:#f92672>=</span> (EXT_INT41_CON <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x7</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>)) <span style=color:#f92672>|</span> <span style=color:#ae81ff>0x2</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 中断使能寄存器，第2位为0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	EXT_INT41_MASK <span style=color:#f92672>=</span> (EXT_INT41_MASK <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>)); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Key2、Key3 中断号为SPI25与SPI26
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ICDISER.ICDISER1 <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>25</span>) <span style=color:#f92672>|</span> (<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>26</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 全局使能CPU0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	CPU0.ICCICR <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span>; 
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 使CPU0能处理所有优先级的中断
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	CPU0.ICCPMR <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xFF</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// GIC使能
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ICDDCR <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置将SPI25和SPI26发送给CPU0处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ICDIPTR.ICDIPTR14 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x01010101</span>;	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>		<span style=color:#75715e>// LED4亮
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPF3.GPF3DAT <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>		mydelay_ms(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>		<span style=color:#75715e>// LED4灭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPF3.GPF3DAT <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>		mydelay_ms(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>P166-</p><h3 id=七串口通信>七、串口通信</h3><h4 id=通用异步收发uart接口简介>通用异步收发UART接口简介</h4><h5 id=串行通信>串行通信</h5><p>计算机与I/O设备之间数据传输的各位按顺序依次进行传送，一条数据线或一对差分线上传输</p><h5 id=并行通信>并行通信</h5><p>多条传输线交换数据，各位同时进行传送。</p><p>前者速度慢，后者成本高。一些差分串行通信总线，如RS-485、RS-422、USB等，传输距离远也速度快。</p><h5 id=异步串行方式特点>异步串行方式特点</h5><p>数据传送以字符为单位，字符间传送完全一部，位与位之间传送同步【字符间异步，字符内部同步】</p><h5 id=串行异步方式数据格式>串行异步方式数据格式</h5><p>1个信息帧：1起始位，规定为0，5-8数据位，1奇偶校验位，1-2停止位，规定为1</p><h5 id=同步串行方式特点>同步串行方式特点</h5><p>数据传输以数据块为单位，字符字符间、字符内部都是同步的【一个数据块内字符与字符间无间隔】</p><p>通常需要同步时钟</p><h5 id=同步串行方式数据格式>同步串行方式数据格式</h5><p>2个同步字符作为一个数据块的起始标志，n个连续传送的数据，2字节的CRC</p><h5 id=波特率波特率因子位周期>波特率、波特率因子、位周期</h5><p>波特率，单位比特(bit/s,bps)，单位时间内传送的二进制数据的位数。</p><p>波特率因子：时钟脉冲频率和波特率的比</p><p>位周期，波特率的倒数</p><h5 id=rs-232c串口规范>RS-232C串口规范</h5><h6 id=9针串口引脚定义>9针串口引脚定义</h6><table><thead><tr><th style=text-align:center>引脚</th><th style=text-align:center>简写</th><th style=text-align:center>功能</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>CD</td><td style=text-align:center>载波侦测</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>RXD</td><td style=text-align:center>接收数据</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>TXD</td><td style=text-align:center>发送数据</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>DTR</td><td style=text-align:center>数据终端设备</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>GND</td><td style=text-align:center>地线</td></tr><tr><td style=text-align:center>6</td><td style=text-align:center>DSR</td><td style=text-align:center>数据准备好</td></tr><tr><td style=text-align:center>7</td><td style=text-align:center>RTS</td><td style=text-align:center>请求发送</td></tr><tr><td style=text-align:center>8</td><td style=text-align:center>CTS</td><td style=text-align:center>清除发送</td></tr><tr><td style=text-align:center>9</td><td style=text-align:center>RI</td><td style=text-align:center>振铃指示</td></tr></tbody></table><h6 id=接线方式>接线方式</h6><p>3线连接法：GND互联，RXD、TXD交叉连。</p><h4 id=exynos4412-uart控制器>Exynos4412-UART控制器</h4><h5 id=简介-1>简介</h5><p>5个独立的异步串行输入输出口，每个口可支持中断模式以及DMA模式</p><p>UART的波特率最大可达4Mbps，每个UART通道包含两个FIFO用于数据的收发，通道0的FIFO大小为256字节，1、4的为64字节，2、3的为16字节。</p><p>通道0-3支持红外模式，通道0-2支持自动流控功能，通道4支持GPS通信和自动流控。</p><h5 id=基本内容>基本内容</h5><p>发送数据帧是可编程的，停止位通过行控制寄存器ULCONn配置</p><p>接收数据帧也是可编程的，接收器可以检测溢出错误、奇偶校验错误、帧错误、传输中断，每个错误都能够设置一个错误标志。</p><p>溢出：已收到数据在读取之前被覆盖</p><p>帧错误：没有接收到有效的停止位</p><p>传输中断错误：接收数据RxRn保持逻辑0超过一帧的传输时间</p><p>FIFO模式下，如果RxFIFO非空，在3个字的传输时间内没有接受数据，则产生超时。</p><h5 id=寄存器详解>寄存器详解</h5><h6 id=uart行控制寄存器ulconn>UART行控制寄存器ULCONn</h6><p>[1:0] 数据位个数，00=5bit，11=8bit</p><p>[2] 停止位数量，0=1个停止位，1=2个停止位</p><p>[5:3]校验方式 0xx无校验，100奇校验，101偶校验，110校验位强制为1，111校验位强制为0</p><p>[6]红外模式，0正常1红外</p><h6 id=uart控制寄存器uconn>UART控制寄存器UCONn</h6><p>[1:0] 00不允许接收，01中断或查询</p><h6 id=uart-fifo控制寄存器-ufconn>UART FIFO控制寄存器 UFCONn</h6><h6 id=uart-modem控制寄存器umconn>UART MODEM控制寄存器UMCONn</h6><h6 id=发送寄存器utxhn和接收寄存器urxhn>发送寄存器UTXHn和接收寄存器URXHn</h6><p>在关闭FIFO的情况下只有一个字节8位数据。</p><h6 id=波特率设置寄存器ubrdivn和ufracvaln>波特率设置寄存器UBRDIVn和UFRACVALn</h6><p>举例：串口时钟SCLK_UART=40MHZ，以设置波特率为115200为目标，方法如下。</p><ol><li>计算DIV_VAL=$(SCLK_UART/(bps\times16))-1=4000000/(115200\times16)-1=20.7$</li><li>设置UBRDIVn寄存器数值为20</li><li>计算AC_VAL=$16\times0.7(小数(DIV_VAL))=11.2$</li><li>设置UFRACVALn寄存器数值为11</li></ol><h6 id=串口状态寄存器utrstatn>串口状态寄存器UTRSTATn</h6><p>[0] 关闭FIFO情况下，接收缓冲区是否为空 0为空</p><p>[1] 发送缓冲区是否为空 1为空</p><h4 id=串口实验>串口实验</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;exynos_4412.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mydelay</span>(<span style=color:#66d9ef>int</span> time);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mydelay_ms</span>(<span style=color:#66d9ef>int</span> time) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> i, j;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(time<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>514</span>; j<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// UART初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>uart_init</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置GPA1_0:RX;GPA1_1:TX  设置为10（TXD0）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPA1.GPA1CON <span style=color:#f92672>=</span> (GPA1.GPA1CON <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span><span style=color:#ae81ff>0xFF</span> ) <span style=color:#f92672>|</span> (<span style=color:#ae81ff>0x22</span>); 
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 模式设置，一个停止位，8位数据，没有校验位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 0000011
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// UCON：接收发送模式都是中断01，0000101
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	UART2.ULCON2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x3</span>; 
</span></span><span style=display:flex><span>	UART2.UCON2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5</span>; 
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 波特率的计算与设置 UART时钟源100Mhz
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// DIV VAL = (100*10^6 / (115200*16) - 1) = 53.3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// UBRDIV2 = 53 = 0x35
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// UFRACVAL2 = 0.3 * 16 = 0x5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	UART2.UBRDIV2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x35</span>;
</span></span><span style=display:flex><span>	UART2.UFRACVAL2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 通信代码-传输字符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>putc</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> data) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// [1] 发送缓冲区不为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>(UART2.UTRSTAT2 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0X2</span>));
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 为空则进行发送
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	UART2.UTXH2 <span style=color:#f92672>=</span> data;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (data <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>			putc(<span style=color:#e6db74>&#39;\r&#39;</span>);
</span></span><span style=display:flex><span>} 
</span></span><span style=display:flex><span><span style=color:#75715e>// 通信代码-传输串
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>puts</span>(<span style=color:#66d9ef>const</span>  <span style=color:#66d9ef>char</span>  <span style=color:#f92672>*</span>pstr) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(<span style=color:#f92672>*</span>pstr <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\0&#39;</span>)
</span></span><span style=display:flex><span>		putc(<span style=color:#f92672>*</span>pstr<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 通信代码-接收
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> <span style=color:#a6e22e>getchar</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> c;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// [0] 0为空，不断循环直到非空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>(UART2.UTRSTAT2 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0X1</span>));
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 不为空则接收
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	c <span style=color:#f92672>=</span> UART2.URXH2;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> c;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 待传输的字符串数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>char</span> c, str[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;uart test!! </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置控制寄存器，LED LED2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	GPX2.GPX2CON <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 串口初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	uart_init();
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 循环监测
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 打开LED
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPX2.GPX2DAT <span style=color:#f92672>=</span> GPX2.GPX2DAT <span style=color:#f92672>|</span> <span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 调用函数进行数据的传输
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		puts(str);
</span></span><span style=display:flex><span>		mydelay_ms(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 关闭 LED
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		GPX2.GPX2DAT <span style=color:#f92672>=</span> GPX2.GPX2DAT <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(<span style=color:#ae81ff>0x1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>		mydelay_ms(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></div><div class="row items-start justify-between"><div class="lg:col-5 mb-10 flex items-center lg:mb-0"><h5 class=mr-3>标签 :</h5><ul><li class=inline-block><a class="bg-theme-light hover:bg-primary dark:bg-darkmode-theme-light dark:hover:bg-darkmode-primary dark:hover:text-dark m-1 block rounded px-3 py-1 hover:text-white" href=/en/tags/%e5%b5%8c%e5%85%a5%e5%bc%8f%e7%b3%bb%e7%bb%9f/>嵌入式系统</a></li></ul></div></div></article></div></div></section></main><footer class="bg-theme-light dark:bg-darkmode-theme-light"><div class=container><div class="row items-center py-10"><div class="lg:col-3 mb-8 text-center lg:mb-0 lg:text-left"><a class="navbar-brand inline-block" href=/en/><img fetchpriority=high decoding=async class="img logo-light" width=160 height=32 src=/images/logo-1_hubf409f6fc77577ff09f7cacc73653041_8513_320x0_resize_q80_h2_lanczos_3.webp alt=Hugoplate onerror='this.onerror=null,this.src="/images/logo-1_hubf409f6fc77577ff09f7cacc73653041_8513_320x0_resize_lanczos_3.png"'>
<img fetchpriority=high decoding=async class="img logo-dark" width=160 height=32 src=/images/logo-2_hu06a606f114baa5722e40403b02652855_7961_320x0_resize_q80_h2_lanczos_3.webp alt=Hugoplate onerror='this.onerror=null,this.src="/images/logo-2_hu06a606f114baa5722e40403b02652855_7961_320x0_resize_lanczos_3.png"'></a></div><div class="lg:col-6 mb-8 text-center lg:mb-0"><ul><li class="m-3 inline-block"><a href=/en/about/>个人信息</a></li><li class="m-3 inline-block"><a href=/en/blog/>学习笔记</a></li><li class="m-3 inline-block"><a href=/en/privacy-policy/>相关说明</a></li></ul></div><div class="lg:col-3 mb-8 text-center lg:mb-0 lg:mt-0 lg:text-right"><ul class=social-icons><li><a target=_blank aria-label=github rel="nofollow noopener" href=https://www.github.com/COOOIKX><i class="fab fa-github"></i></a></li><li><a target=_blank aria-label=csdn rel="nofollow noopener" href="https://blog.csdn.net/m0_59701064?spm=1000.2115.3001.5343"><i class="fas fa-home-lg"></i></a></li></ul></div></div></div><div class="border-border dark:border-darkmode-border border-t py-7"><div class="text-light dark:text-darkmode-light container text-center"><p>Designed by Zeon Studio and Developed by LHF</p></div></div></footer><script crossorigin=anonymous integrity="sha256-YQerunHGeT7hXzxweSqFUXgOHHxFceSjmMy/kmnAHWU=" src=/js/script.min.6107abba71c6793ee15f3c70792a8551780e1c7c4571e4a398ccbf9269c01d65.js></script><script defer async crossorigin=anonymous integrity="sha256-w+aS42D2+B+Jix+joZ7pAua1vbu/pRK/IhoP55b8n3w=" src=/js/script-lazy.min.c3e692e360f6f81f898b1fa3a19ee902e6b5bdbbbfa512bf221a0fe796fc9f7c.js></script><script>"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js")</script></body></html>