[{"section":"Blog","slug":"/en/blog/it-project-management/","title":"【课程笔记】IT项目管理","description":"this is meta description","date":"March 2, 2024","image":null,"imageSM":null,"searchKeyword":"","categories":"课程笔记","tags":"IT项目管理","content":"一、基本概念 1.1 价值 1.1.1 项目的价值 组织通过日常工作来维持基本的运行，通过项目来推进自身的发展和壮大。 项目价值是指项目具有明示和潜在的功能，能满足利益相关方明示和潜在的需要。 项目是实现价值、成就事业的载体，通过项目来实现企业和人生的价值，通过三个层次来体现：管理项目、发现项目、创造项目。\n1.1.2 项目管理的价值 项目管理是管理学的子集，具有管理学在通常意义上的价值。项目管理最主要的价值来源是通过完成业务目标来获得的，而要确保业务目标的实现，需要有效的项目管理，实行项目管理可以为企业创造巨大价值。\n1.2 项目概念 1.2.1 人类活动的特点 目的性、依存性、知识性\n1.2.2 作业与项目 作业：连续不断、周而复始的活动；项目：临时的、一次性的活动\n1.2.3 项目定义 利用有限资源、在一定时间内，完成满足一系列特定目标的多项相关工作\n1.2.4 项目特征 目标独特性、项目一次性、项目整体性、项目临时性、项目不确定性、资源多变性\n1.3 项目管理 现代管理科学是从关键路径法（Critical Path Method，CPM）和计划评审技术（Program Evaluation and Review Technique，PERT）的基础上发展，通过融合后发展起来的工作分解结构（Work Breakdown Structure，WBS）、蒙特卡洛（MonteCarlo Simulation，MCS）统计模拟方法和挣值（Earned Value，EV）分析技术，形成关于项目资金、时间、人力等资源控制的管理科学。\n1.3.1 管理的概念 管理是管理者为了有效地实现组织目标、个人发展和社会责任，运用管理智能进行协调的过程。 内涵P9\n1.3.2 项目管理定义 美国项目管理协会PMI给出定义：项目管理就是将知识、技能、工具与技术应用于项目活动，以满足项目的需要。项目管理通过合理运用和整合项目管理过程得以实现。 五大过程组：启动、规划、执行、监控、收尾\n1.3.3 项目管理特点 五项基本任务：项目计划、项目组织、质量管理、费用控制、进度控制 项目管理必须通过不完全确定的过程，在确定的期限内生产出不完全确定的产品或完成不完全确定的任务。 P11\n1.3.4 项目管理知识体系 PMI和PMBOK\nPMI：美国项目管理协会\nPMBOK：项目管理知识系统\n4大核心知识领域：项目范围管理、项目时间管理、项目成本管理、项目质量管理\n5大辅助知识领域：项目人力资源管理、项目沟通管理、项目风险管理、采购管理和项目于系人管理\nIPMA与ICB\nIPMA：国际项目管理协会\nICB：国际项目管理知识体系\n划分为42个要素：28个核心要素、14个附加要素；个人素质的8大特征、总体印象的10个方面\n1.4 IT项目 信息技术IT：包括传感器技术、通信技术、计算机技术、控制技术等\n1.4.1 定义 信息化的实现以IT项目为载体，以信息技术为基础。 用IT信息化来综合描述信息技术与信息化，与此对应的项目称之为IT信息化项目；有时将以计算机为主体的各种项目称为IT项目。 利用有限资源、在一定时间内，完成满足一系列特定的IT信息化目标和多项相关工作叫做IT项目。\n1.4.2 IT项目特征 目标不确定性、需求不稳定性、费用不可控性、项目时限性、对智力的依赖性、项目评价的主观性、项目创新性\n1.4.3 IT项目管理 定义：是指在一定期限内，根据一定的IT信息化项目需求，依托一定的资源，为达成一定的IT信息化目标而进行的一系列活动 特点：P24\n1.5 软件与软件项目 软件定义、软件分类、软件特点、软件项目特点、软件项目管理意义与重点\n课后题与思考 "},{"section":"Blog","slug":"/en/blog/security/","title":"【课程笔记】信息安全技术","description":"this is meta description","date":"March 2, 2024","image":null,"imageSM":null,"searchKeyword":"","categories":"课程笔记","tags":"信息安全技术","content":"《信息安全技术》 1. 信息与网络安全概念 3. 传统加密技术 3.1 对称密码模型 包含：明文M、加密算法E、密钥K、密文C、解密算法D\nE总是公开的，保密依靠密钥K\n满足要求：1. 加密算法必须足够强，至少在敌手获取一个或者多个密文时无法破译密文或算出密钥。 2. 发送方和接收方必须在某种安全的形式下获得密钥并且必须保证密钥安全（密钥需要通过安全信道）。\n3.1.1 密码编码学 密码编码学系统将具有以下三个独立的特征。\n将明文转换为密文的运算类型：基于代替和置换 密钥数目：分为对称加密和非对称加密 处理明文的方法：分为分组密码和流密码 [分组密码每次处理输入的一组元素，相应地输出一组元素，流密码连续地处理输入元素，每次输出一个元素] 3.1.2 密码分析学和穷举攻击 攻击密码系统的典型目标是恢复使用的密钥，而不是只恢复单个密文对应的明文。通用方法包括密码分析学和穷举攻击。\n密码分析学：依赖算法的性质、明文的一般特性或者某些明密文对。\n穷举攻击：尝试所有可能的密钥。\n加密算法应当满足的标准：\n破译密码的代价超过密文信息的价值； 破译密码的时间超过密文信息的有效生命期。 3.2 代替技术 3.2.1 Caesar密码 密钥k，明文C，每个明文字母k：C=E(k,p)=(p+k) mod 26\n解密：p=D(k,C) = (C-k) mod 26\n缺陷：需要测试的密钥只有25个，容易被进行穷举攻击分析。\n3.2.2 单表替代密码 置换：有限集合中交换位置，有n个元素的集合则有n!个置换。\n缺陷：虽然密钥空间很大没法穷举攻击，但是它带有原始字母使用频率的一些统计学特征。\n思考：如果对每个明文元素分配的密文元素的个数与此明文元素的使用频率成一定的比例关系，那么使用频率信息就会被完全破坏。解决方案：多个字母一起加密或者多表替代。\n3.2.3 PlayFair密码 密钥词构造出一个密钥矩阵：去除重复元素，从上到下从左到右填入矩阵单元，剩余的元素按顺序进行填写，IJ当作一个字母。\n加密方法：\n将明文进行字母对划分，若两个字母是相同的，就在中间添加一个填充字母x； 落在矩阵同一行的字母对，由右边的字母替代； 落在矩阵同一列的字母对，由下面的字母替代； 该字母所在行为密文所在行，另一个字母所在列为密文所在列（先看行再看列）。 3.2.4 Hill密码 带模数的矩阵乘法加密，乘矩阵的逆进行解密\n3.2.5 多表替代加密 Vigenere密码：在Caesar的基础上增加密钥词，密钥是一个密钥词的重复。 $$ C_i=(p_i+k_{i\\ mod \\ m})\\ mod \\ 26 $$ 缺陷：密文依旧存在循环的统计特征，有一个”密钥自动生成系统“的方案：将密钥词和明文自身连接起来以便生成不重复的密钥词。\n3.2.6 一次一密 使用与消息一样长且无重复的随机密钥来加密消息，密钥只加密一条消息，之后丢弃不用。\n3.3 置换技术 一种复杂的方案为：将消息一行一行地写成矩阵，然后按列读出，但是要把列的次序进行打乱，打乱的方法根据密钥产出。多次置换密码相对来说要安全地多。\n"},{"section":"Blog","slug":"/en/blog/compiler/","title":"【课程笔记】编译原理","description":"this is meta description","date":"March 2, 2024","image":null,"imageSM":null,"searchKeyword":"","categories":"课程笔记","tags":"编译原理","content":"《编译原理》 一、引论 1.1 编译程序 翻译程序：将某一种语言程序（称为源语言程序）转换成另一种语言程序（称为目标语言程序）。\n解释程序：以该语言写的源程序为输入，但不产生目标程序，边解释边执行源程序本身。\n分类：\n诊断编译程序Diagnostic Compiler：帮助程序开发和调试 优化编译程序Optimizing Compiler：提高目标代码效率 交叉编译程序Cross Compiler：产生不同于其宿主机的机器代码的编译程序 可变目标编译程序Retargetable Compiler：不需要重写编译程序中与机器无关的部分就能改变目标机。 1.2 编译过程 五个阶段：词法分析、语法分析、语义分析与中间代码生成、优化、目标代码生成。\n词法分析：基于构词规则，输入源程序将其中的字符串进行扫描和分解得到一个个单词。工具为正规式和有限自动机 语法分析：基于语法规则，将单词符号串分解为各类语法单位，如“短语”、“子句”等。工具为：上下文无关文法，这是一种层次结构分析。 语义分析与中间代码生成：对语法分析所识别出的各类语法范畴进行含义分析，并进行初步翻译。首先进行静态语义检查（变量是否定义等），语义正确则进行中间代码翻译。依照语义规则（使用属性文法描述）。中间代码：一种含义明确、便于处理的记号系统，通常独立于具体的硬件。例如四元式（算符-左操作数-右操作数-结果） 优化：对中间代码进行加工变换，使得在最后阶段能产生出更高效的目标代码。主要方面：公共子表达式的提取、循环优化、删除无用代码、并行化处理等。原则：程序的等价变换规则。 目标代码生成：把中间代码变化成特定机器上的低级语言代码。依赖于硬件系统结构和机器指令含义。目标代码的形式可以是绝对指令代码（可以立即执行）或可重定位的指令代码或汇编指令代码（需要汇编器汇编后才能执行）。大多数编译程序产生的目标代码都是一种可重定位的指令代码，还需要连接装配程序把各个目标模块连接在一起，并确定程序变量在主存中的位置、装入内存中指定的起始地址。 1.3 编译程序的结构 源程序-\u0026gt;词法分析器-\u0026gt;单词符号。词法分析器，又称为扫描器。 单词符号-\u0026gt;语法分析器-\u0026gt;语法单位。语法分析器，简称分析器。 语法单位-\u0026gt;语义分析与中间代码生成器-\u0026gt;中间代码。 中间代码-\u0026gt;优化器-\u0026gt;优化后的中间代码。 优化后的中间代码-\u0026gt;目标代码生成器-\u0026gt;目标代码。 表格与表格管理\n需要保持一系列表格以登记源程序的各类信息和编译各阶段的进展状况。最重要的是符号表，用来登记源程序中出现的每个名字以及名字的各种属性。（编译程序处理到名字的定义性问题时，要把各种属性填入到符号表，处理到使用性问题时，要对名字的属性进行查证。词法分析填名字，语义分析填类型，目标代码生成填地址）\n出错程序\n发现错误，报告错误，指出错误的性质和错误发生地点，并且将错误的影响限制在尽可能小的范围内。错误通常分为语法错误（在词法分析或语法分析检测出来，例如出现非法字符，括号不匹配等）和语义错误（有些只能在运行时检测出来，通常包括类型不一致、作用域错误等）两大类。\n遍\n对源程序或源程序的中间结果的一次从头到尾的扫描。当一遍中包含若干阶段时，各阶段的工作是穿插进行的，如词法分析、语法分析、语义分析和中间代码生成这三个阶段可以被安排成一遍。\n编译前端与后端\n前端：与源语言有关但与目标机无关的组成部分。（词法分析、语法分析、语义分析与中间代码生成）\n后端：与目标机有关的部分。（代码优化和目标代码生成）\n通常以中间代码为界。\n1.4 编译程序与程序设计环境 开发工具：编辑程序、连接程序、调试工具等。\n程序设计环境：编译程序+开发工具\n目前倾向于构造集成化的程序设计环境。类似于IDE？\n1.5 编译程序的生成 早期的编译程序大都是机器语言或汇编语言用作工具，但现在使用高级语言作工具来编译程序。\n现在有利用已有的高级语言开发新的高级语言，即采用一种“移植”方法，现在已有多种编制部分或张晶晶个编译程序的工具，例如编译程序-编译程序、编译程序产生器、翻译程序书写系统。\n二、高级语言及语法描述 2.1 程序语言定义 主要从语法和语义两个方面进行定义。\n语法 通过词法规则和语法规则（产生规则）来形成合式程序。\n词法规则：单词符号的形成规则；使用正规式和有限自动机描述。\n语法规则：语法单位（表达式、语句、分程序、函数、过程、程序等）的形成；使用上下文无关文法描述。\n语义 通过语义规则翻译。基于属性文法的语法制导翻译方法（不是一种形式化系统）。\n2.2 高级语言特性 分类 强制性语言：命令驱动的、面向语句的\n应用式语言：通过已有函数构造更复杂的函数\n基于规则的语言：检查一定的条件，满足值则执行适当动作\n面向对象：封装、继承、多态\n数据类型 三要素：属性（类型、作用域）、值、操作\n初等数据类型：数值数据、逻辑数据、字符数据、指针类型；数据结构；抽象数据类型\n语句与控制结构 表达式：一个表达式是由运算量（操作数，即数据引用或函数调用）和算符组成。\n语句：赋值句、控制句、说明句、简单句和复合句。\n2.3 程序语言的语法描述 基本概念 定义$\\Sigma$为有穷子目标，元素为符号，$\\Sigma$上的符号串是指有$\\Sigma$中的符号构成的又穷序列。$\\varepsilon$为空字，不含符号。\n$\\Sigma^*$为所有符号串全体。\n定义连接为： 对于$U,V \\in \\Sigma^{*}，UV=\\{\\alpha\\beta,\\alpha \\in U \\\u0026amp; \\beta \\in V \\}$。则有：\n$$ V^0=\\{\\varepsilon\\} \\\\ V^*=V^0 \\cup V^1 \\cup V^2 \\cup \u0026hellip; \\\\ V^+=V^1 \\cup V^2 \\cup V^3 \\cup\u0026hellip; $$\n$V^*$为$V$的闭包（有限次连接），$V^+$为$V$的正则闭包，无空字$\\varepsilon$。\n上下文无关文法 文法：描述语言的语法结构和形成规则（语法规则），符号$G$。\n$G$：一组终结符号$V_T$，一组非终结符$V_N$，开始符号$S$，产生式$P$。\n终结符：不可分的基本符号；非终结符：语法范畴，如算术表达式，是集合；\n产生式：产生规则，如$A\\rightarrow\\alpha$，如果用 $::=$代替$\\rightarrow$则为巴科斯范式。\n$\\alpha A \\beta$直接推出$\\alpha \\gamma \\beta$：$\\alpha A\\beta \\Rightarrow \\alpha \\gamma \\beta$。\n存在$\\alpha_1$至$\\alpha_n$的推导：$\\require{extpfeil}\\Newextarrow{\\xRightarrow}{5,5}{0x21D2} \\alpha_1 \\xRightarrow{+} \\alpha_n$（一步或若干步，多步推导）；$\\require{extpfeil}\\Newextarrow{\\xRightarrow}{5,5}{0x21D2} \\alpha_1 \\xRightarrow{*} \\alpha_n$（零步或若干步，广义推导）。\n对于文法$G$和开始符号$S$，若$\\require{extpfeil}\\Newextarrow{\\xRightarrow}{5,5}{0x21D2} S \\xRightarrow{*} \\alpha$则$\\alpha$为一个句型，仅包含终结符的话则为句子，$G$产生的句子的全体称为语言，记为$L(G)$。\n$$ \\require{extpfeil}\\Newextarrow{\\xRightarrow}{5,5}{0x21D2} LG=\\{\\alpha | S \\xRightarrow{+} \\alpha \\\u0026amp; \\alpha \\in V_T^* \\} $$\n例如：\n考虑如下一个文法$G_1$所定义的语言。 $$ S \\rightarrow bA \\\\ A \\rightarrow aA|a $$ 从开始符号$S$开始，进行以下句子推导。 $$ S \\Rightarrow bA \\Rightarrow ba \\\\ S \\Rightarrow bA \\Rightarrow baA \\Rightarrow baa \\\\ \u0026hellip; \\\\ S \\Rightarrow bA \\Rightarrow baA \\Rightarrow \u0026hellip; \\Rightarrow ba \u0026hellip;a $$ 综上，$L(G_1)=\\{ba^n|n \\ge 1\\}$。\n推导不唯一，但为了进行结构的确定性分析，通常有最左推导和最右推导。\n语法分析树 文法能够唯一确定语言，但语言不能对应唯一一个文法。\n如果一个文法存在某个句子对应两颗不同的语法树，则称该文法是二义的，左右推导对语法树的形态影响相同，非二义性的情况下画出来的语法树是一样的。\n2.4 文法类别 0型文法 $ \\forall \\alpha \\rightarrow \\beta,\\alpha \\in (V_N \\cup V_T)^* $ 且至少存在一个非终结符，同时$\\beta \\in (V_N \\cup V_T)^* $。\n1型文法 即上下文有关文法，$\\alpha \\rightarrow \\beta$满足$|\\alpha|\\le|\\beta|$，其中$S \\rightarrow \\varepsilon$例外。\n2型文法 上下文无关文法，对于非终结符的替换无需考虑上下文。$A \\rightarrow \\beta, A \\in V_N, \\beta \\in (V_N \\cup V_T)^*$。\n3型文法 左右线性文法（正规文法）\n对于右线性文法，有:$A \\rightarrow \\alpha B | \\alpha, \\alpha \\in V_T^*, A,B \\in V_N^* $\n对于左线性文法，有:$A \\rightarrow B\\alpha | \\alpha, \\alpha \\in V_T^*, A,B \\in V_N^* $\n三、词法分析 3.1 概念 源程序通过词法分析得到单词符号串。\n单词符号：关键字、标识符、常数、运算符、界符。用 二元式（单词种别，单词符号的属性值） 表示。其中单词种别用整数编码。\n3.2 设计 输入预处理 去除编辑性字符（有些语言将空白符用作界符）\n输入预处理程序被调用时处理一串定长字符进入扫描缓冲区。然后分析器从中逐一识别单词符号。\n分析器扫描缓冲区时一般用：起点指示器、搜索指示器。\n扫描缓冲区被一分为二：如扫描指示器从单词起点处罚搜索到半区边缘但尚未到达单词终点，就调用预处理程序吧后续的一串字符装入另一半区。\n单词符号识别：超前搜索 关键字识别 考虑：DO66K=1,10和DO66K=1.10，前者为DO语句，后者为赋值语句，需要超前扫描许多字符直到能够确定词性。\n标识符识别 大多由字母开头的”字母/数字“串。\n常数识别 有些也需要进行超前搜索。\n算符与界符 有些需要进行复合，如++合成一个单词符号，需要进行超前搜索、。\n状态转换图 一张状态转换图包含有限个状态，一个为初态，至少一个终态\n单词符号有其种别编码和内码值，但不利于记忆，故使用一些特殊符号来表示种别编码，用$开头。\n状态转换图的实现 每个状态节点对应一小段程序即可。P44-P45。\n为了方便实现需要进行几点限制（可以不用超前搜素）：\n所有的关键字都是保留字，不得将其作为自定义的标识符； 当转换图识别到一个标识符时，就进行保留字表的查询，确定当前标识符是否为关键字； 关键字、标识符、常熟之间至少需要一个空白符作为间隔。 3.3 正规表达式和有限自动机 正规式和正规集 对于字母表$\\Sigma$，存在一个正规集，同时也使用正规式来表示正规集。递归定义如下：\n$\\varepsilon$和$\\phi$都是$\\Sigma$上的正规式，对应表示的正规集为$\\{\\varepsilon\\}$和$\\phi$。 任何$a \\in \\Sigma$都是$\\Sigma$上的正规式，对应表示的正规集为$\\{a\\}$。 假设$U$和$V$都是$\\Sigma$上的正规式，表示的正规集分别为$L(U)$和$L(V)$，那么以下都是正规式：$(U|V),(U·V),(U)^*$，对应的正规集为$L(U)\\cup L(V)、L(U)L(V)、(L(V))^*$。 只有经过有限次以上步骤得到的表达式才是$\\Sigma$上的正规式，仅由这些正规式所表示的字集才是$\\Sigma$上的正规集。\n若两个正规式表示的正规集相同，则认为二者等价，等价的正规式$U$和$V$记为$U=V$。如$b(ab)^*=(ba)^*b$。\n确定有限自动机(DFA) 一个确定有限自动机（DFA）M是一个五元式$M=(S,\\Sigma,\\delta,s_0,F)$。\n其中：\n$S$是一个有限集，每一个元素是一个状态。 $\\Sigma$是一个有穷子目标，每个元素是一个输入字符。 $\\delta$是一个映射。$\\delta(s,a)=s\u0026rsquo;$表示：当前状态为$s$，输入字符为$a$时，转换到下一个状态$s\u0026rsquo;$，称为$s$的一个后继状态。 $s_0 \\in S$是唯一的初态。 $F \\subseteq S$是一个可空的终态集。 DFA可以用一个矩阵来表示，称为状态转换矩阵，也对应一张确定的状态转换图。\n对于$\\Sigma^*$中的任何字$\\alpha$，若存在一条从初态节点到某一终态节点的通路，且这条通路上的所有弧的标记符连接成的字等于$\\alpha$，则称$\\alpha$可为DFA $M$所识别（或者读出、接受）。若$M$的初态节点同时又是终态节点，则空字$\\varepsilon$可为$M$所接受。DFA $M$所能识别的字的全体记为$L(M)$。\n如果一个DFA M的输入字母表为$\\Sigma$，我们也称$M$也是$\\Sigma$上的一个DFA。$\\Sigma$上的一个字集$V \\subseteq \\Sigma^*$是正规的，当且仅当存在$\\Sigma$上的DFA M，使得$V=L(M)$ 。\n该有限自动机的确定性体现在：对于任何状态和输入符号，都有唯一确定的下一个状态。\n非确定有限自动机（NFA） 一个非确定有限自动机（NFA）M是一个五元式$M=(S,\\Sigma,\\delta,S_0,F)$。\n其中：\n$S$是一个有限集，每一个元素是一个状态。 $\\Sigma$是一个有穷子目标，每个元素是一个输入字符。 $\\delta$是一个从$S\\times \\Sigma^*$到$S$的子集的映射。即$\\delta:S\\times \\Sigma^* \\rightarrow 2^S$。同一个字母可以出现在同状态射出的多条弧上（由某个状态，可由正规式、字符、字符串、空字转移到下一个状态）。 $S_0 \\in S$是不唯一的非空初态集。 $F \\subseteq S$是一个可空的终态集。 DFA是NFA的特例。但对于每一个NFA $M$存在一个DFA $M^n$，使得$L(M)=L(M^n)$ 。（感性理解：对于NFA，一个状态可以根据一个字符或者字符串来导出到其它状态，而DFA只能通过一个字符进行状态转移，那么进行多遍的DFA可以达到使用字符串导出其它状态的效果，即与NFA相同。）\n具体证明过程如下：\n假定$NFA\\ M = \u0026lt;S,\\Sigma,\\delta,S_0,F\u0026gt;$，进行以下状态图的修改：a）引入新的初态节点$X$和终态节点$Y$，$X,Y \\notin S$，从$X$到$S_0$ 中任意状态节点连一条$\\varepsilon$，从$F$中任意状态节点连一条$\\epsilon$到$Y$。b）分裂状态图直至每条弧上都是$\\varepsilon$或者$\\Sigma$中的单个字母。最终得到的NFA记为$M\u0026rsquo;$，很显然有$L(M\u0026rsquo;)=L(M)$。 将$M\u0026rsquo;$转换为DFA。a）定义$\\varepsilon$闭包为：假定$I$为$M\u0026rsquo;$的状态集的子集，则$I$的$\\varepsilon$闭包$\\varepsilon\\_ CLOSURE(I)$为从$I$中状态出发经过任意条$\\varepsilon$弧能够到达的状态节点的全体（可以是0步）。b）在以上定义的基础上，定义$I_a$为从$I$中状态出发，经过一条$a$弧以及任意条$\\varepsilon$弧所能到达的状态节点的全体。c）假定$\\Sigma = \\{ a_1,a_2,\u0026hellip;,a_k\\}$，构造一张表满足：首行首列为$\\varepsilon\\_ CLOSURE(X)$，其中$X$为初态节点，如某一行的第一列已经确定，将其记为$I$，则对于接下来的$i+1$列，依次求$I_{ai}$，检查其在表的第一列是否已经出现，如果未出现则将其填入第一列，循环往复，由于$M\u0026rsquo;$的状态子集的个数是有限的，以上过程会在有限步骤内停止。这张表就可与刻画出一个DFA，记为$M\u0026rsquo;\u0026rsquo;$，初态为首行首列的状态，且$L(M\u0026rsquo;\u0026rsquo;)=L(M\u0026rsquo;)=L(M)$。 P50 正规文法和有限自动机的等价性 对于正规文法$G$和有限自动机$M$，如果$L(G)=L(M)$，即$G$的语言和$M$所能识别的字的全体相等，则称$G$和$M$是等价的。相关结论：\n对于每一个右线性正规文法$G$或左线性正规文法$G$，都存在一个有限自动机$M$，使得$L(M)=L(G)$。FA的构造 对于每一个有限自动机$M$，都存在一个右线性正规文法$G_R$和左线性正规文法$G_L$，使得$L(M)=L(G_R)=L(G_L)$。正规文法的构造 证明（正规文法-\u0026gt;有限自动机）：\n设存在一个右线性正规文法$G=\u0026lt;V_T,V_N,S,P\u0026gt;$，将$V_N$中的每一个非终结符视作一个状态符号，并增加一个新的终结符号$f,f\\notin V_N$。可以构造有限自动机$M=\u0026lt;V_N \\cup \\{f\\},V_T,\\delta,S,\\{f\\}\u0026gt;$，其中$\\delta$进行以下构造：（a）若对某个$A\\in V_N$且$a\\in V_T \\cup \\{\\varepsilon\\}$，有产生式$A \\rightarrow a$，则$\\delta(A,a)=f$。（b）对任意的$A\\in V_N$且$a\\in V_T \\cup \\{\\epsilon\\}$，产生式左端为$A$，右端包含$A$，即$A\\rightarrow aA_1|\u0026hellip;|aA_k$，则$\\delta(A,a)=\\{A_1,\u0026hellip;A_k\\}$。【理解：在右线性的正规文法$G$中，对于推导$S \\xRightarrow{+} w$的最左推导中，每次利用$A\\rightarrow aB$进行一次推导就相当于从$A$经过标记为$a$的弧达到$B$，最左推导情况下左边的一系列终结符不会再进行划分了，$A\\rightarrow a$则表示状态$A$经过标记$a$得到最终状态。】 设存在一个左线性正规文法$G=\u0026lt;V_T,V_N,S,P\u0026gt;$，将$V_N$中的每一个非终结符视作一个状态符号，并增加一个新的初始状态符号$q_0,q_0 \\notin V_N$。可以构造有限自动机$M=\u0026lt;V_N\\cup\\{q_0\\},V_T,\\delta,q_0,\\{S\\}\u0026gt;$，其中$\\delta$进行以下构造：（a）对某个$A\\in V_N$且$a\\in V_T \\cup \\{\\varepsilon\\}$，有产生式$A\\rightarrow a$，则$\\delta(q_0,a)=A$。（b）对任意的$A\\in V_N$且$a\\in V_T \\cup \\{\\epsilon\\}$，产生式形式为：$A_1\\rightarrow Aa,\u0026hellip;,A_k \\rightarrow Aa$，则$\\delta(A,a)={A_1,\u0026hellip;A_k}$。【理解：NFA的推导从左往右，但左线性文法需要进行最右推导？观察表达式可知每次取左推导会导致非终结符仍然存在左侧，无法进行状态的描述，将整个过程反过来，尝试将开始符号作为NFA的终止状态，并添加起始状态，将整个推导过程反过来】 证明（有限自动机-\u0026gt;正规文法）：\n假设一个非确定自动机DFA $M=\u0026lt;S,\\Sigma,\\delta,s_0,F\u0026gt;$ 。（a）若$s_0 \\notin F$，令$G_R=\u0026lt;\\Sigma,S,s_0,p\u0026gt;$，其中$p$为：对任意$a\\in \\Sigma$以及$A,B \\in S$，若有$\\delta(A,a)=B$，则令$A\\rightarrow aB$（当$B\\notin F$时），$A\\rightarrow a|aB$（若$B \\in F$）。【理解：对于任意两个状态，将其放到右线性文法的最左推导中考虑】（b）若$s_0 \\in F$，则可以确定的是：因为$\\delta(s_0,\\varepsilon)=s_0$，则$\\varepsilon$为FA $M$所能识别的字，即$\\varepsilon \\in L(M)$，但显然$\\varepsilon$不属于$G_R$的语言，即$\\varepsilon \\notin L(G_R)$，但可以发现：$L(G_R)=L(M)-\\{\\varepsilon\\}$。故考虑添加一个语言，操作为：在上述的$G_R$中添加一个非终结符$s_0\u0026rsquo;（s_0\u0026rsquo; \\notin S）$和产生式$s_0\u0026rsquo; \\rightarrow s_0|\\varepsilon$，并使用$s_0\u0026rsquo;$作为开始符号。【理解：加一个看似无用的推导过程$s_0\u0026rsquo; \\rightarrow s_0|\\varepsilon$，使其在形式上满足DFA】 概括：\n有限自动机变正规文法：字母表$\\Sigma$设为终结符$V_T$，状态集$S$设为非终结符$V_N$，初态直接对应开始符号，对于产生式$P$，则：观察所有$\\delta$的边，若指向终态，则直接由起点状态产生弧上的字符，或者由起点状态产生（弧字符+终点状态），即右线性正规文法的写法（非终结符在右）；若指向非终态，则只有起点状态产生（弧字符+终点状态）。如果在自动机中，初态也在终态集中，那么设一个新的开始符号$s_0\u0026rsquo;$，并加一个产生式$s_0\u0026rsquo;\\rightarrow s_0|\\varepsilon$。 正规文法变有限自动机：加一个终态$f$，状态集则为文法中所有非终结符加上$f$，所有终结符作为字母表，开始符号作为初态，$\\{f}$为终态集，对于状态转移图$\\delta$，则：对于每一个产生式，若右侧没有非终结符了，直接左侧指向$f$，弧上字符为产生式的右侧字符，反之指向右侧的非终结符对应的状态。 正规式和有限自动机的等价性 对任何FA $M$，都存在一个正规式$r$，使得$L(r)=L(M)$，即$r$的正规集和$M$所能识别的字的全体相等。 对任何正规式$r$，都存在一个FA $M$，使得$L(M)=L(r)$。 证明（有限自动机-\u0026gt;正规式）\n在自动机$M$的转换图上加点$X$和$Y$，$X$通过$\\varepsilon$弧连接所有初态节点，$Y$通过$\\varepsilon$连接所有终态节点，新的NFA只有一个初态和一个终态，显然与原NFA是等价的。逐步消去新NFA的节点，依照以下过程。 证明（正规式-\u0026gt;有限自动机）\n对于正规式r，如果r中没有运算符，即满足：$r=\\varepsilon$或$r=\\phi$或$r=a,a\\in \\Sigma$。显然可以直接用FA来描述，如下图。 若r中含有k个运算符，则作以下操作。 确定有限自动机DFA的化简 定义状态$s$和$t$等价：从$s$出发能读出某个字$w$而停在终态，同样$t$出发也能读出同样的字$w$而停在终态，反之亦然。\n不等价则称两个状态是可区别的。\n对于DFA的化简，即将DFA的状态集划分为一系列不相交的子集，使得任意两个子集中的状态是可区别的，同一个子集内任两个状态都是等价的。最后选每个子集中的一个代表并消去其它。\n划分步骤：\n将状态集$S$的终态和非终态分开，分成两个子集以形成基本划分$\\Pi$。 设某个时刻$\\Pi = \\{I^{(1)},I^{(2)},\u0026hellip;I^{(m)}\\}$，且不同子集的状态是可区别的（但同一子集的状态可能等价，也可能不等价）。检查每个$I^{(i)}$能否再次进行划分，对于某个$I^{(i)}=\\{q_1,q_2,\u0026hellip;q_k\\}$，若存在一个字符$a\\in \\Sigma$，使得$I_a^{(i)}$不全包含在现在$\\Pi$中的某个子集中（也就是说走一步后的状态在不同子集中，即是可区别的，显然原集合的状态也是可区别的，因为走了一步$a$后可区别，加上这一步a也是可区别的状态），则根据走一步后的集合进行$I^{(i)}$的划分。 重复上述步骤，直到不存在可划分的状态集合。 举例：P57\n"},{"section":"Blog","slug":"/en/blog/lossfunction/","title":"【泛学内容】损失函数相关","description":"this is meta description","date":"January 14, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/lossfunction/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"247\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/lossfunction\\/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/lossfunction/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/lossfunction\\/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 泛学内容","tags":"损失函数, 实验记录, 图像分割","content":"损失函数Loss Function 一、回归任务常用Loss 1. L1 Loss 原理 即为平均绝对值误差MAE，主要用于简单的回归问题，指模型预测值与真实值之间的绝对差值的平均值。\n表达式 $$ MAE=\\frac{1}{n}\\sum_{i=1}^{n}|f(x_i)-y_i| $$\n代码 criterion = nn.L1Loss() loss = criterion(target, pred) 2. MSE Loss 原理 均方误差损失函数MSE，指模型预测值与真实值之间的差的平方的平均值。\n表达式 $$ MSE=\\frac{1}{n}\\sum_{i=1}^{n}(f(x_i)-y_i)^2 $$\n代码 criterion = nn.MSELoss() loss = criterion(target, pred) 备注 reduce参数取值：\nnone：维度不缩减，返回相同shape的结果，每个位置均为对应元素差值的平方\nmean：默认值，所有位置的损失取平均\nsum：所有位置的损失求和但不取平均\n与L2Loss的关系：\n在大多数情况下是同一个概念，但严格来说L2Loss对平方和求得结果后会进一步求平方根。\n二、分类任务常用Loss 1. NLLLoss 原理 即为负对数似然函数，常用于多分类。取对应位置的数值进行相加即可，最后取负值。\n表达式 $$ Loss=-\\sum_iy_if(x_i) $$\n代码 criterion = nn.NLLLoss() loss = criterion(target, pred) 备注 这里的target可以传入索引，Pytorch实现的函数内进行了one-hot\n对于pred的内容需要进行softmax+log操作\n2. BCELoss 原理 即为二值交叉熵损失，适用于0/1的二值分类，模型输出一个概率值，即为预测为正例的概率。\n表达式 $$ BCE = -\\frac{1}{n}\\sum_i(y_i.log(f(x_i))+(1-y_i).log(1-f(x_i))) $$\n代码 criterion = nn.BCELoss() loss = criterion(target, pred) 3. CrossEntropyLoss 原理 即为交叉熵损失，适用于多分类问题\n表达式 $$ Loss=-\\sum_iy_ilog(f(x_i)) $$\n代码 criterion = nn.CrossEntropyLoss() loss = criterion(target, pred) 备注 nn.CrossEntropyLoss()结合了nn.LogSoftmax()和nn.NLLLoss()函数，前者经过softmax后取对数。\n其中target是真实标签，每个元素的值是样本所属类别的索引值\n形式上与负对数似然损失类似，但负对数似然函数是基于极大似然估计的概率方法，但交叉熵是信息论种将两个概率分布进行差异性分析的方式，本质有所差别。\n4. Dice 原理 Dice Loss由Dice系数而来，Dice系数是用来描述两个样本相似性的函数，值越大则越相似，那么对应的Loss就可以是1-Dice系数。\n表达式 $$ DiceLoss=1-\\frac{2|X \\cap Y}{|X|+|Y|} $$\n代码 class DiceLoss(nn.Module): def __init__(self): super().__init__() self.epsilon = 1e-5 def forward(self, output, target): assert output.size() == target.size() output = F.softmax(output, dim=1) output = flatten(output) target = flatten(target) intersect = (output * target).sum(-1) denominator = (output + target).sum(-1) dice = intersect / denominator dice = torch.mean(dice) return 1 - dice 5. Focal Loss 原理 Focal Loss是由交叉熵演变而来，对于一些样本分布及其不均匀的分割任务，例如血管分割，使用BCELoss容易产生初始状态下Loss就已经很小的情况。\n因此引入来控制正负样本的loss权重，例如引入一个$\\alpha_t$，当真实为正样例时，取值为$\\alpha$，反之为$1-\\alpha$，并将其架在原有的交叉熵损失上，记当为真实为正例时$p_t=p$，反之$p_t=1-p$，相当于模型输出的p为预测为正例的概率。\n因此交叉熵损失更改为$-\\alpha_tlog(p_t)$，若$\\alpha$取值较小，当遇到正例时对损失函数带来的Loss影响更大（因为有负号的存在），反之负例则Loss影响较小。\n但这并不能使得模型聚焦于hard样例的学习，引入调制因子$(1-p_t)^\\gamma$，对于正例，若模型输出的结果较小，认定其具有学习难度，结果$p_t$越小，难度越大，调制因子带来的Loss就越大。\n表达式 最终表达式如下：\n$$ Focal=\\left\\{ \\begin{aligned} -(1-\\alpha)f(x)^\\gamma log(1-f(x)), \\ y=0 \\\\ -\\alpha (1-f(x))^\\gamma log(f(x)),\\ y=1 \\end{aligned} \\right. $$\n代码 class WeightedFocalLoss(nn.Module): def __init__(self, alpha=.25, gamma=2): super(WeightedFocalLoss, self).__init__() self.gamma = gamma self.alpha = alpha def forward(self, inputs, targets): BCE_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction=\u0026#39;none\u0026#39;) pt = torch.exp(-BCE_loss) F_loss = self.alpha * (1 - pt) ** self.gamma * BCE_loss return F_loss.mean() 备注 对于$\\alpha$和$\\gamma$的取值，通常为0.25和2。\n实验效果不佳？对于非小比例正例的训练情况\n三、其它Loss 1. KL散度 原理 信息熵的定义：\n一个事件信息量的期望，形式上：设事件$X$有$n$种可能，发生$x_i$的概率为$p(x_i)$，则该事件的熵$H(X)$则为： $$ H(x)=-\\sum_{i=1}^{n}p(x_i)log(p(x_i)) $$ 相对熵的定义：\n对于同一个随机变量$x$有两个单独的概率分布$P(x)$和$Q(x)$，使用KL散度描述差异，其中$P$往往是真实分布，$Q$为模型所预测的分布。\n表达式 $$ D_{KL}(p||q)=\\sum_{i=1}^{n}[p(x_i)log(p(x_i))-p(x_i)log(q(x_i))]=\\sum_{i=1}^{n}p(x_i)log(\\frac{p(x_i)}{q(x_i)}) $$\n备注 KL散度可以理解为从A角度来看，B事件和A事件的差异性。\n2. Hinge损失 原理 常用于SVM中，二分类问题，对于标签值$y \\in { 1,-1 }$，预测值$\\hat{y} \\in R$，当预测值在$(-1,1)$之外时，分类结果确定，反之分类结果不确定，loss不为0，当预测值为0时，显然loss是最大的。Loss向零线性增长。\n表达式 $$ Hinge=max(0,1-yf(x)) $$\n"},{"section":"Blog","slug":"/en/blog/diffusion/","title":"【学习笔记】扩散模型的基本原理与训练方法","description":"this is meta description","date":"December 14, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/diffusion/process_hucaeaf4e39aab7718665e67c263b83e8d_100488_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"77\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/diffusion\\/process_hucaeaf4e39aab7718665e67c263b83e8d_100488_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/diffusion/process_hucaeaf4e39aab7718665e67c263b83e8d_100488_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/diffusion\\/process_hucaeaf4e39aab7718665e67c263b83e8d_100488_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 学习笔记","tags":"扩散模型, 图像生成","content":"1. Diffusion前向过程 给定采样自数据集的真实图片$x_0 \\sim q(x)$，并对其添加高斯噪声，共进行$T$步，称该过程为$q$过程，能够得到添加噪声后的图片分布$x_1,x_2,\u0026hellip;,x_T$。\n将加噪的过程看作一个马尔可夫过程，即$t$时刻的状态只与$t-1$时刻有关，设置超参数$\\beta_t \\in (0,1), t\\in(1,T)$ ，本质上该超参数即为每一时刻下添加的高斯分布的方差。至此可以将该前向$q$过程写成以下形式，表示在$x_{t-1}$满足的分布前提下，$x_{t}$的方差为$\\beta_t$，均值则受到了前一个状态的影响。 $$ q(x_t|x_{t-1})=\\mathcal N(x_t;\\sqrt{1-\\beta_t}x_{t-1},\\beta_t \\mathbf{I}) $$ 实际场景中，$\\beta$是随着$t$的增大而递增的，那么当$t$很大时，$\\beta_t$ 趋近于1，则$x_t$满足的分布接近于标准正态分布。【$\\beta_t$这一超参数的存在本质是描述方差，但却在均值上乘上了$\\sqrt{1-\\beta_t}$，这能够使得均值在$t$很大的时候趋向于0，整个分布则为标准正态分布。】\n由于以上过程看作一个马尔可夫过程，因此根据乘法公式可以写出以下表达式： $$ q(x_{1:T}|x_0)=\\prod_{t=1}^{T}q(x_t|x_{t-1}) $$\n重参数技巧（reparameterization trick） 以上前向的$q$过程的表达形式是采样形式的，表示在某个分布中进行随机采样，这回导致过程有随机性，无法反向传播梯度，为了使该采样过程变得可导，使用冲参数技巧，引入一个固定的随机变量$\\epsilon$实现。\n例如需要进行以下采样：$z \\sim \\mathcal N (z;\\mu_\\theta,\\sigma_{\\theta}^{2}\\mathbf{I})$，可以写成：$z=\\mu_{\\theta}+\\sigma_{\\theta}\\odot\\epsilon$，这样的话$z$依旧是一个随机变量，但对于$\\mu_{\\theta}$和$\\sigma_{\\theta}$等含有网络参数的参数，能够通过$z$进行梯度的求取，随机性完全来自于固定不变服从标注正态分布的$\\epsilon $中了。\n那么对于原先的$q$过程，可以使用重参数技巧重写$x_t$，即： $$ x_t=\\sqrt{1-\\beta_t}x_{t-1}+\\sqrt{\\beta_t}z，z \\sim \\mathcal N (0,\\mathbf{I}) $$\n使用统一的方法表示$x_t$ 由于上述扩散过程是一步步进行的，为了能够快速得到$x_t$，考虑使用$x_0$和$\\beta$进行统一表示。\n首先假设$\\alpha_t=1-\\beta_t$，并记$\\overline{\\alpha_t}=\\prod_{i=1}^{T}\\alpha_i$。\n则对$x_t$有以下推导过程：\n$$ \\begin{aligned} %aligned命令对齐，在对齐的地方用\u0026quot;\u0026amp;\u0026quot; x_t \u0026amp;=\\sqrt{\\alpha_t}x_{t-1}+\\sqrt{1-\\alpha_t}z_1 \\\\ \u0026amp;=\\sqrt{\\alpha_t}(\\sqrt{\\alpha_{t-1}}x_{t-2}+\\sqrt{1-\\alpha_{t-1}}z_2)+\\sqrt{1-\\alpha_t}z_1 \\\\ \u0026amp;=\\sqrt{\\alpha_t \\alpha_{t-1}}x_{t-2}+\\sqrt{\\alpha_t(1-\\alpha_{t-1})}z_2+\\sqrt{1-\\alpha_t}z_1 \\\\ \u0026amp;=\\sqrt{\\alpha_t \\alpha_{t-1}}x_{t-2}+\\sqrt{1-\\alpha_t \\alpha_{t-1}}\\overline{z_2} \\\\ \u0026amp; \u0026hellip; \\\\ \u0026amp;=\\sqrt{\\overline{\\alpha_t}}x_0+\\sqrt{1-\\overline{\\alpha_t}}\\ \\overline{z_t} \\end{aligned} $$\n其中对于$\\sqrt{\\alpha_t(1-\\alpha_{t-1})}z_2+\\sqrt{1-\\alpha_t}z_1=\\sqrt{1-\\alpha_t \\alpha_{t-1}}\\overline{z_2}$的推导过程，有以下分析：\n$$ \\sqrt{\\alpha_t(1-\\alpha_{t-1})}z_2 \\sim \\mathcal N(0,\\alpha_t(1-\\alpha_{t-1})\\mathbf{I}) \\\\ \\sqrt{1-\\alpha_t}z_1 \\sim \\mathcal N (0,(1-\\alpha_t)\\mathbf{I}) \\\\ \\sqrt{\\alpha_t(1-\\alpha_{t-1})}z_2+\\sqrt{1-\\alpha_t}z_1 \\sim \\mathcal N(0,(1-\\alpha_t \\alpha_{t-1})\\mathbf{I}) \\\\ $$\n对于得到的混合高斯分布$\\mathcal N(0,(1-\\alpha_t \\alpha_{t-1})\\mathbf{I})$，可以表达为$\\sqrt{1-\\alpha_t \\alpha_{t-1}}\\overline{z_2}$，对于$\\overline{z_2}$依然服从的是标准高斯分布。\n综上，对于$x_t$的表达式形式为$x_t=\\sqrt{\\overline{\\alpha_t}}x_0+\\sqrt{1-\\overline{\\alpha_t}}z$，采样形式为$q(x_t|x_0) \\sim \\mathcal N(x_t;\\sqrt{\\overline{\\alpha_t}}x_0,(1-\\overline{\\alpha_t})\\mathbf{I})$。可以看成原始图片与高斯噪声的加权求和结果。\n2. Diffusion逆向推断 该过程可以看成前向$q$过程的逆过程，即去噪过程。目前在这里我们已知所有的前向过程$q(x_t|x_{t-1})$，想要从标准正态分布中逐步去噪得到最终的原图分布，即从$x_T$得到$x_0$，那么就需要知道$q(x_{t-1}|x_t)$。但这是十分困难的，因此考虑使用深度神经网络来对该分布进行预测，即训练一个模型使其能够做到$p_{\\theta}(x_{t-1}|x_t)$。【即让神经网络去学习去噪的过程】\n对于$p_{\\theta}(x_{t-1}|x_{t})$，写成正态分布的表达形式，即为下式，可以看到我们需要使网络根据$x_t$和$t$学习得到分布的均值与方差。\n$$ p_{\\theta}(x_{t-1}|x_t)=\\mathcal N (x_{t-1};\\mu_{\\theta}(x_t,t),\\Sigma_{\\theta}(x_t,t)) $$\n虽然$q(x_{t-1}|x_t)$难以直接得到，但是可以引入已知的原图像分布$x_0$的先验知识，尝试得到$q(x_{t-1}|x_t,x_0)$，可以进行以下过程推导：\n$$ \\begin{aligned} q(x_{t-1}|x_t,x_0)\u0026amp;=\\frac{q(x_{t-1},x_{t},x_{0})}{q(x_t,x_0)} \\\\ \u0026amp;=\\frac{q(x_{t-1},x_t,x_0)}{q(x_{t-1},x_0)}\\frac{q(x_{t-1},x_0)}{q(x_t,x_0)} \\\\ \u0026amp;=q(x_t|x_{t-1},x_0)\\frac{\\frac{q(x_{t-1},x_0)}{q_{x_0}}}{\\frac{q(x_t,x_0)}{q_{x_0}}}\\\\ \u0026amp;=q(x_t|x_{t-1},x_0)\\frac{q(x_{t-1}|x_0)}{q(x_t|x_0)} \\end{aligned} $$\n由此将加入先验知识的逆向分布转换为正向分布的表达式。\n对于几个前向过程进行表达式说明：\n$$ q(x_{t-1}|x_0)=\\sqrt{\\overline{\\alpha_{t-1}}}x_0+\\sqrt{1-\\overline{\\alpha_{t-1}}}z \\sim \\mathcal N (\\sqrt{\\overline{\\alpha_{t-1}}}x_0,1-\\overline{\\alpha_{t-1}}) \\\\ q(x_{t}|x_0)=\\sqrt{\\overline{\\alpha_{t}}}x_0+\\sqrt{1-\\overline{\\alpha_{t}}}z \\sim \\mathcal N (\\sqrt{\\overline{\\alpha_{t}}}x_0,1-\\overline{\\alpha_{t}}) $$\n由于$q$过程是马尔可夫过程，则有：\n$$ q(x_t|x_{t-1},x_0)=q(x_t|x_{t-1})=\\sqrt{\\alpha_{t}}x_{t-1}+\\sqrt{1-\\alpha_{t}}z \\sim \\mathcal N (\\sqrt{\\alpha_{t}}x_{t-1},1-\\alpha_{t}) $$\n而对于高斯分布，我们能够使用概率密度函数的形式进行表达，即：$\\mathcal N(\\mu,\\sigma^2)\\propto exp(-\\frac{(x-\\mu)^2}{2\\sigma^2})$，则考虑使用概率密度函数描述$q(x_{t-1}|x_0)、q(x_t|x_0)、q(x_t|x_{t-1},x_0)$，如下表达式所示：\n$$ q(x_{t-1}|x_0)\\propto exp(-\\frac{(x_{t-1}-\\sqrt{\\overline{\\alpha_{t-1}}}x_0)^2}{2(1-\\overline{\\alpha_{t-1}})}) \\\\ q(x_{t}|x_0)\\propto exp(-\\frac{(x_{t}-\\sqrt{\\overline{\\alpha_{t}}}x_0)^2}{2(1-\\overline{\\alpha_{t}})}) \\\\ q(x_t|x_{t-1},x_0)\\propto exp(-\\frac{(x_{t}-\\sqrt{\\alpha_{t}}x_{t-1})^2}{2(1-\\alpha_{t})}) $$\n则最终可以表达$q(x_{t-1}|x_t,x_0)$，如下推导所示。由于$q(x_{t-1}|x_t,x_0)$是关于$x_{t-1}$的表达式，则需要进行同类相合并\n$$ \\begin{aligned} q(x_{t-1}|x_t,x_0) \u0026amp;=q(x_t|x_{t-1},x_0)\\frac{q(x_{t-1}|x_0)}{q(x_t|x_0)} \\\\ \u0026amp;\\propto exp(-\\frac{(x_{t-1}-\\sqrt{\\overline{\\alpha_{t-1}}}x_0)^2}{2(1-\\overline{\\alpha_{t-1}})}) + exp(-\\frac{(x_{t}-\\sqrt{\\alpha_{t}}x_{t-1})^2}{2(1-\\alpha_{t})}) - exp(-\\frac{(x_{t}-\\sqrt{\\overline{\\alpha_{t}}}x_0)^2}{2(1-\\overline{\\alpha_{t}})}) \\\\ \u0026amp;=exp(-\\frac{1}{2}(\\frac{(x_{t-1}-\\sqrt{\\overline{\\alpha_{t-1}}}x_0)^2}{1-\\overline{\\alpha_{t-1}}}+\\frac{(x_{t}-\\sqrt{\\alpha_{t}}x_{t-1})^2}{1-\\alpha_{t}}-\\frac{(x_{t}-\\sqrt{\\overline{\\alpha_{t}}}x_0)^2}{1-\\overline{\\alpha_{t}}})) \\\\ \u0026amp;=exp(-\\frac{1}{2}((\\frac{\\alpha_t}{1-\\alpha_t}+\\frac{1}{1-\\overline{\\alpha_{t-1}}})x_{t-1}^2-(\\frac{2\\sqrt{\\alpha_t}}{1-\\alpha_t}x_t+\\frac{2\\sqrt{\\overline{\\alpha_{t-1}}}}{1-\\overline{\\alpha_{t-1}}}x_0)x_{t-1}+C(x_t,x_0))) \\end{aligned} $$\n其中$C(x_t,x_0)$不含$x_{t-1}$。\n考虑到对于概率密度的表达式，可以进行展开操作，即$\\mathcal N(\\mu,\\sigma^2)\\propto exp(-\\frac{(x-\\mu)^2}{2\\sigma^2})=exp(-\\frac{1}{2}(\\frac{1}{\\sigma^2}x^2-\\frac{2\\mu}{\\sigma^2}x+\\frac{\\mu^2}{\\sigma^2}))$，与$q(x_{t-1}|x_t,x_0)$的表达式一一对应可知。\n$$ \\frac{1}{\\sigma^2}=\\frac{\\alpha_t}{1-\\alpha_t}+\\frac{1}{1-\\overline{\\alpha_{t-1}}} \\\\ \\sigma^2 =\\frac{(1-\\alpha_t)(1-\\overline{\\alpha_{t-1}})}{\\alpha_t(1-\\overline{\\alpha_{t-1}})+(1-\\alpha_t)}=\\frac{\\beta_t(1-\\overline{\\alpha_{t-1}})}{\\alpha_t(1-\\overline{\\alpha_{t-1}})+\\beta_t} \\\\ =\\frac{1-\\overline{\\alpha_{t-1}}}{1-\\overline{\\alpha_t}}\\beta_t $$\n对于均值，有求得表达式：\n$$ \\frac{2\\mu}{\\sigma^2}=\\frac{2\\sqrt{\\alpha_t}}{1-\\alpha_t}x_t+\\frac{2\\sqrt{\\overline{\\alpha_{t-1}}}}{-\\overline{\\alpha_{t-1}}}x_0 \\\\ \\mu=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}x_0 $$\n至此，我们在加入$x_0$的先验知识后，能够描述出分布$q(x_{t-1}|x_t,x_0)$的均值和方差的表达式，即\n$$ \\mu=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}x_0 \\\\ \\sigma^2=\\frac{1-\\overline{\\alpha_{t-1}}}{1-\\overline{\\alpha_t}}\\beta_t $$\n但实际上我们需要通过神经网络来训练出一个分布$p_{\\theta}(x_{t-1}|x_t)$，该分布的均值和方差均是含参数的，即上述的$\\mu_{\\theta}(x_t,t)$与$\\Sigma_{\\theta}(x_t,t)$。我们考虑使用$q(x_{t-1}|x_t,x_0)$来近似估计$p_{\\theta}(x_{t-1}|x_t)$，这显然是可行的，因为$x_t$可以由$x_0$来表示，同理也可以使用$x_t$来表示$x_0$。综上可得以下关于均值和方差的表达式：\n$$ \\mu_{\\theta}(x_t,t)=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}x_0 \\\\ \\Sigma_{\\theta}(x_t,t)=\\frac{1-\\overline{\\alpha_{t-1}}}{1-\\overline{\\alpha_t}}\\beta_t $$\n对于其中出现的先验知识$x_0$，考虑使用$x_t$来表达，即有： $$ x_0=\\frac{x_t-\\sqrt{1-\\overline{\\alpha_t}}z}{\\sqrt{\\overline{\\alpha_t}}} $$ 代入均值$\\mu_{\\theta}(x_t,t)$的表达式，有以下推导过程：\n$$ \\begin{aligned} \\mu_{\\theta}(x_t,t)\u0026amp;=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}x_0 \\\\ \u0026amp;=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}\\frac{x_t-\\sqrt{1-\\overline{\\alpha_t}}z}{\\sqrt{\\overline{\\alpha_t}}} \\\\ \u0026amp;=\\frac{1}{\\sqrt{\\alpha_t}}(x_t-\\frac{1-\\alpha_t}{\\sqrt{1-\\overline{\\alpha_t}}}z) \\end{aligned} $$\n观察表达式可以发现，$\\alpha_t$、$x_t$、$\\overline{\\alpha_t}$均为已知量，模型需要确定$\\mu_{\\theta}(x_t,t)$，本质上是个噪声预测的过程，即对于上式中的$z$，需要交给神经网络去预测，记为$z_{\\theta}(x_t,t)$。\n综上，反向去噪过程可以概括为：\n根据$x_t$和$t$预测高斯噪声$z_{\\theta}(x_t,t)$，则能够得到模型预测的去噪后的分布均值$\\mu_{\\theta}(x_t,t)$，其实就是去噪后的图像。 得到方差$\\Sigma_{\\theta}(x_t,t)$，在DDPM中方差是untrained的，即$\\Sigma_{\\theta}(x_t,t)=\\frac{1-\\overline{\\alpha_{t-1}}}{1-\\overline{\\alpha_t}}\\beta_t$，但对于方差也可以进行训练估计。 $p_{\\theta}(x_{t-1}|x_t)=\\mathcal N (x_{t-1};\\mu_{\\theta}(x_t,t),\\Sigma_{\\theta}(x_t,t))$进行去噪，获得$x_{t-1}$，通过重参数技巧。 3. 训练方式与策略 常规的训练流程 从数据集中采样得到$x_0$，$x_0 \\sim q(x)$，并在$1\u0026hellip;T$中随机采样一个 $t$。 从标准高斯分布中采样一个噪声$z\\sim \\mathcal N (0,\\mathbf{I})$。 根据重参数技巧得到$x_t=\\sqrt{\\overline{\\alpha_t}}x_0+\\sqrt{1-\\overline{\\alpha_t}}z$。 训练UNet，输入$x_t$和$t$，模型输出$z_{\\theta}(x_t,t)$，将$z_{\\theta}(x_t,t)$和$z$做Loss。 推理流程 从标准高斯分布中采样得到一个噪声$x_t \\sim \\mathcal N(0,\\mathbf{I})$。 从$T$到1遍历变量$t$，如果$t==1$则$z=0$，否则采样噪声$z\\sim\\mathcal N(0,\\mathbf{I})$。 UNet推理得到$z_\\theta(x_t,t)$，进行去噪$x_{t-1}=\\frac{1}{\\sqrt{\\overline{\\alpha_t}}}(x_t-\\frac{1-\\alpha_t}{\\sqrt{1-\\overline{\\alpha_t}}}z_{\\theta}(x_t,t))+\\Sigma_{\\theta}(x_t,t)z$。 得到$x_0$。 4. Diffusion的应用拓展 Diffusion做分割（SegDiff） 要点：将待分割图像作为condition image进行特征的提取，在进入UNet之前进行特征的融合，扩散生成的为mask。\n训练$\\mu_{\\theta}(x_t,t)$时，需要加入图像的特征，即$\\mu_{\\theta}(x_t,t,I)$，推理时同理。\n"},{"section":"Blog","slug":"/en/blog/lagrange-multipiler/","title":"【泛学内容】拉格朗日乘子法求解带约束的优化问题","description":"this is meta description","date":"December 2, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/Lagrange/image-1_huf60a259aeee080a9aa1a0bc3eb400074_34139_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"437\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/Lagrange\\/image-1_huf60a259aeee080a9aa1a0bc3eb400074_34139_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/Lagrange/image-1_huf60a259aeee080a9aa1a0bc3eb400074_34139_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/Lagrange\\/image-1_huf60a259aeee080a9aa1a0bc3eb400074_34139_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"数学相关, 泛学内容","tags":"高等数学, 最优化问题, 拉格朗日乘子法","content":"拉格朗日乘子法 用于求解约束条件下的极值问题，是SVM的理论基础。\n一、简单例子引入 求解以下优化问题： $$ \\begin{aligned} \u0026amp;min \\ f(x_1,x_2)=x_1^2+x_2^2 \\\\ \u0026amp;st.\\ x_1+x_2 = 2 \\end{aligned} $$ 使用函数$g(x_1,x_2)=x_1+x_2-2$来描述约束条件，则$g(x_1,x_2)=0$。\n引入拉格朗日乘子$\\lambda$，构造一个新函数$h(x_1,x_2)=f(x_1,x_2)+\\lambda g(x_1,x_2)$。很显然$h(x_1,x_2)=f(x_1,x_2)$，因此要求$f(x_1,x_2)$的最小值，即求$h(x_1,x_2)$的最小值，则令梯度为0，表达式如下： $$ \\frac{\\partial h(x_1,x_2)}{\\partial x_1}=\\frac{\\partial f(x_1,x_2)}{\\partial x_1}+\\lambda \\frac{\\partial g(x_1,x_2)}{\\partial x_1}=2x_1+\\lambda=0 \\\\ \\frac{\\partial h(x_1,x_2)}{\\partial x_2}=\\frac{\\partial f(x_1,x_2)}{\\partial x_2}+\\lambda \\frac{\\partial g(x_1,x_2)}{\\partial x_2}=2x_2+\\lambda=0 \\\\ \\tag{1} $$ 则有以下等式组: $$ 2x_1+\\lambda =0 \\\\ 2x_2+\\lambda =0 \\\\ x_1+x_2-2=0 \\tag{2} $$ 求解得到结果为$\\lambda=-2，x_1=x_2=1$，则表示$f(x_1,x_2)$在$x_1=x_2=1$时取得最小值，值为2。\n二、几何简介 对于约束函数$g(x_1,x_2)=0$，即可以看作一条直线，最终$x_1,x_2$的取值要满足在这条直线上。对于$f(x_1,x_2)$，其取任意值都有一个圆与之对应（类似于等高线），例如下图中红线代表$f(x_1,x_2)=1$的所有$x_1$和$x_2$的取值点。\n因此在约束条件下$f(x_1,x_2)$若能够取到某个值$d$，则对应的$x_1,x_2$则为圆$f(x_1,x_2)=d$与$g(x_1,x_2)=0$的交点。\n显而易见的是：当圆$f(x_1,x_2)=d$与$g(x_1,x_2)=0$相切时，此时$d$ 为能取到的最小值，同时交点即为对应的自变量值。此时两个函数的梯度方向相同，但是值不一定相当，是成比例的。\n对于$f(x_1,x_2)$在该点的梯度，即为$(\\frac{\\partial f(x_1,x_2)}{\\partial x_1},\\frac{\\partial f(x_1,x_2)}{\\partial x_2})$，对于$g(x_1,x_2)$在该点的梯度，即为$(\\frac{\\partial g(x_1,x_2)}{\\partial x_1},\\frac{\\partial g(x_1,x_2)}{\\partial x_2})$。\n这里引入了乘子$\\lambda$，是一个比例系数，则有（3）式子，该式子显然与（1）一致。 $$ \\frac{\\partial f(x_1,x_2)}{\\partial x_1}=\\lambda \\frac{\\partial g(x_1,x_2)}{\\partial x_1} \\\\ \\frac{\\partial f(x_1,x_2)}{\\partial x_2}=\\lambda \\frac{\\partial g(x_1,x_2)}{\\partial x_2} \\\\ \\tag{3} $$\n三、带等式约束的最优化问题 有多个等式约束的多元函数优化问题，表达如下\n$$ min \\ f(x_1,x_2,\u0026hellip;,x_n) \\\\ s.t. \\left\\{ \\begin{aligned} \u0026amp;g_1(x_1,x_2,\u0026hellip;,x_n) = 0 \\\\ \u0026amp;g_2(x_1,x_2,\u0026hellip;,x_n) = 0 \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;g_m(x_1,x_2,\u0026hellip;,x_n) = 0 \\end{aligned} \\right. \\tag{4} $$\n则令$L(x_1,x_2,\u0026hellip;,x_n;\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n)=f+\\lambda_1 g_1 + \\lambda_2 g_2+\u0026hellip;+\\lambda_n g_n=f+\\sum_{i=1}^{m} \\lambda_i g_i \\ (\\lambda_i\\in \\mathbf{R})$。\n最小化$L$，得到最优解$x^*=(x_1^*,x_2^*,\u0026hellip;,x_n^*)^T$的必要条件(KKT)如下。共$m$个约束加上$n$个梯度分量为0带来的方程。\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla_xL=\\nabla_xf+\\sum_{i=1}^{m}\\lambda_i \\nabla_x g_i = 0 \\\\ \u0026amp;g_i=0 \\end{aligned} \\right. \\tag{5} $$\n三、带不等式约束的最优化问题 约束变成不等式实际上相当于可行域从一条直线变成了一个区域，记为$g(x)\u0026lt;0$，可以分两种情况进行讨论。\n最优点处于约束区域边界 这种情况相当于$g$所对应的区域没有覆盖住$f$的梯度最低点，那么只能退而求其次在$g$的边界处取得最优点。\n这时候$g$和$f$的梯度方向是必然相反的，那么就存在一个缩放因子$\\lambda\u0026gt;0$，使得$\\nabla f+\\lambda \\nabla g=0$，因此最优解条件可以写成以下形式（以二维为例）：\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla L(x_1,x_2,\\lambda)=\\nabla f(x_1,x_2)+\\lambda \\nabla g(x_1,x_2) = 0 \\\\ \u0026amp;\\lambda \u0026gt;0 \\\\ \u0026amp;g(x_1,x_2)=0 \\end{aligned} \\right. \\tag{6} $$\n最优点处于约束区域内部 这种情况相当于$g$所对应的区域完全覆盖住$f$的梯度最低点，最优点显然处于$f$的梯度最低点，相当于$g$没有起任何约束，只需要依靠$\\nabla f = 0$求得最优点。\n为了统一形式可以写成以下条件组。\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla L(x_1,x_2,\\lambda)=\\nabla f(x_1,x_2)+\\lambda \\nabla g(x_1,x_2) = 0 \\\\ \u0026amp;\\lambda =0 \\\\ \u0026amp;g(x_1,x_2)\u0026lt;0 \\end{aligned} \\right. \\tag{7} $$\n合并上述情况 最终的式子都可以写成$\\nabla f(x_1,x_2)+\\lambda \\nabla g(x_1,x_2) = 0$，$\\lambda\\ge0$。\n考虑到：当最优点在$g$的边界上时，$g=0,\\lambda\u0026gt;0$，当最优点在$g$内部时，$g\u0026lt;0,\\lambda=0$，则有$\\lambda g =0$，称为互补松弛条件。\n综上合并情况后可以把在不等式约束下的最优解的必要条件写为：\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla L(x_1,x_2,\\lambda)=\\nabla f(x_1,x_2)+\\lambda \\nabla g(x_1,x_2) = 0 \\\\ \u0026amp;\\lambda \\ge0 \\\\ \u0026amp;\\lambda g(x_1,x_2)=0 \\\\ \u0026amp;g(x_1,x_2)\\le 0 \\end{aligned} \\right. \\tag{8} $$\n推广到多个不等式约束的多元函数优化问题，表达如下\n$$ min \\ f(x_1,x_2,\u0026hellip;,x_n) \\\\ s.t. \\left\\{ \\begin{aligned} \u0026amp;g_1(x_1,x_2,\u0026hellip;,x_n) \\le 0 \\\\ \u0026amp;g_2(x_1,x_2,\u0026hellip;,x_n) \\le 0 \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;g_m(x_1,x_2,\u0026hellip;,x_n) \\le 0 \\end{aligned} \\right. \\tag{9} $$\n则令$L(x_1,x_2,\u0026hellip;,x_n;\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n)=f+\\lambda_1 g_1 + \\lambda_2 g_2+\u0026hellip;+\\lambda_n g_n=f+\\sum_{i=1}^{m} \\lambda_i g_i \\ (\\lambda_i\\in \\mathbf{R})$。\n最小化$L$，得到最优解$x^*=(x_1^*,x_2^*,\u0026hellip;,x_n^*)^T$的必要条件（KKT）如下。共$m$个约束、$n$个梯度分量为0带来的方程、m个互补松弛条件。\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla_xL=\\nabla_xf+\\sum_{i=1}^{m}\\lambda_i \\nabla_x g_i = 0 \\\\ \u0026amp;\\lambda_i \\ge 0\\\\ \u0026amp;\\lambda_i g_i =0 \\\\ \u0026amp;g_i\\le0 \\end{aligned} \\right. \\tag{10} $$\n四、混合情形 为简化表示，使用$\\mathbf{x}=(x_1,x_2,\u0026hellip;x_n)^T$。\n$$ min \\ f(\\mathbf{x}) \\\\ s.t. \\left\\{ \\begin{aligned} \u0026amp;g_1(\\mathbf{x}) = 0 \\\\ \u0026amp;g_2(\\mathbf{x}) = 0 \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;g_k(\\mathbf{x}) = 0 \\\\ \u0026amp;h_1(\\mathbf{x}) \\le 0 \\\\ \u0026amp;h_2(\\mathbf{x}) \\le 0 \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;h_l(\\mathbf{x}) \\le 0 \\end{aligned} \\right. \\tag{11} $$\n则令$L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})=f(\\mathbf{x})+\\sum_{i=1}^{k} \\lambda_i g_i(\\mathbf{x}) +\\sum_{i=1}^{l} \\mu_i h_i(\\mathbf{x})$。\n其中$\\mathbf{\\lambda}=(\\lambda_1,\\lambda_2,\u0026hellip;\\lambda_k)$，$\\mathbf{\\mu}=(\\mu_1,\\mu_2,\u0026hellip;\\mu_l)$，前者为等式约束的拉格朗日乘子，后者为不等式约束的拉格朗日乘子。\n最小化$L$，得到最优解$x^*=(x_1^*,x_2^*,\u0026hellip;,x_n^*)^T$的必要条件如下。\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla_xL(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})=\\nabla_xf(\\mathbf{x})+\\sum_{i=1}^{k}\\lambda_i \\nabla_x g_i(\\mathbf{x})+\\sum_{i=1}^{l}\\mu_i \\nabla_x h_i(\\mathbf{x}) = 0 \\\\ \u0026amp;g_i(\\mathbf{x})=0 \\ (i=1,2,\u0026hellip;k)\\\\ \u0026amp;h_i(\\mathbf{x}) \\le 0 \\ (i=1,2,\u0026hellip;l) \\\\ \u0026amp;\\lambda_i \\in \\mathbf{R} \\ (i=1,2,\u0026hellip;k)\\\\ \u0026amp;\\mu_i \\ge 0 \\ (i=1,2,\u0026hellip;l)\\\\ \u0026amp;\\mu_i h_i(\\mathbf{x}) =0 \\ (i=1,2,\u0026hellip;l) \\end{aligned} \\right. \\tag{12} $$\n五、原最优化问题转对偶问题 在满足KKT条件的情况下，原函数$f(\\mathbf{x})$可以与$max \\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})$等价（这里$\\lambda$和$\\mu$为自变量）。则目标原来的目标函数$min\\ f(\\mathbf{x})$就等价为$\\mathop{min}\\limits_{x} \\ \\mathop{max}\\limits_{\\lambda,\\mu} \\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})$。其对偶表达式为$ \\mathop{max}\\limits_{\\lambda,\\mu} \\ \\mathop{min}\\limits_{x}\\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})$，由于满足KKT条件，其最优值等于原问题的最优值。\n即若在取得最优解$x^*$的情况下，满足以下表达式： $$ f(x^*)=\\mathop{min}\\limits_{x} \\ \\mathop{max}\\limits_{\\lambda,\\mu} \\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu}) = \\mathop{max}\\limits_{\\lambda,\\mu} \\ \\mathop{min}\\limits_{x}\\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu}) $$\n参考资料 拉格朗日乘子法详解-CSDN博客 形象理解拉格朗日乘子法 - 知乎 (zhihu.com) 《统计学习方法》-李航\n"},{"section":"Blog","slug":"/en/blog/opticalflow/","title":"【学习笔记】Optical Flow的基本原理与常见光流估计方法","description":"this is meta description","date":"November 12, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"219\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 学习笔记","tags":"光流估计, 金字塔特征, GRU迭代更新","content":"CSDN：【学习笔记】光流(Optical Flow)的基本知识与光流估计方法 1. 简介 1.1 光流(Optical Flow)的基本概念 光流（Optical Flow）是指描述在图像序列中物体表面上的像素移动的模式。在计算机视觉和图像处理领域，光流是一种用于估计相邻帧之间像素之间位移的技术。简而言之，光流是描述相邻图像帧之间像素运动的模式，它通过跟踪图像中的特征点或像素来估计运动的速度和方向。 或者说是在像素级别上的位移描述，即每一个像素点从第一帧到第二帧的具体偏移量。\n1.2 补充说明 光流法的基本假设：（1）亮度恒定不变，即同一目标在不同帧间的运动时亮度不会发生改变；（2）相邻帧之间的位移要比较小，即时间上不会引起目标的剧烈位置变化。\n基于假设的形式化表达：形式化表达即如下，其中I代表具体的像素值（光强度），t为具体的时刻，Δt一般即为相邻帧的时间，(u,v)则为像素的具体偏移量，可以理解成前一帧图像中的(i,j)像素在Δt的时间间隔下（下一帧），移动了(u,v)。\n$$ I(i,j,t) = I(i+u,j+v,t+\\Delta t) $$\n光流的方向：图像帧A→B，则flow的方向为B-\u0026gt;A。（不确定，查阅了各种资料后得到的解释，但这部分方向上的定义不影响实际的分析与代码编写）\n光流的warp：若存在两帧frame1和frame2，不考虑batch的情况下，其shape均为[3,H,W]，对应的flow的shape为[2,H,W]，两个通道分别表示水平、竖直方向上的位移，该flow满足以下关系式子。 $$ frame1[:,i,j] = frame2[:,i+u,j+v] \\ u=flow[0,i,j],v=flow[1,i,j] $$ 那么在已知frame1和flow的情况下，可以通过依次查询flow并将像素进行偏移得到frame2，该过程则为warp。在大多数代码场景下，还会涉及到backwarp操作（有些文章不严格区分warp和backwarp），即在已知frame2和flow的情况下，得到frame1，一部分原因还包括backwarp的操作可以通过torch.nn.functional.grid_sample采样函数实现（见后文），这样的话，我们可以在已知frame2到frame1的flow以及frame1的前提下轻松地求得frame2。（Tips：部分文章提及使用frame1到frame2的-flow求frame2，使用的还是基于grid_sample函数的backwarp方法，个人认为并不正确，因为frame2的像素点和具体在frame1的采样点的映射关系需要通过flow得以确定，画个图就可以说明。）\n1.3 常见应用 视频压缩、视频插帧、物体运动分析（车流方向）、特征计算的优化、视频稳像、视觉效果等。\n2. 一些常用操作 2.1 光流文件读取 flow的常见存储文件格式为.flo，网络上已有现成且广泛使用的flo文件读取代码，如下。通过分析代码可以知道该文件大致的存储结构，包括标识符、高宽数据、具体位移数据。通过open函数进行二进制形式打开即可，使用numpy中的fromfile函数进行依次读取。\n# 读取flow文件，返回对应的numpy数组 def load_flow(path): with open(path,\u0026#39;rb\u0026#39;) as fl: flag = np.fromfile(fl,np.float32,count=1) # 先读取第一个数据 assert (202021.25 == flag) # 使用assert语句判定flo文件的合法性 width = np.fromfile(fl, np.int32, count=1)[0] # 读取宽、高信息 height = np.fromfile(fl, np.int32, count=1)[0] data = np.fromfile(fl, np.float32, count=2 * width * height) # 读取剩余的位移数据 return np.resize(data, (height, width, 2)) 2.2 光流可视化 将运动信息进行具体的可视化。其实就是对不同位移方向和大小进行颜色赋值，例如绿色代表往右上角进行移动，绿色越深表示偏移程度越大。\n例如可以达到以下的效果。（实际位移方向与颜色之间的映射关系可能不同，下图中左上角的椅子往右上角移动了，颜色为深紫色。）\n网上常用的可视化代码如下，可以直接当成已知模块使用。\n# 将flow进行可视化 def flow_to_image(flow, max_flow=256): # 确保max_flow的最小值为1 if max_flow is not None: max_flow = max(max_flow, 1.) else: max_flow = np.max(flow) # 定值，含义未深究，可能是用于得到不同的饱和度 n = 8 # 提取水平、垂直运动信息 u, v = flow[:, :, 0], flow[:, :, 1] # 计算每个像素点的光流大小，即为模长（位移大小） mag = np.sqrt(np.square(u) + np.square(v)) # 计算每个像素点的光流方向，即速度的方向角度（得到的弧度） angle = np.arctan2(v, u) # 将角度值映射到0到1的范围内，除以2*pi，加1并余1即可约束范围（色调信息） im_h = np.mod(angle / (2 * np.pi) + 1, 1) # 大概是：计算每个像素点的饱和度，通过光流大小和max_flow的比值进行缩放，并确保饱和度在0到1的范围内 im_s = np.clip(mag * n / max_flow, a_min=0, a_max=1) # 大概是：计算每个像素点的亮度，亮度为n减去饱和度，并确保亮度在0到1的范围内 im_v = np.clip(n - im_s, a_min=0, a_max=1) # 将色调、饱和度和亮度转换为RGB颜色空间的图像 im = hsv_to_rgb(np.stack([im_h, im_s, im_v], 2)) # 在0到255的范围内表示图像的像素值 return (im * 255).astype(np.uint8) 2.3 backwarp操作实现 对于正向warp，其含义比较简单，即将每一个像素点数值放到对应的偏移位置即可，注意非整点的处理。\n这里重点介绍一下使用torch.nn.functional.grid_sample的backwarp操作，由于backwarp操作一般在网络内部执行，这里写的是torch框架下的代码。\n对于grid_sample函数，网上资料较多，不做赘述，简单来说就是输入一个图像和一个网格grid，根据网格grid中的位置信息在图像中找到（采样）对应的像素点进行存储，看后续代码应该更好理解。\n# 这里把它封装成了一个nn模块，将backwarp操作写到了正向传播过程中，输入frame2与flow，得到对应的frame1 class BackWarpFlow(nn.Module): # 类静态变量，其实可以写成全局变量。由于后面的操作有需要处理指定规格的网格，有时候无需重复处理以减少时间开销，这里先做一个存储 Warp_Grid = {} def __init__(self): super(BackWarpFlow, self).__init__() def forward(self, img, flow): # 将运算加载到GPU上，如果传入的张量已在GPU上加载则可以不用操作 img, flow = img.cuda(), flow.cuda() # 若该规格的flow未被处理过（未生成过对应规格的网格）则先处理出一个网格 if str(flow.shape) not in BackWarpFlow.Warp_Grid: # 使用linspace生成一个从-1.0到1.0的等间隔的张量（与flow的宽等长），并调整规格为[1,1,1,W] # 使用repeat函数在shape[2]方向上重复shape[2]次，即H次，得到张量的规格为[1,1,H,W] u = torch.linspace(-1.0, 1.0, flow.shape[3]).view(1, 1, 1, -1).repeat(1, 1, flow.shape[2], 1) # 同理另一层 v = torch.linspace(-1.0, 1.0, flow.shape[2]).view(1, 1, -1, 1).repeat(1, 1, 1, flow.shape[3]) # 在第1个维度上拼接得到的网格规格为[1,2,H,W]，与flow相对应，且每一个像素位置上的值是均匀的，与其位置相对应。存储到字典中 BackWarpFlow.Warp_Grid[str(flow.shape)] = torch.cat([u, v], 1).cuda() # 取出flow中两个方向上的偏移，将其根据规格进行规范化处理，重新拼接 tenFlow = torch.cat([flow[:, 0:1, :, :] * (2.0 / (img.shape[3] - 1.0)), flow[:, 1:2, :, :] * (2.0 / (img.shape[2] - 1.0))], 1) # 调用grid_sample进行采样，前面提到Warp_Grid中的网格值是与位置一一对应的，加上flow后，每个网格上的值就相当于进行了位移，将该网格作为采样网格即可实现frame2还原到frame1。（理解成，(i,j)地方的像素应当去(i+u,j+v)的地方采样，(i,j)即在Warp_Grid中体现，与位置对应，(u,v)即在tenFlow体现） # permute调整维度以适应grid_sample函数，该函数要求通道数这一维在最后 # 可能有非整点的情况出现，采用双线性插值。 return torch.nn.functional.grid_sample(input=img, grid=(BackWarpFlow.Warp_Grid[str(tenFlow.shape)] + tenFlow).permute(0,2,3,1), mode=\u0026#39;bilinear\u0026#39;, padding_mode=\u0026#39;border\u0026#39;, align_corners=True) 2.4 光流的评价(Loss说明) 最主要的评价指标为Endpoint error (EPE) loss，即端点误差损失。EPE损失是通过计算预测的光流场与真实的光流场之间的平均欧氏距离来衡量光流估计的精度。同时也可以作为损失函数进行相关光流估计网络的训练。该部分代码实现方式较多，这里呈现最简单的实现方法。\nclass EPELoss(nn.Module): def __init__(self): super(EPELoss, self).__init__() def forward(self, flow_pred, flow_target): # 平均欧氏距离 dist = (flow_target - flow_pred).pow(2).sum().sqrt() return dist.mean() 3. 光流估计方法 前人有许多基于数理统计、泰勒展开等数学方法，内容较多难以涵盖，主要介绍归纳几种常见有效的基于深度学习的光流估计方法（当然是经过论文阅读和学习的方法，没有学习到的方法若后续有所学习，则会补上笔记）。大部分方法本文只能给出整体的实现思路，具体的开源代码分析耗时较长，后续再进行整理编辑。同时，对于每种方法的创新点和亮点，不同读者可能有不同的理解看法，本文视角可能相对局限。\n3.1 FlowNet-基于CNNs构建的含关联层的端到端训练光流网络 3.1.1 论文及其链接 论文：ICCV2015, FlowNet: Learning Optical Flow with Convolutional Networks\n链接：FlowNet: Learning Optical Flow With Convolutional Networks (thecvf.com) 3.1.2 文章摘要 卷积神经网络（CNNs）最近在各种计算机视觉任务中取得了很大成功，尤其是与识别相关的任务。光流估计并不是CNNs成功的任务之一。在本文中，我们构建了能够将光流估计问题作为监督学习任务解决的CNNs。我们提出并比较了两种架构：一种通用架构和另一种包括在不同图像位置相关特征向量的层。由于现有的地面真实数据集不足以训练CNN，我们生成了一个大型的合成飞行椅子（Flying Chairs）数据集。我们展示了在这种不真实的数据上训练的网络仍然很好地推广到现有数据集，如Sintel和KITTI，在5到10fps的帧速率下达到了竞争性的准确度。\n3.1.3 文章亮点 提出了使用卷积神经网络来进行光流估计的方法，例如一种通用架构，说明了使用CNNs方法进行光流估计的可行性； 提出了像素关联层（correlation layer）的概念，再像素级别描述各像素之间的关联性，使用网络自行学习两张图像（或其特征）之间的关联性，以实现图像在不同位置之间的匹配； 在多个尺度上不断细化光流（Refinement），对低分辨率的粗糙进行上采样并逐步学习细化； 制作了Flying Chairs数据集，提供了一种含噪声背景情况下的物体运动信息（Flow）的数据集。 3.1.4 网络结构 文章中包含了两种网络结构，一种为简单版本的FlowNetSimple，另一种是基于像素关联层的FlowNetCorr，结构分别如下。\nRefinement模块\n两类网络均包含了refinement细化模块，该模块以多尺度的图像特征为输入，得到细化的光流估计（提高光流的输出分辨率），结构如下。（但从效果来说，又比双线性插值好多少呢）\n可以看到，灰色部分即为编码器（特征提取部分）所得到的多尺度特征。该细化模块进行了多个尺度的粗糙光流细化，具体地，相当于将以下三部分内容进行拼接：上一层特征经过卷积与上卷积后的结果（绿色）、上一层输出的粗糙flow的上采样结果（红色）、编码器过程中对应尺度的特征（灰色），作为当前层的特征，送入一个光流预测网络即可获得当前层输出的光流。\nFlowNetSimple\n简单地将两张图像进行拼接(在通道维度上进行拼接)，并使用卷积神经网络进行多尺度的特征提取，最后送入细化模块进行光流的细化。该网络结构是由网络自行决定如何从图像中进行运动信息的提取。对输出Flow进行监督达到光流估计的目的。\nFlowNetCorr\n根据网络结构可知对两帧图像分别进行特征的采集，随后对特征进行关联性计算，得到一个特征相关性矩阵（暂且这么叫吧）。\n首先文章中给出了两个特征图中任意两个像素之间的关联性定义，如下表达式。\n$$ I(i,j,t) = I(i+u,j+v,t+\\Delta t) $$\n$$ c\\left(\\mathbf{x}_{1}, \\mathbf{x}_{2}\\right)=\\sum_{\\mathbf{o} \\in[-k, k] \\times[-k, k]}\\left\\langle\\mathbf{f}_{1}\\left(\\mathbf{x}_{1}+\\mathbf{o}\\right), \\mathbf{f}_{2}\\left(\\mathbf{x}_{2}+\\mathbf{o}\\right)\\right\\rangle $$\n上式含义为：以x1这个点为中心，2k+1为边长的正方形区域，与x2为中心的区域之间的关联性，这里引入一个k作为区域范围，以说明一个个patch块之间的关联性（其实就是考虑到了周边的像素点的特征）。其中x1和x2分别表示来自于两个特征图的像素位置，分别都是二元组；f1表示第一个特征图，f2表示第二个特征图，由于特征图是多通道的（如前面的网络结构图中显示的两个计算相关性的特征图，均有256层特征），因此每一个像素位置都可以取到多通道的特征数值（例如在第一个特征图的(i,j)位置，可以取到一个256维的向量feature[: , : , i , j])，将两个区域块对应位置的特征向量进行内积运算，得到一个相关值c。\n但每个特征图都有h×w个像素，两张特征图中两两求关联性则会产生h×h×w×w个相关值，这个数量太大了，因此文章中提到对于每个位置的像素仅考虑一个限定范围D之内的像素的相关性，即不考虑处理距离太远的像素之间的相关项，这样便将值相关性数据的数理降低为h×w×D×D。即可以理解为：对于第一张图的每一个位置的像素特征，都对应着和第二张图D×D个相关性值。这也是图中441这个数值的来源，这里的D应取为21，即考虑以某一像素为中心，边长为21的范围内的像素的相关性。\n此外，观察网络结构图可以发现，文章还将该相关项矩阵与第一张图的再采样的特征图（以尺寸为1的卷积核获取了32层特征）进行了拼接操作，这一步文章中并未详细说明（可能也是我没读仔细），感性理解上可能是，后续的网络学习需要同时带上第一帧图像的一些特征信息，进行特征融合。\n通过相关性矩阵的处理，网络能够学习到像素级别上的像素相关性信息，从而更好地捕获像素级别的运动信息，在学习到抽象的相关性特征的同时不丢失浅层的图像信息。\n3.2 SPyNet-基于空间金字塔与残差光流训练的光流更新网络 3.2.1 论文及其链接 论文：CVPR2017, Optical Flow Estimation using a Spatial Pyramid Network\n链接：Optical Flow Estimation Using a Spatial Pyramid Network (thecvf.com) 3.2.2 文章摘要 我们通过将经典的空间金字塔形式与深度学习相结合来学习计算光流。这通过在每个金字塔级别将一对图像中的一个图像根据当前的光流估计进行warp，并计算对光流的更新来以粗到细的方式估计大运动。与在每个金字塔级别进行标准目标函数最小化的方法不同，我们针对每个级别训练一个深度网络来计算光流的更新。与最近的FlowNet方法不同，网络不需要处理大运动；这些大运动由金字塔来处理。这有几个优点。首先，我们的空间金字塔网络（SPyNet）在模型参数方面比FlowNet简单得多，小96%。这使得它更高效，更适用于嵌入式应用。其次，由于每个金字塔级别的光流很小（\u0026lt;1像素），因此将卷积方法应用于一对变形图像是合适的。第三，与FlowNet不同，学习到的卷积滤波器与经典的时空滤波器相似，这提供了对方法及其改进方法的见解。我们的结果比大多数标准基准测试上的FlowNet更精确，这表明了将经典的光流方法与深度学习相结合的新方向。\n3.2.3 文章亮点 采用训练光流残差的方式，对光流进行逐步细化； 每一个尺度下均训练了一个深度网络用于光流残差的获取，并有多尺度下的光流细化过程； 将传统的空间金字塔与深度学习方法进行结合，同时参数量较小。 3.2.4 网络结构 SPyNet的网络结构如下，其中仅举例展示了三层金字塔结构，具体的金字塔层数可以根据实际情况进行修改。\n其中可以明显看到每一层的网络结构大致相同，故这里取其中一层的结构进行说明，如红框所示，首先需要有上一层网络产出的预测光流（需要通过u上采样达到目标分辨率，或者双线性插值）。对于深度网络G，输入深度网络的有三部分内容：上一层的预测光流，frame1，经过上一层预测光流backwarp的frame2；而输出深度网络的则为光流残差，需要与上一层的预测光流进行相加以实现这一尺度下的光流细化。\n在最开始的情况下，直接暴力地设置初始光流为0，通过多尺度的空间特征与光流细化后得到目标尺度的光流。对于具体的公式表达，文章说明的比较详细，但最终表达的意思与网络结构图一致。\n模型训练\n根据文章描述，是对每一层的深度网络G进行依次训练，并不是一次性的端到端训练，其中Loss的定义如下图，即在前面的所有层的网络完成训练后，认定可以产出较为精准的光流，该层深度网络训练得到光流残差$v_k$后，与当前尺度下的光流标签$\\hat V_k$和上一层预测光流的差$\\hat v_k$进行Loss计算，使用EPELoss。\n但为什么不能直接对加上光流残差修正后的光流进行监督呢？含义似乎是一样的。\n这样分层训练的方式简化了模型的训练，相比于端到端的训练方法来说更省时间或容易收敛。（不知道能不能对多层光流同时进行监督？）\n3.2.5 代码分析 开源代码中大部分训练代码给的为lua代码，但也给出了使用Pytorch框架编写的网络结构，为更好地理解网络结构，对代码进行分析（lua没学过）。\n去除一些辅助代码，这里只看核心的网络架构。取自开源的Pytorch代码（https://github.com/sniklaus/pytorch-spynet），进行注释编写分析。\nclass Network(torch.nn.Module): def __init__(self): super().__init__() # 为更好地训练模型，编写了一个图像归一化处理的过程代码 class Preprocess(torch.nn.Module): def __init__(self): super().__init__() def forward(self, tenInput): # 翻转通道，为什么呢？ tenInput = tenInput.flip([1]) # 减去数据集的均值并除以标准差以实现图像的归一化 tenInput = tenInput - torch.tensor(data=[0.485, 0.456, 0.406], dtype=tenInput.dtype, device=tenInput.device).view(1, 3, 1, 1) tenInput = tenInput * torch.tensor(data=[1.0 / 0.229, 1.0 / 0.224, 1.0 / 0.225], dtype=tenInput.dtype, device=tenInput.device).view(1, 3, 1, 1) return tenInput # 每层的光流残差训练的深度网络 class Basic(torch.nn.Module): def __init__(self, intLevel): super().__init__() # 与论文实验部分说明一致，采用五个卷积层加ReLU激活函数 self.netBasic = torch.nn.Sequential( # 说明为什么输入通道为8。 # 前面提及送入网络的三部分内容为：上一层的预测光流（2通道），frame1（3通道），经过上一层预测光流backwarp的frame2（3通道） # 直接拼接融合即为8通道 torch.nn.Conv2d(in_channels=8, out_channels=32, kernel_size=7, stride=1, padding=3), torch.nn.ReLU(inplace=False), torch.nn.Conv2d(in_channels=32, out_channels=64, kernel_size=7, stride=1, padding=3), torch.nn.ReLU(inplace=False), torch.nn.Conv2d(in_channels=64, out_channels=32, kernel_size=7, stride=1, padding=3), torch.nn.ReLU(inplace=False), torch.nn.Conv2d(in_channels=32, out_channels=16, kernel_size=7, stride=1, padding=3), torch.nn.ReLU(inplace=False), torch.nn.Conv2d(in_channels=16, out_channels=2, kernel_size=7, stride=1, padding=3) ) def forward(self, tenInput): return self.netBasic(tenInput) self.netPreprocess = Preprocess() # 每一层都有一个深度网络用于训练当前尺度的光流残差 self.netBasic = torch.nn.ModuleList([ Basic(intLevel) for intLevel in range(6) ]) def forward(self, tenOne, tenTwo): tenFlow = [] # 用于存储不同尺度下的图像金字塔 开始就是原尺度 tenOne = [ self.netPreprocess(tenOne) ] tenTwo = [ self.netPreprocess(tenTwo) ] # 额外处理五层 for intLevel in range(5): # 取金字塔顶部（最小的）图像，若宽高大于32则可以继续下采样 if tenOne[0].shape[2] \u0026gt; 32 or tenOne[0].shape[3] \u0026gt; 32: # 使用均值池化获取低分辨率的图像， insert到list的第0位，则金字塔中的尺度是自小向大的 tenOne.insert(0, torch.nn.functional.avg_pool2d(input=tenOne[0], kernel_size=2, stride=2, count_include_pad=False)) tenTwo.insert(0, torch.nn.functional.avg_pool2d(input=tenTwo[0], kernel_size=2, stride=2, count_include_pad=False)) # 开始光流为0，shape除以2是因为每一层的操作都有一个光流上采样过程，为了同步编码，第0层也进行一个上采样，因此设置小一点的初始光流 tenFlow = tenOne[0].new_zeros([ tenOne[0].shape[0], 2, int(math.floor(tenOne[0].shape[2] / 2.0)), int(math.floor(tenOne[0].shape[3] / 2.0)) ]) # 遍历每一层 for intLevel in range(len(tenOne)): # 对光流进行上采样，方式为双线性插值，缩放比为2， tenUpsampled = torch.nn.functional.interpolate(input=tenFlow, scale_factor=2, mode=\u0026#39;bilinear\u0026#39;, align_corners=True) * 2.0 # 对上采样的光流尺寸进行修正，处理可能存在的尺寸不匹配问题，需要与金字塔图片的尺度进行匹配。 if tenUpsampled.shape[2] != tenOne[intLevel].shape[2]: tenUpsampled = torch.nn.functional.pad(input=tenUpsampled, pad=[ 0, 0, 0, 1 ], mode=\u0026#39;replicate\u0026#39;) if tenUpsampled.shape[3] != tenOne[intLevel].shape[3]: tenUpsampled = torch.nn.functional.pad(input=tenUpsampled, pad=[ 0, 1, 0, 0 ], mode=\u0026#39;replicate\u0026#39;) # 将前面提及的三部分送入深度网络训练，得到光流残差最后加上上采样后的前一层的预测光流 # tenOne[intLevel] 第一帧 # backwarp(tenInput=tenTwo[intLevel], tenFlow=tenUpsampled) 通过当前光流backwarp后的第二帧 # tenUpsampled 当前预测光流 tenFlow = self.netBasic[intLevel](torch.cat([ tenOne[intLevel], backwarp(tenInput=tenTwo[intLevel], tenFlow=tenUpsampled), tenUpsampled ], 1)) + tenUpsampled return tenFlow 3.3 RAFT-基于多尺度4D相关体查找与GRU的迭代光流更新网络 3.3.1 论文及其链接 论文：ECCV2020, Recurrent All-Pairs Field Transforms for Optical Flow\n链接：ecva.net/papers/eccv_2020/papers_ECCV/papers/123470392.pdf 3.3.2 文章摘要 我们介绍了循环全对场变换（RAFT），这是一种用于光流的新型深度网络架构。RAFT提取每个像素的特征，为所有像素对构建多尺度4D相关性体，并通过一个循环单元迭代地更新流场，该单元在相关性体上执行查找操作。RAFT实现了最先进的性能。在KITTI数据集上，RAFT实现了5.10%的F1-all误差，比最佳发布结果（6.10%）减少了16%的误差。在Sintel（最终通行证）上，RAFT的端点误差为2.855像素，比最佳发布结果（4.098像素）减少了30%的误差。此外，RAFT在推理时间、训练速度和参数数量方面具有高效率，具有强大的跨数据集泛化能力。\n3.3.3 文章亮点 采用多尺度的4D相关体，即相关体金字塔，通过预处理该金字塔结合后续的查表操作，可以描述一个flow所带来的映射像素的多尺度相关性 采用GRU对光流进行不断的修正与更新。 3.3.4 网络结构 RAFT的整体结构如下，后文进行分模块分析。\n特征提取网络\n即上图中的Feature Encoder和Context Encoder，分别进行图像特征和语义特征的提取。其中Feature Encoder导出低分辨率的密集特征图。（对于特征提取无非是卷积操作，这里也不深究特征提取到什么程度了，到后面看看对特征图进行怎样的处理）\n4D相关体（4D Correlation Volumes）计算\n看结构图可以看到一个点积的符号，联想到对特征向量的点积操作，这里和FlowNet中的关联矩阵计算很类似，只是这里只考虑两个像素之间的特征相关性，并没有选定某一个范围进行区域相关性计算。公式如下，本质上就是将两个像素（比如第一张图的(i,j)和第二张图的(k,l)）对应的特征进行点积得到一个特征值，那么像素两两进行相关性计算即可得到一个4维（H×W×H×W）的相关矩阵，通称为4D相关体，表示$I_1$每一个像素点与每一个$I_2$像素点的相关度。\n$$ C_{ijkl}=\\sum_{h}g_{\\theta}(\\mathbf{I_{1}})_{ijh}·g_{\\theta}(\\mathbf{I_2})_{klh} $$\n相关性金字塔（Correlation Pyramid）\n但实际上，frame1（前文说是$I_1$）的像素不可能与frame2的每一个像素都有关联（可能还有其它更深层的考虑），作者再4D相关体的后两个维度上进行下采样，得到了4层的相关体，其中尺寸从大到小分别为H×W×H×W、H×W×H/2×W/2、H×W×H/4×W/4、H×W×H/8×W/8，这里也在一定程度上隐含了像素和某一个区域的相关性。如下图所示。\n查表Lookup\n这一部分论文写的相对难以理解，不过可以去读源码辅助理解。\n由于RAFT主要进行的是光流的迭代更新，对于每一次产出的光流，可以表示为（$\\mathbf{f}^{1},\\mathbf{f}^{2}$），对于frame1中的一个像素点$\\mathbf{x}(u,v)$，通过光流找到frame2中的对应点$\\mathbf{x\u0026rsquo;}(u+\\mathbf{f}^{1}(u),v+\\mathbf{f}^{2}(v))$，在$\\mathbf{x\u0026rsquo;}$的基础上，作者定义了一个领域网格$N_r(\\mathbf{x\u0026rsquo;})$，表达式如下： $$ \\mathbf{N_r(x\u0026rsquo;)} = { \\mathbf{x\u0026rsquo;}+\\mathbf{dx}\\ |\\ \\mathbf{dx}\\in \\mathbb{Z}^2, ||\\mathbf{dx}||_1 \\le r } $$ 相当于这个领域网格就是以当前预测光流的映射关系下，找到对应像素点的一个领域范围内，并在这个领域范围内去查找相关性金字塔，将查询得到的值进行组合得到一个新的向量，该向量就是Lookup的输出结果。（不太标准地概括这种思路：对于任意一个flow，在4D相关体上查询frame1的像素在该flow的作用下的映射像素之间的多尺度关联性，关联性越高那么显然这个flow的映射更贴近真实情况，这样便给与网络一种描述flow准确度的手段）\n举个例子，比如r为9，那么对于每一个frame1的像素点，都可以在4D相关性金字塔的每一层中查询到81个相关性值，即为与邻域范围内所有像素点的相关性，而4层相关体则可以查询到4×81个相关性值（对于低像素的相关体，使用双线性采样器找到对应的位置即可），那么对于所有H×W个像素点，最终可以查询到规格[H,W,324]的向量。\n对于上式，r如果较大，那么能够获取到的关联性数据就多，能够获取较大运动范围内的关联信息，反之则运动更为精细。\n光流迭代更新（GRU）\nGRU的大体结构和式子不作赘述，直接看以下网络结构，用于修正光流的产生。\n对于每一次迭代，GRU单元的输入（图中红色）包含：经过Lookup查表后的关联向量、隐状态、语义特征context feature；输出（图中蓝色）包含：更新后的隐状态，修正光流Δf，用于对上一次迭代的粗糙光流进行修正。\n特别的是，训练过程中，作者并非直接取最后一次迭代的光流与实际光流计算Loss，而是对每一次迭代的光流都进行了Loss计算以监督。\n这个思路与SPyNet略有点相似（也只是一点，在于使用深度网络训练残差光流，对光流进行细化），只是RAFT在全分辨率下不断进行光流的修正，能够实现每次迭代的监督，而SPyNet则是在多尺度下进行光流的细化。\n以下的内容等待进一步深入学习与笔记的细化。\n3.4 GMA-基于全局运动信息 3.4.1 论文及其链接 论文：ICCV2021, Learning to Estimate Hidden Motions with Global Motion Aggregation\n链接：Learning To Estimate Hidden Motions With Global Motion Aggregation (thecvf.com) 3.5 KPA-基于局部注意力 3.5.1 论文及其链接 论文：CVPR2022，Learning Optical Flow with Kernel Patch Attention\n链接：Learning Optical Flow With Kernel Patch Attention (thecvf.com) 3.6 DIP-基于patchmatch降低4D相关体的计算 3.6.1 论文及其链接 论文：CVPR2022, DIP: Deep Inverse Patchmatch for High-Resolution Optical Flow\n链接：DIP: Deep Inverse Patchmatch for High-Resolution Optical Flow (thecvf.com) 4. 光流的应用研究 4.1 ICCV2017：Semantic Video CNNs through Representation Warping 使用offline的flow计算方法对前一帧的feature进行warp，但warp的是CNN过程中的层特征。提高精度。\n4.2 CVPR2018：Semantic Video Segmentation by Gated Recurrent Flow Propagation 将前一帧的mask进行warp，与当前帧直接计算的mask共同送入GRU，以实现前一帧mask对当前帧mask的弥补。提高精度。\n4.3 CVPR2017：Deep Feature Flow for Video Recognition 将前一帧（key frame）的feature通过flow作为当前帧的feature，减少重复的特征计算。\n参考资料 optical flow光流方向问题 - 知乎 (zhihu.com) 光流、warp和grid_sample()_pytorch warp-CSDN博客 提取光流文件(.flo)为u，v二通道图像(作为网络输入)_光流flo 文件-CSDN博客 端点误差损失Endpoint error (EPE) loss - 知乎 (zhihu.com) 【光流评估】《Optical Flow Estimation using a Spatial Pyramid Network》2016 Tubingen, Germany-CSDN博客 全面回顾 | 基于深度学习的光流估计算法汇总-CSDN博客 RAFT光流估计 - CuriosityWang - 博客园 (cnblogs.com) https://github.com/sniklaus/pytorch-spynet "},{"section":"Blog","slug":"/en/blog/database/","title":"【课程笔记】数据库原理与应用","description":"this is meta description","date":"September 25, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"219\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"数据库原理与应用","content":"一. 绪论 1. 数据库的几个基本概念 数据 描述事物的符号记录\n数据库 数据库时长期存储在计算机内、有组织、可共享的大量数据的集合\n数据库管理系统 位于用户和操作系统之间的一层数据管理软件\n包含以下功能：\n1.数据定义功能（提供数据定义语言DDL） 2.数据组织、存储和管理 3.数据操作功能（提供数据操作语言DML） 4.数据库的事务管理和运行管理 5.数据库的建立和维护功能\n数据库系统 由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理、维护数据的系统\n2. 数据库系统的特点 数据结构化 数据的共享性高、冗余度低且易扩充 数据独立性高 保证应用程序不会发生改变\n包含物理独立性和逻辑独立性\n物理独立性即指用户的应用程序域数据库中数据的物理存储方式是相互独立的；逻辑独立性则与数据库的逻辑结构相互独立\n数据由数据库管理系统统一管理和控制 DBMS需要提供以下数据控制功能\n数据的安全性保证 数据的完整性检查 并发控制 数据库恢复 3. 数据模型 数据模型是对现实世界数据特征的抽象，数据模型是用来描述数据、组织数据和对数据进行操作的。\n两类数据模型 概念模型：考虑ER图\n逻辑模型：包含层次模型、网状模型、关系模型、面向对象数据结构、对象关系数据模型、半结构化数据模型\n补充：物理模型是对数据最底层的抽象，是数据在计算机内部的表示方式和存取方式\n数据模型的组成要素 数据结构、数据操作和数据完整性约束条件这三个方面的内容完整地描述了一个数据模型。\n数据结构：描述数据库的组成对象以及对象之间的联系（描述静态特性）\n数据操作：对数据库中各类对象的实例允许执行的操作的集合，包括操作及有关的操作规则。（描述动态特性）\n数据的完整性约束条件：一组完整性规则，用于限定符合数据模型的数据库状态以及状态的变化，保证数据的这个却有效和相容。\n常用的逻辑数据模型 层次模型 优点：结构比较简单清晰、查询效率高、提供良好的完整性支持\n缺点：很多联系是非层次性的，如果一个节点具有多个双亲结点则难以表示，查询子节点必须经过双亲节点\n网状模型 优点：能够更为直接的描述现实世界，性能良好存储效率高\n缺点：结构复杂，DDL、DML较为复杂\n关系模型 关系模式：对关系的描述，一般表示为：关系名（属性1，属性2，\u0026hellip;，属性n）\n关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项。\n关系的完整性约束条件包含三大类：实体完整性、参照完整性、用户定义的完整性。\n优点：建立在严格的数学概念的基础上的；数据结构简单、清晰；存取路径对用户透明，具有更高的数据独立性\n缺点：查询效率往往不如格式化数据模型\n4.三级模式结构 模式是对数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及对型的描述，而不涉及具体的值。\n模式的一个具体值被称为模式的一个实例，模式是相对稳定的，而实例是相对变动的。\n模式 模式也称为逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n模式实际上是数据库数据在逻辑级上的视图，一个数据库只有一个模式。\n考虑成基本数据表。\n外模式 也称为子模式或者用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述\n外模式是模式的子集，一个数据库可以有多个外模式。\n考虑成用户视图。\n内模式 也成为存储模式，一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。\n外模式/模式映像 体现逻辑独立。\n模式改变时，对该模式映像进行改变，可以使外模式保持不变。\n应用程序是基于外模式编写的，从而让应用程序不必修改。\n模式/内模式映像 体现物理独立。\n模式/内模式映像是唯一的，定义了数据全局逻辑结构和存储结构之间的对应关系\n当存储结构发生改变时，对该模式映像进行改变，使得模式保持不变，从而顶层的应用程序也不必发生改变。\n二、关系数据库 1. 关系与关系模式 2. 关系操作 基本的关系操作 关系数据语言的分类 3. 关系的完整性 4. 关系代数 三、关系数据库标准语言SQL 四. 数据库安全性 数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。\n1. 不安全因素 非授权用户对数据库的恶意存取和破坏 数据库中重要或敏感的数据被泄露 安全环境的脆弱性 2. 安全标准 TCSEC/TDI将系统划分为4组共7个等级\n自高到低分别为：A1、B3、B2、B1、C2、C1、D\nCC标准\n低到高EAL1到EAL7，与上对应\n3. 数据库安全性控制 用户身份鉴别：静态口令鉴别（密码）、动态口令鉴别（验证码）、生物特征鉴别、智能卡鉴别 存取控制（自主和强制） 自主存取控制方法：授权 4. 自主存取控制 用户权限包含两个要素：数据库对象和操作类型\n存取控制的对象包含：数据本身（数据、属性列、具体数据）以及数据库模式（包含模式、基本表、视图、和索引的创建）。\n为什么要授权：是数据库安全控制中的自主存取控制方法，为了保护数据库、防止不合法的操作对数据库造成泄露、更改或毁坏。\n授权GRNAT GRANT 权限 ON 对象类型 对象名 TO 用户名 [WITH GRANT OPTION]\n用户可以是：一个或多个具体用户，也可以是PUBLIC，指全体用户。\nWITH GRANT OPTION子句：可以把权限再授予其它的用于。\n所有权限：ALL PREVILEGES\n不允许循环授权！\n收回授权REVOKE REVOKE 权限 ON 对象类型 对象名 FROM 用户名 [CASCADE|RESTRICT]\nCASCADE：级联回收，将用户传播出去的权限一并收回。（默认为CASCADE）\nRESTRICT：受限回收。若用户传播该权限，则无法进行权限回收。\n创建数据库模式的权限 以上授权均为对数据的操作权限，若要给与创建模式的权限则需要在创建用户时实现。\nCREATE USER 用户名 [WITH] [DBA|RESOURSE|CONNECT]\n只有超级用户才能创建数据库用户\nDBA权限可以：创建用户、创建模式、创建表、登录数据库执行查询和操纵\nRESOURSE权限：不可以创建用户、模式，可以创建表，可以登录数据库执行查询和操纵\nCONNECT权限：啥都不可以创建，可以连接数据库，具体操作权限需要被授权才可以。\n数据库角色 角色就是一组权限的集合\nCREATE ROLE 角色名\n在一个角色中添加角色或者用户：\nGRANT 角色 TO 某角色/某用户 [WITH ADMIN OPTION]\n如果指定WITH ADMIN OPTION子句，则表示可以把这种权限再授予其它角色\n给角色授权：\nGRANT 权限 ON 对象类型 对象名 TO 角色；\n授权授权：\nREVOKE 权限 ON 对象类型 对象名 FROM 角色；\n5. 强制存取控制 将实体划分为主体和客体\n主体就是活动实体，例如实际用户\n客体就是被动实体，例如文件、基本表、索引\n为每个实例派发一个敏感度标记，对主体来说为许可证级别，对客体来说是密集\n级别由：绝密TS、机密S、可信C、公开P\n当且仅当主体的许可证级别大于等于客体的密级时，该主体才能够读相应的客体。\n当且仅当主体的许可证级别小于等于客体的密级时，主体才能写相应的客体。\n6. 视图机制 通过视图机制把要保密的数据对无权存取的用户英藏起来\n7. 审计 把对数据库的所有操作都记录到审计日志中，然后可以通过日志审计这个里面是否有一些违法行为。\nAUDIT 操作 ON 对象；对某个对象的某个操作进行审计\nNOAUDIT 操作 ON 对象；取消审计\n是一种事后检查的安全机制。\n8. 数据加密 存储加密 透明存储加密：数据在写道磁盘时对数据进行加密（内核级）\n非透明加密：多个加密函数实现\n传输加密 五. 数据库完整性 1.定义 数据库的完整性是指数据的正确性、相容性\n正确性：数据是符合现实世界语义、反映当前实际状况的\n相容性：数据库同一对象在不同关系表中的数据是符合逻辑的\n区别完整性和安全性：完整性保证不存在不符合语义的数据，安全性是保护数据库被恶意破坏或者非法存取\n数据库管理系统需要实现：\n提供定义完整性约束条件的机制\n提供完整性检查的方法\n进行违约处理\n2. 实体完整性 定义 关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。\n有两种说明方法：列级约束条件（在属性后面直接定义）、表级约束条件（一张表后进行定义）\nCREATE TABLE STudent ( Sno CHAR PRIMARY KEY, 列级 PRIMARY KEY(Sno) 表级 ) 检查和违约处理 插入或者修改时自动进行检查：\n检查主码值是否唯一，不唯一则拒绝修改。 检查主码的各个属性值是否为空，只要有一个为空则拒绝修改 检查是否唯一的一种方法是全表扫描并依次对比，或者建立索引进行查找。\n3. 参照完整性 定义 在CREATE TABLE上用FOREIGN KEY短语进行外码的定义，使用REFERENCES短语指明外码参照哪些表的主码。\n检查和违约处理 对被参照表和参照表进行增删改操作时可能会破坏参照完整性约束，必须检查两个表的相容性。\n处理策略包括：\n拒绝执行NO ACTION（默认策略） 级联操作CASCADE 例如删除学生，对应的选课记录也会被删除。\n例如，这样会在删除Student表中的元组后级联删除SC表的对应项，修改同理。\nFOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE ON UPDATE CASCADE 设置为空值 4. 用户定义的完整性 定义 在建表时要求定义属性上的约束条件，即属性值限制\n包括：\n列值非空\n列值为一\n检查列值是否满足一个条件表达式（CHECK 短语）\n分为以下定义方法：\n属性上的定义：直接跟在属性后面 元组上的定义：表级类似，在表的最后进行CHECK语句的编写，一般这样能够控制多个属性 违约处理 拒绝执行\n5. 完整性约束命名子句 定义 CONSTRAINT 完整性约束条件名 \u0026lt;完整性约束条件\u0026gt;\n完整性约束条件包括NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK短语等。\n可以直接跟在属性的定义后面（对属性的一些约束）.\nCREATE TABLE Student( Sno CHAR(20) CONSTRAINT C1 CHECK(Sno BETWEEN 2000 AND BETWEEN 3000), ) 或者表级：\nCREATE TABLE Student( Sno CHAR(20), CONSTRAINT StudentKey PRIMARY KEY(Sno)， CONSTRAINT ForeignKey FOREIGN KEY(Sno) F, ) 修改 使用ALTER TABLE语句修改表中的完整性限制\nALTER TABLE Student DROP CONSTRAINT C4\nALTER TABLE Student ADD CONSTRAINT C1 CHECK(\u0026hellip;)\n6. 断言 创建断言：\nCREATE ASSERTION 断言名 \u0026lt;CHECK子句\u0026gt;\n断言创建后，任何对断言中涉及的关系的操作会触发对断言的检查，不符合断言的则被拒绝执行\n例如限制所有课程最多60名学生选修：\nCREATE ASSERTION CHECKX CHECK( 60\u0026gt;=ALL( SELECT COUNT(*) FROM SC GROUP BY Cno ) ) 增加表的属性：ALTER TABLE \u0026lt;X\u0026gt; ADD \u0026lt;NAME\u0026gt; \u0026lt;TYPE\u0026gt;\n7. 触发器 CREATE TRIGGER SC_T AFTER UPDATE OF Grade ON SC 触发事件 REFERENCING OLDROW AS old NEWROW as new FOR EACH ROW\t行级触发器，每执行一次对Grade的更新就会触发一次 行级有OLDROW和NEWROW 语句级触发器为FOR EACH STATEMENT 语句级有 NEWTABLE和OLDTABLE WHEN(new.Grade\u0026gt;=1.1*old.Grade) INSERT..... 需要对每一行数据做处理则使用行级触发器\n语句执行完后再执行语句的后续业务处理逻辑则使用语句级\n再举例：\nCREATE TRIGGER Insert_s BEFORE INSERT OR UPDATE ON Teacher REFERENCING NEWROW AS newT FOR EACH ROW BEGIN IF(newT.Job=1) AND(...) THEN newT.Sal:=4000 END IF; END; 触发器的激活：\n先BEFORE触发器，再激活触发器的SQL语句，最后AFTER触发器\n相同级别的谁先创建谁执行。\n删除触发器：\nDROP TRIGGER \u0026lt;触发器名\u0026gt; ON \u0026lt;表\u0026gt;\n六. 关系数据理论 纸质笔记\n七. 数据库设计 1. 数据库设计的一般定义 数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。\n2. 数据库设计的特点 数据库建设的基本规律：\n三分技术，七分管理，十二分基础数据\n结构（数据）设计和行为（处理）设计相结合。\n3. 数据库设计的步骤 需求分析：明确用户的需求，确定系统边界，生成数据字典和用户需求规格说明书 概念结构设计：概念模型-ER图 逻辑结构设计：ER转换为关系模型，根据范式规范理论对其进行优化，设计用户子模式 物理结构设计：关系模式选择存取方法、设计关系、索引等数据库文件的物理存储结构，确定数据库的存储结构 数据库实施：实际建立数据库结构、试运行、装入数据 数据库运行和维护 数据库的维护工作包含以下几个方面：\n数据库的转储和恢复\n数据库的安全性、完整性控制\n数据库性能的监督、分析和改造\n数据库的重组织与重构造\n八. 数据库编程 1.嵌入式SQL与主语言之间的通信 SQL向主语言传递执行状态信息，主要通过SQL通信区实现 主语言向SQL提供参数，主要通过主变量实现 将SQL语句查询数据库的结果交还给主语言处理，主要用主变量和游标实现 SQL通信区 SQL语句执行后的执行状态信息将送到SQL通信区中，应用程序从中取出这些信息，据此决定接下来指定的语句\n使用EXEC SQL INCLUDE SQLCA加以定义\n主变量 SQL语句中使用的主语言程序变量简称为主变量（即SQL使用主语言的变量）\n输入主变量由应用程序赋值，SQL引用\n输出主变量由SQL赋值或设置状态信息，返回应用程序\n一个主变量可以附带一个任选的指示变量（整型），用来指示所指的主变量的值或条件\n主变量名和指示变量名前面要加冒号（：）作为标识\n所有主变量和指示变量必须在SQL语句 BEGIN DECLARE SECTION 和 END DECLARE SECTION之间进行说明\n游标 一条SQL可能产生多条记录，而主语言面向记录的，一组变量一次只能存放一条记录，因此引入游标来协调这两种不同的处理方法，可以看作一个数据缓冲区，用来存放SQL语句的执行结果，每个游标区都有自己的名字\n建立连接 建立连接的嵌入式SQL语句为：\nEXEC SQL CONNECT TO target [AS connection-name] [USER user-name]；\ntarget就是要连接的数据库服务器，connection-name时可选的连接名\n关闭连接 EXEC SQL DISCONNECT {CONNECTION}\n2. 游标相关 不用游标的SQL语句 查询结果为单条记录的SELECT语句 非CURRENT形式的增删改语句 使用游标的SQL语句 查询结果为多条记录的SELECT语句 CURRENT形式的UPDATE和DELETE语句 3. 动态SQL 使用SQL语句主变量 程序的主变量包含的内容就是SQL语句的内容，这样的变量即为SQL语句主变量\n可以进行动态SQL语句的执行，就是执行这种包含在变量中的SQL语句\n动态参数 动态参数是SQL语句中的可变元素，使用参数符号（？）表示该位置的数据在运行时设定\n4. 过程化SQL 基本的SQL语句是高度非过程化的语言，过程化SQL是对SQL的扩展，使其增加了过程化语句功能。过程化SQL程序的基本结构是块，所有的过程化SQL程序都是由块者组成的，块之间可以相互嵌套，每个块完成一个逻辑操作。\n常量变量的定义 变量定义\n变量名 数据类型:=初值\n常量定义\n常量名 数据类型 CONSTANT:=常量表达式\n赋值语句\n变量名:=表达式\n流程控制 条件控制语句和循环控制语句\nIF condition THEN\n​\txxxxx\nEND IF；\nIF condition THEN\n​\txxxxx\nELSE\n​\txxxxx\nEND IF；\nLOOP\n​\txxxxx\nEND LOOP；\nWHILE condition LOOP\n​\txxxxx\nEND LOOP；\nFOR count IN [REVERSE] bound1..bound2 LOOP\n​\txxxxx\nEND LOOP;\n5.存储过程和函数 过程化的SQL块有两种类型，命名块和匿名块\n匿名块每次执行都要编译，不能被存储到数据库中，也不能在其它过程化SQL块中被调用。\n函数和过程都是命名块，编译完成后保存在数据库中，也成为持久性存储模块。\n存储过程优点 提供了在服务器端快速执行SQL语句的有效途径\n降低了客户机和服务器之间的通信量\n方便实施企业规则\n存储过程的定义 CREATE OR REPLACE PROCEDURE 过程名([参数1，参数2]) AS 过程化SQL块 存储过程的执行 CALL PROCEDURE 过程名（[参数1，参数2]）\n存储过程的修改 ALTER PROCEDURE 过程名1 RENAME TO 过程名2\n函数 和过程类似，定义有所区别，将PROCEDURE换成FUNCTION即可\n定义如下：\nCREATE OR REPLACE FUNCTION 函数名([参数]) RETURNS 类型 九、关系查询处理和查询优化 1. 查询处理步骤 查询分析 对查询语句进行扫描、词法分析和语法分析\n查询检查 对合法的查询语句进行语义检查\n这时候的完整性检查时初步的、静态的检查，检查通过后便把SQL查询语句转换为内部表示，即等价的关系代数表达式，一般用查询树或者语法分析树来表示拓展的关系代数表达式。\n查询优化 物理优化：是指存取路径和底层操作的算法选择，选择的依据可以是基于规则的，也可以是基于代价的，还可以是基于语义的\n代数优化：关系代数表达式的优化，按照一定规则进行等价变换\n查询执行 由代码生成器生成执行查询计划的代码，然后加以执行返回结果\n2. 查询操作的算法示例 选择操作 全表扫描算法 索引扫描算法 连接操作 嵌套循环算法 排序-合并算法：排完序之后再循环扫描，扫描到不一样的元素就跳下一个 索引连接算法：一个表建立索引，另一个表按照索引去连接 hash join算法：hash作为索引，开桶放元组，另一个表查桶并做链接 3. 代数优化 4. 物理优化 十.数据库恢复技术 1. 事务 定义 事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位\n一个事务可以是一个SQL语句，一组SQL语句，或者整个程序。一般来说一个程序包含多个事务。\n事务是恢复的基本单位，也是并发控制的基本单位。\n相关SQL语句 开始语句：BEGIN TRANSACTION\n结束语句：COMMIT 表示提交事务的所有操作 或者 ROLLBACK 表示回滚，即事务运行中发生了某种故障，需要对已经完成的操作进行撤销，回滚到事务的开始状态。\n2. 事务的4个特性 原子性 一个事务要么全做、要么全部都不做\n一致性 事务执行的记过必须一致，如果一个事务被迫中断，即事务中的一些操作做了，剩下的还没做，且做了对数据库造成的修改已经存入数据库的化，就会导致数据库处于不一致的状态。因此事务要么全做要么全不做，一致性与原子性密切相关\n隔离性 一个事务的执行不能被其他事务干扰\n持续性（永久性） 一个事务一旦提交，他对数据库中的数据改变应该是永久性的\n3. 数据库系统的故障种类 事务内部的故障 有的是可以通过事务程序本身发现的而直接进行ROLLBACK的，有的是非预期的 事务故障的情况下，数据库可能处于不正确的状态，恢复程序要在不影响其它事务运行的情况下强行回滚该事务，撤销该事务造成的修改，这类恢复操作成为UNDO（事务撤销）。\n系统故障 系统停止运转的任何事件，使得系统要重新启动（硬件错误，操作系统故障，DBMS代码错误，断电等）\n系统故障的情况下，在系统重新启动后，恢复子系统除了要撤销未完成的事务之外，还要REDO（事务重做）已提交的事务（但数据还在缓冲区没有被写入到数据库之类的）\n介值故障 就是硬故障，损毁之类的\n计算机病毒 4. 恢复技术的实现 恢复机制涉及的两个关键问题：如何建立冗余数据 如何利用冗余数据进行数据库的恢复\n恢复的基本原理：利用存储在后备副本、日志文件和数据库镜像中的冗余数据来重建数据库\n数据转储 DBA定期将整个数据库复制到磁带、磁盘或者其它存储介质上保存起来，这些备用数据被称为后备副本或者后援副本。重新装入副本即可恢复，但只能恢复到存储时的状态，想要恢复到故障发生的状态还需要REDO转储后的所有更新事务。\n分为：静态转储（在系统中无运行事务时进行）、动态转储（转储期间允许对数据库进行存取和修改）\n也可分为：海量转储、增量转储\n登记日志文件 日志文件是用来记录事务对数据库的更新操作的文件，有两种格式：以记录为单位、以数据块为单位\n以记录为单位的日志文件：\n登记各个事务的开始（BEGIN TRANSACTION）和各个事务的结束（COMMIT/ROLLBACK）、各个事务的所有更新操作。\n日志记录的内容：事务标识（哪一个事务）、操作类型（增删改）、操作对象（记录内部标识）、更新前数据的旧值、更新后数据的新值\n以数据块为单位的日志文件：\n日志记录的内容：事务标识、被更新的数据块\n日志文件的作用：\n事务故障恢复和系统故障恢复必须使用日志文件 在动态转储方式中必须建立日志文件，后备副本和日志文件结合（可以进行介质故障恢复）才能够有效恢复数据库 静态转储方式也可以建立日志文件，首先转储完后登记日志文件，在恢复时首先回到转储完的结果，再REDO日志文件中已经完成的事务，尚未完成的进行UNDO即可实现恢复。 登记日志文件的原则：\n登记的次序严格按并发事务执行的时间顺序 必须先写日志文件，后写数据库（防止写了数据库后日志文件未写入而导致该部分内容丢失） 5. 恢复策略 事务故障的恢复 由系统自动完成，对用户透明，利用日志文件UNDO此事务对数据库进行的修改\n系统故障的恢复 由系统重新启动时自动完成，不需要用户的干预：UNDO故障时未完成的事务，REDO已完成的事务\n正向扫描，有COMMIT的就表示已完成，放到REDO-LIST中，反之放到撤掉队列UNDO-LIST\n介质故障的恢复 恢复方法是重装数据库+重做已完成的事务\n首先装入最新的数据库后备副本，使数据库恢复到最近一次转储的一致性状态，对于动态转储的还需要装入从转储开始的日志文件副本才能将数据库恢复到一致性状态。\n其次装入相应的日志文件副本，通过REDO已完成，UNDO未完成的方法进行恢复\n6. 具有检查点的恢复技术 在日志文件中增加了检查点记录：在检查点之前的事务已经做完的了的不需要重做，如图即可。\n检查点的记录内容 建立检查点时期所有正在执行的事务清单\n这些事务最近一个日志记录的地址\n动态维护日志文件的方式是：周期性地执行建立检查点、保存数据库状态的操作。\n检查点记录步骤 将当前日志缓冲区中的所有日志记录写到磁盘的日志文件上。 在日志文件中写入一个检查点记录 在当前数据缓冲区中的所有数据记录写入磁盘的数据库中（保证如果一个事务在检查点之前提交，则T对数据库所做的修改一定会都写入到数据库中） 把检查点记录在日志文件中的地址写入一个重新开始文件 检查点恢复步骤 重新开始文件中找到最后一个检查点记录在日志文件中的地址 拿到该记录点中记录的所有正在执行的事务清单 首先放到UNDO-LIST中 从检查点开始正向扫描日志文件 有新开始的事务T就放到UNDO中 有提交的事务就把它从UNDO放到REDO中 7. 数据库镜像 自动把整个数据库或者其中的关键数据复制到另一个磁盘上，保证数据库和镜像一致性\n没有故障发生时还可以用于并发操作。\n十一. 并发控制 事务是并发控制的基本单位\n1. 数据不一致性 丢失修改：两个事务读入同一数据并修改，T2的提交破坏了T1提交的结果，导致T1的修改被丢失 不可重复读：T1读取数据后，T2执行更新操作，导致T1无法再现前一次读取结果。 读”脏“数据：T1修改某一数据后T2读，但是T1回滚了数据，导致T2读脏 并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。\n并发控制的主要技术有封锁、时间戳、乐观控制法、多版本并发控制等。\n2. 封锁 基本的封锁类型有两种：排他锁（X锁，写锁）和共享锁（S锁，读锁）\n加了X锁后其它事务不能再对对其加任何类型的锁，加了S锁后只能够读但不能修改，也不能再让别的事务加X锁。\n3. 封锁协议 一级封锁协议 T再修改R之前先对其加X锁，直到事务结束再释放锁\n二级封锁协议 在一级封锁协议基础上增加事务T在读取R之前必须加S锁，读完后可立即释放S锁\n三级封锁协议 读R时加S锁，等到事务结束才释放\n解决了”不可重复读“问题，因为如果当读完之后立马放锁，在事务期间别的事务可能会进行数据的修改，导致下一次读取时读不到原有的数据。\n4. 死锁 死锁预防 一次封锁法（对所有要使用的数据进行加锁）、顺序封锁法（对数据对象规定一个封锁顺序，所有事务按照顺序封锁）\nDBMS在解决死锁的问题上普遍采用的是诊断并解除死锁方法\n死锁诊断与解除 超时法：如果一个事务的等待事件超过了规定的时限就认为发生了死锁，可能误判或者不能及时发现 等待图法，构建事务等待图（节点表示运行的事务，边表示事务等待的情况）存在回路则表示出现了死锁，选择一个处理死锁代价最小的事务进行UNDO操作，释放该事务所持有的所有锁。 5. 可串行化调度 多个事务并发执行的结果=这些事务按照某种次序串行执行的结果，即为可串行化。\n一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。\n如何进行可串行化的判断？\n冲突可串行化调度 冲突操作：不同事务对同一个数据的读写操作和写写操作\n不同事务的冲突操作和同一事务的两个操作时不能进行交换的\n通过交换两个事务不冲突操作的次序得到一个串行的调度，则称当前调度为冲突可串行化的调度。\n冲突可串行化调度一定为可串行化的调度，反之不一定。\nSc=R1(A)W1(A)R2(A)W2(A)R1(B)W1(B)R2(B)W2(B)\n交换W2(a)和R1(B)W1(B)\n=R1(A)W1(A)R2(A)R1(B)W1(B)W2(A)R2(B)W2(B)\n交换R2(A)和R1(B)W1(B)\n=R1(A)W1(A)R1(B)W1(B)R2(A)W2(A)R2(B)W2(B)\n变为串行调度T1和T2了，则表示原Sc是冲突可串行化调度。\n6. 两端锁协议（2PL） 所有事务必须分为两个阶段对数据项加锁和解锁\n获得封锁（拓展阶段）：在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁。 释放封锁（收缩阶段）：在释放一个封锁之后，事务不再申请和获得其他任何封锁 若并发执行的所有事务均遵守2PL，则这些事务对任何并发调度策略都是可串行化的。\n7. 封锁的粒度 封锁对象的大小被称为封锁粒度。\n封锁粒度与系统的并发度和并发控制的开销密切相关。\n一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法被称为多粒度封锁。\n多粒度树。\n多粒度封锁 允许多粒度树上的每一个节点独立的加锁。对一个节点加锁意味着这个节点的所有子节点也被加上了同类型的锁。\n显示封锁：直接加到数据对象上的锁\n隐式封锁：由于其上级节点加锁而导致该数据对象加上了锁。\n显示隐式封锁都要进行检查\n意向锁 含义：如果对一个节点加意向锁，则说明该节点的下层节点正在被加锁，对任意一个节点加锁时，必须先对它的上层节点加意向锁。\n例如：对任一元组加锁时，必须对他所在的数据库和关系加意向锁。\n意向锁包含：意向共享锁IS、意向排他锁IX、共享意向排他锁SIX。\nIS锁：如果对一个节点加了IS锁，表示它的后裔节点（意向）加S锁\nIX锁：如果对一个节点加了IX锁，表示它的后裔节点（意向）加X锁\nSIX锁：如果对一个数据对象加了SIX锁，表示对它加了S锁，再加了IX锁。例如对某个表加了SIX锁，表示该事务要读整个表，故加了S锁，同时会对个别元组进行更新操作，即子节点意向加X锁，故对表要加IX锁。\n任意事务T要对一个数据对象加锁，必须对他的上层节点加意向锁，申请封锁应该是按照自上而下的顺序进行，解锁应当自下而上。\n"},{"section":"Blog","slug":"/en/blog/software-engineering/","title":"【课程笔记】软件工程","description":"this is meta description","date":"September 25, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"219\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"软件工程","content":"1. 软件工程概述 1.1 软件的本质 软件是：\n（1）指令的集合（计算机程序），通过执行这些指令可以满足预期的特性、功能和性能需求；\n（2）数据结构，使得程序可以合理利用信息；\n（3）软件描述信息，它以硬拷贝和虚拟形式存在，用来描述程序的操作和使用。\n补充：软件是逻辑的而非物理的系统元素，软件不会“磨损”，但是软件退化是存在的，不断的变更时软件退化的根本原因。\n1.2 软件工程学科 定义 将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件。\n软件工程是一种层次化的技术。\n根本特性 可靠性、运行效率、经济性、工程化\n层次结构 自顶向下为工具、方法、过程、质量关注点。\n软件工程六大目标 达到要求的软件功能、取得较好的软件性能、开发出高质量的软件、付出较低的开发成本 、需要较低的维护费用 、能按时完成开发工作并及时交付使用\n软件工程七大原则 用分阶段的生命周期计划严格管理、坚持阶段评审、严格实施产品控制、采用现代的程序设计技术、结果应该能明确审查、开发成员应该少而精、承认不断改进软件工程实践的必要性。\n软件工程实践七大原则 Hooker的概括性原则\n存在价值、保持简洁KIS、保持愿景、关注使用者、面向未来、提前计划复用、认真思考\n软件工程实践四个精髓 理解问题、策划解决方案、实施计划、测试结果的正确性\n理解问题：谁将从问题的解决中获益？有哪些是未知的？哪些数据、功能和特征是解决问题必须的？问题可以划分吗？可以图形化描述吗？可以建立分析模型吗？ 策划解决方案：以前曾经见过类似问题吗?（可以识别一些模式？）类似问题是否解决过？可以定义子问题吗？如果可以，子问题是否已有解决方案？能用一种可以很快实现的方式来描述解决方案吗?能构建出设计模型吗？ 实施计划：解决方案和计划一致吗？解决方案的每个组成部分是否可以证明正确？ 测试结果：能够测试解决方案的每个部分？解决方案是否产生了与所需求的数据、功能和特征一致的结果?是否按照项目利益相关者的需求进行了确认？ 诞生的根本原因 软件工程诞生的根本原因：软件危机\n表现形式包括：\n软件开发进度难以预测 软件开发成本难以控制 用户对产品功能难以满⾜ 软件产品质量⽆法保证 软件产品难以维护 1.3 软件过程 定义 软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。\n活动：主要实现宽泛的目标（如与利益相关者进行沟通），与应用领域、项目大小、结果复杂性之类的没有关系\n动作：例如体系结构设计，包含主要工作产品生产过程中的一系列任务\n任务：关注小而明确的目标，能够生产实际产品\n过程框架 过程框架定义了若干个框架活动：沟通、策划、建模、构建、部署。\n框架活动可以不断迭代应用，每次项目迭代都会产生一个软件增量。\n普适性活动 软件工程过程框架活动由很多普适性活动来补充：软件项目跟踪和控制、风险管理、软件质量保证、技术评审、测量、软件配置管理、可复用性管理、工作产品的准备和生产。\n通用的框架活动和普适性活动构成了软件工程工作的体系结构轮廓。\n1.4 相关思考 软件工程的意义？\n软件工程是指导计算机软件开发和维护的工程学科，采用工程的原理，技术、概念和方法来开发和维护软件，把经过实践检验的正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并维护它。\n如何理解“工程化软件开发”与到目前为止大家所熟悉的“编程”之间的区别？\n概括过程框架。当谈及框架活动适用于所有的项目时，是否意味着对于不同规模和复杂度的项目可应用相同的工作任务？请解释\n普适性活动存在于整个软件过程中，他们均匀分布在软件过程中，还是集中在某个或者某些框架活动中？\n2. 软件过程 软件过程定义为一个创建高质量软件所需要完成的活动、动作和任务的框架。（过程框架）\n2.1 通用过程模型 框架活动 沟通、策划、建模、构建以及部署（在过程框架中定义的）\n普适性活动 软件项目跟踪和控制、风险管理、软件质量保证、技术评审、测量、软件配置管理、可复用性管理、工作产品的准备和生产\n过程流 过程流描述了在执行顺序和执行时间上如何组织框架中的活动、动作和任务。\n线性过程流：从沟通到部署顺序执行五个框架活动。\n迭代过程流：在执行下一个活动之前重复执行之前的一个或者多个活动\n演化过程流：采用循环的方式执行各个活动，每次循环都能产生更为完善的软件版本（增量交付）。\n并行过程流：将一个或者多个活动与其他活动并行（例如软件不同方面的构建活动可以并行执行）\n任务集 每一个软件工程动作（例如需求获取，一种与沟通活动相关的动作）都是由若干个任务集构成，而每一个任务集都由软件工程工作任务、相关工作产品、质量保证点和项目里程碑组成。\n（要适合开发团队特点，因此软件工程动作可以根据项目的特定需要和团队特点进行调整）\n2.2 惯用过程模型 每一个模型都对框架活动有不同的侧重，并且定义了不同的过程流以不同的方式执行每一个框架活动（以及软件动作和任务）\n瀑布模型 线性顺序模型，是一个系统的、顺序的软件开发方法。\n首先清晰地了解要解决问题的需求，然后顺序开展框架活动，最终交付完整的软件产品，并开展后续的技术支持和维护\n问题：1.实际项目很少完全遵循瀑布模型提出的顺序；2.客户难以在一开始就完整、准确地描述需求；3.客户必须要有耐心，因为只有在接近到项目尾声的时候，才能得到可执行的程序；4.在评审可运行程序之前，可能不会检测到重大错误。\n原型开发过程模型 当客户只定义了软件的一些基本任务，但是没有详细定义功能和特征需求。（需求很模糊的时候）\n将开发过程分成若干原型增量，每次增量选择一部分需求（最关键、最核心的需求）作为交付目标，产出一个可执行的中间产品。\n每个增量产出的中间产品可以提供给客户或用户，用于发现问题或者潜在的新需求。\n（原型是一个可实地运行的模型,有正式产品的主要特征,但不是全部特征。软件原型是软件系统的最初版本,以最少的费用,最短的时间开发出的、以反映最后软件的主要特征的系统。）\n演化过程模型 也称为螺旋模型，是风险驱动的周期性迭代，结合了原型迭代性质和瀑布模型的可控性和系统性的特点，采用迭代或者增量的方式开发高质量软件。\n螺旋模型被分割称一系列由软件工程团队定义的框架活动。\n螺旋模型将软件开发为一系列演进版本，在早期的迭代中，软件可能是一个理论模型或者是原型，在后来的迭代中会产生一系列逐渐完整的系统版本。\n包括：抛弃式原型和增量式原型\n主要问题：难以判断螺旋演进何时结束\n统一过程模型 统一过程（UP）建立了迭代的、增量的过程流，提供了演进的特征。\nUML——统一建模语言包含大量用于面向对象系统建模和开发的符号，作为需求模型和设计模型的表示方法。\n包括：\n​\t起始阶段：包含客户沟通和策划活动，该阶段识别基本的业务需求，并用用例初步描述每一类用户所需要的主要特征和功能。\n​\t细化阶段：包括沟通和通用过程模型的建模活动。细化拓展了初始阶段定义的用例，创建了用例模型、分析模型、设计模型、实现模型、部署模型。\n​\t构建阶段：和通用软件过程中的构建活动相同。软件增量所要求的必须具备的特征和功能在源代码中实现。随着构建的实现需要对构件设计并实施单元测试。\n​\t转换阶段：包括通用软件过程中的构建活动后半期和部署活动的第一部分。软件被提交给最终用户进行Beta测试，用户反馈报告缺陷以及必要的变更。在转换阶段结束时，软件增量成为可用的发布版本。\n​\t生产阶段：和通用软件过程中的部署活动一致。对软件进行监控，提供运行环境的支持。\n有可能在构建、转换和生产阶段的同时，下一个软件增量的工作已经开始了，即五个UP阶段不一定顺序执行，而是阶段性的并发进行。\n2.3 相关思考 描述三个适用于原型模型以及三个瀑布模型的软件项目\n原型：用户界面，需求不明确的项目，用户参与的项目\n瀑布模型：稳定需求和规范明确的项目，对项目整体和成本高度控制的项目，不需要频繁变更的项目\n可以合用几个过程模型吗？如果可以，举例说明\n假设有一个大型软件项目，其中一部分需求相对稳定而另一部分需求可能会频繁变化。在这种情况下，可以考虑将项目分为两个主要部分：混用演化（敏捷过程模型）与瀑布。\n统一过程和UML是同一概念 ？\n开发质量足够好的软件的优点和缺点是什么？也就是说当我们追求开发速度胜过产品质量的时候会产生什么后果？\n3. 敏捷和敏捷过程 3.1 敏捷概念 普遍存在的变更是敏捷的基本动力，敏捷不仅是有效的响应变更，还是敏捷开发宣言中提及的哲学理念。\n强调可运行软件的快速交付而不那么看重中间产品。\n敏捷可以应用于任何软件过程。\n3.2 敏捷过程 敏捷过程必须具有可适应性（对于快速变更的项目和技术条件，以解决不可预测性的过程）\n敏捷软件过程必须增量式地适应。应该使用增量式开发策略，在很短的时间间隔内交付软件增量（可执行原型或者部分实现的可运行系统）来适应变更（不可预测的）的步伐。\n3.3 敏捷开发宣言 敏捷软件开发宣言 个体和互动 高于 流程和工具 工作的软件 高于 详尽的文档 客户合作 高于 合同谈判 响应变化 高于 遵循计划\n也就是说，尽管右项有其价值，我们更重视左项的价值。\n敏捷软件的十二条原则 敏捷宣言遵循的原则 (agilemanifesto.org) 3.4 Scrum 基本概念 是一种敏捷过程模型，Scrum原则和敏捷宣言是一致的。过程由“需求、分析、设计、演化和交付”等框架性活动组成。\n每一个框架活动中，工作任务在相对较短的时间盒的期限内完成称为一个冲刺。\n组成 Scrum团队由产品负责人、Scrum master和一个小型（3~6人）开发团队组成。\nScrum开发的主要制品是：产品待定项、冲刺待定项和代码增量。\n开发将项目分解为一系列称为冲刺的增量原型开发周期，每个周期2~4周。\n产品待定项：产品需求或特征的优先级列表，可为客户提供业务价值，在产品负责人同意且开发团队认可后，可以随时将项目添加到待定项中。（可以理解成：对于客户来说的一些待实现的、列入计划（在待定项中了）的功能）\n冲刺待定项：产品团队选择的产品待定项的子集，在当前进行的冲刺期间作为代码增量完成。增量是以前冲刺完成的所有产品待定项和在当前冲刺中要完成的所有待定项的并集。\n会议 冲刺规划会议：在每个冲刺开始之前，排序产品待定项，在冲刺待定项中选择具体项目，确定开发目标，确定在分配的时间盒中可以作为增量交付哪些内容。\n每日Scrum会议：自从上次团队例会后做了什么？遇到什么苦难？下次例会前计划做些什么？\n冲刺评审会议：演示冲刺期间完成的代码增量，演示可能不包含所有计划的功能，但是要演示冲刺期间完成的功能，负责人决定接受不接受该增量。\n冲刺回顾：考虑：冲刺中哪些方面进展顺利？哪些方面需要改进？下一个冲刺中致力于改进什么？\n基本特征 开发活动由工作单元（packets）组成 测试和文档编制贯穿始终 发生于一个过程模式的工作任务被称为一个冲刺，来源于待定项中定义的需求 例会时间很短 在规定时间内将演示软件交付给用户 3.5 XP框架 极限编程包括策划、设计、编码和测试四个框架活动的规则和时间。\n策划 策划活动从倾听用户故事开始，描述待开发软件所需的输出、特征以及功能。（需求收集活动）\n每个用户故事由客户书写并且置于一张索引卡上，客户根据对应特征或功能的综合业务价值标明故事的权值（优先级）。新故事可以在任何时候书写。\n用户和XP团队共同决定如何将故事分组，并置于XP团队将要开发的下一个发布版本（软件增量）中。\n排序有待开发的故事：\n所有故事将尽快完成 具有最高权值的故事将移到进度表的前面并首先实现 高风险故事将移到进度表的前面并首先实现 项目速度是第一个发布版本中实现的用户故事个数。用于评估后续发布版本的日期和进度安排（用来适当修改计划的）\n设计 XP设计严格遵守KIS（保持简洁）原则\nXP鼓励使用CRC卡（类-职责-协作者）来确定和组织当前软件增量相关的面向对象的类，也是作为XP过程一部分的唯一设计工作产品。\n编码 XP建议不要直接开始编码，而是开发系列测试单元用于检验软件增量中发布的所有故事。一旦编码完成，就可以立即完成单元测试，从而向开发者提供及时反馈。\n结对编程：两个人面对同一台计算机共同为一个故事开发代码，提供了实时解决问题和实时质量保证的机制。\n测试 所建立的单元测试应当使用一个可以自动实施的框架。\nXP验收测试也称为客户测试。\n3.6 看板法 基本概念 Kanban是一种精益方法学（精益思想认为，应该从是否增加了价值的角度来评价一个活动是否是浪费，即消除浪费，做有价值的工作），描述改进过程或工作流的方法，专注于变更管理和服务交付。\n​\t变更管理：定义了将请求的变更集成到基于软件的系统过程。\n​\t服务交付：更专注于了解客户需求和期望。\n核心实践 使用看板图可视化工作流。看板图按列组织，分别表示软件功能的每个元素的发展阶段。团队会随着项目进展将\u0026quot;要做\u0026quot;推进到“正在进行”，再推进到“已完成”。 在给定的时间内要限制当下工作（WIP）负荷。鼓励开发人员在进行另一项工作前完成当前任务。以缩短交付时间，提高工作质量，提高团队向利益相关者频繁交付软件功能的能力。 通过当前价值流、分析停滞位置、定义变更以及实施变更来管理工作流，以减少浪费。 明确的过程策略（写下选择工作项目的理由，定义“完成”的标准） 通过创建反馈循环聚焦持续改进，基于过程数据引入变更。 过程变更要相互合作。 会议 问自己：每一个项目在看板中，现在在哪里？从哪里来？到哪里去？\n和Scrum会议类似，每日看板站立会议的基础是“走板“任务，找出正在处理的”板“中遗漏的项目并适当添加。\n每周回顾会议期间，检查过程测量。\n3.7 开发运维一体化DevOps 将开发和运维相结合。涉及阶段（会持续循环）：持续开发、持续测试、持续集成、持续部署、持续监控。\n**持续开发：**将软件可交付成果分解到多次冲刺会议中开发\n持续测试：自动化测试工具的使用，可以同时测试多个代码增量\n持续集成：将具有新功能的代码段添加到现有的代码段和运行环境中，对其检查以保证后续部署没有错误。\n持续部署：将集成代码部署到生产环境，\n持续监控：运维人员通过监控软件在生产环境中的性能来主动查找问题（尽可能地早于用户发现问题）以提高软件质量。\nDevOps通过快速响应客户的需求或希望的变化来提高用户体验。\n这样的精益方法能够减少重复劳动、转向更高业务价值的活动。\n3.8 相关思考 什么样的项目适合于采用计划驱动的开发方法？什么样的项目适合于采用敏捷开发方法？\n从敏捷到开发运维一体化体现了现代软件开发什么样的特点？\n软件变更的原因？从“过程”和“方法”两方面分别讲下如何应对变更？\n从敏捷适应变更（不可预测的）的角度来说？ P39中小结\nP29中敏捷产生的前提：市场情况变化迅速等\nXP模型在处理增量原型方面与螺旋模型有何不同？\n4. 理解需求 用户需求：用户的期望，希望系统向用户提供什么样的服务以及满足哪些约束\n系统需求：协商后确定的：系统所需要提供的服务、实现的功能、质量以及约束\n软件需求：在系统需求中关于待开发的软件的功能、质量及约束等方面的描述\n用户需求经过细化和商讨确定一系列系统需求。\n系统需求通过不断分解和精化步骤来确定软件与其它系统元素的职责分配，从而确定软件需求。\n4.1 需求工程 需求工程就是致力于不断理解需求的大量任务和技术。\n起始：提出一系列问题\n获取：征求各利益相关者的需求\n精化：开发一个需求模型，来说明软件的功能、特征和信息的各个方面\n协商：协商形成一个能令开发人员和客户都满意的交付软件\n规格说明：可以是一份写好的文档、一套模型、一个形式化的数学模型、一个原型、一个使用场景\n确认：对需求工程的工作产品进行质量评估，通过一组检查机制来发现一些错误、需要进一步解释的、丢失信息、不一致性、冲突需求\n需求管理：在项目进程中标识、控制和追踪需求以及需求变更。\n软件需求规格说明书 SRS一般至少包括下面三个主要的内容：功能特征描述、系统接口描述、质量特征描述\n主要目标 在现有的系统上下文环境中建立并实现愿景。\n愿景：给出了关于软件系统需要实现的目标的主观愿望\n上下文环境：给出了目标实现可以利用的客观便利条件或必须考虑的客观约束\n4.2 建立根基 确定利益相关者：”你认为我还应该和谁谈？“ 识别多重观点：利益相关者多了导致需求角度不同，需要把所有信息分类，消除不一致性或者矛盾的需求描述。 协同合作：客户之间、团队之间、客户与团队之间（利益需求的矛盾消除） 首次提问：谁请求的？谁使用的？收益如何？还需要其它资源？ 非功能需求：质量属性、性能属性、安全属性。例如可用性、可测性、安全性之类的。 可追溯性：软件工程工作产品间记录的文档化链接。 4.3 获取需求 需求获取是将问题求解、细化、协商和规格说明等元素结合在一起。\n协作收集需求 会议由软件工程师和其它的共利益者共同举办，拟定一个会议议程，由一个主持人控制会议。\n为了：标识问题、提出解决方案的要素、协商不同的方法、确定一套解决需求问题的初级方案。\n​\t需求分解与精化\n​\t愿景分解：针对愿景提问“如何才能实现”，识别一组更加具体的目标，这些目标的达成可以确保愿景的实现\n​\t目标分解：得到的目标又可以进一步被分解成下一级子目标，方式同样是针对目标提问“如何才能实现”\n​\t方式：与分解、或分解，表示子目标与父目标之间的关系。\n​\t•目标分解和精化过程不断迭代进行，直至得到可明确指导设计和实现的详细需求，其中伴随着问题和解决方案的不断迭代转换\n​\t需求优先级排序\n​\t低优先级需求往往依赖于一些高优先级的需求\n使用场景 收集需求时，系统功能和特性的整体愿景开始具体化，为了将其转移到技术化的软件中，可以创建一系列场景——场景可以识别将要构建系统的使用线索，通常被称为用例。\n站在参与者的视角分析与待开发系统的交互过程、关注于业务实体和实体之间关系的类分析、关注于系统响应外部事件的方式的行为分析也都有一些应用\n获取工作产品 通常结合自然语言描述与形式化的模型描述（模型具有规范性和精确性，但在普适性灵活性和易用性存在不足）。\n产品可以包括：\n要求和可行性说明 系统技术环节说明 需求列表 一系列使用场景 4.4 开发用例 确定故事中的参与者（使用系统的各类人员或者设备，是任何与系统或产品通信的事务，且对系统本身来说是外部的） 明确交互操作，具有相同目标且交互过程相似的一组场景可以被组织为一个用例。需要进行识别用例，判断是否满足：过程明确且完整、可独立完成且不可再分、对于用户有价值 用例描述：UML用例图（概览描述）、UML泳道图（用例详细描述）、UML活动图（用例详细描述）。 用例详细描述还可以通过自然语言：用例名称、参与者、目标、前置条件、触发条件、主场景、其他场景、异常场景、发生频率。 4.5 构建分析模型 分析模型的元素 ​\t基于场景：用例、更精细的基于模板的用例、用例图、描述\n​\t基于类：UML类图\n​\t行为元素：状态图、顺序图\n分析模式 分析模式在特定应用领域内提供一些解决方案（如类、功能、行为）的模板。\n5. 需求建模 使用文字或者图表综合的形式来描绘需求。\n5.1 建模方法 ​\t原则：\n问题的信息域必须得到表达和理解； 必须定义软件执行的功能； 必须表示软件的行为（作为外部事件的结果） 描述信息、功能和行为的模型必须以分层（或分级）的方式进行分割以揭示细节。 分析任务应从基本信息转向实现细节。 场景分析与描述 创建用例 使用：用例图、活动图、泳道图、自然语言描述 详细的自然语言描述的用例举例：\n类分析与描述 类包含一组所有对象或实体都具有的属性和操作。\n类之间存在多种不同类型的关系：继承（Inheritance）、聚合（Aggregation）、关联（Association）、依赖（Dependency）\n​\t识别分析类\n​\t选取名词（潜在类），分类：外部实体、事物、偶发事件或事件、角色、组织单元、场地、结构\n​\t考虑特征：保留信息、所需服务（一组可确认的操作）、多个属性、公共属性、公共操作、必要需求。P107\n​\t分析类的种类\n​\t实体类、边界类、控制类\n​\t边界类：与用户的接口（交互屏幕或报表之类的）\n​\t控制类：可以管理：实体类的创建与更新、对象集合间的复杂通信、数据交换的确认\n​\t呈现\n​\tUML类图、CRC（类-职责-协作者）\n行为分析与描述 行为：系统或其一部分响应外部的事件激励而执行一些动作，同时伴随自身状态的变化\n行为分析从系统本身而非场景分析中的外部参与者的角度了解到系统如何响应外部事件进行状态转换并执行各种动作的\n包含的基本内容：状态、事件、状态转换、动作\n顺序图、状态图\n5.2 相关思考 数据流图、E-R图、UML类图、UML用例图、UML活动图、UML顺序图、UML状态图\n6. 软件设计 软件设计是软件需求与实现代码之间的桥梁\n6.1 层次 数据/类设计\n体系结构设计\n组件接口设计\n组件（构建）级设计\n6.2 软件设计思想（概念） ​\t分解与抽象：\n​\t分解：将软件不断地分解为更细粒度的代码单元，例如从组件、模块到文件和类\n​\t抽象：忽略无关细节，只保留与当前问题相关的关键信息\n​\t（例如接口抽象使得我们可以针对接口进行编程而忽略内部数据结构、算法等实现细节）\n​\t数据抽象：对于目标对象的数据化抽象描述\n​\t过程抽象：对一系列过程性步骤和指令序列的整体抽象\n​\t软件体系结构：\n​\t大规模软件系统（特别是网络化软件系统）需要更高层的设计考虑\n​\t软件体系结构给出了软件系统的顶层设计（包括一组软件组件、它们的外部属性以及相互之间的关系）\n​\t充分体现了分解与抽象的基本原则\n​\t总体质量在很大程度上取决于体系结构设计\n​\t关注点分离：\n​\t关注点：软件系统中所实现的某种功能或特性，反映不同涉众所关注和关切的方面\n​\t关注点分离：将软件系统的整体需求分解为尽可能小的关注点并分解到不同的模块单元（例如模块、包、类、方法等）中实现\n​\t模块化划分就体现了关注点分离的思想。\n​\t存在问题：关注点散布（一个关注点散到多个模块单元中）和混杂（同一模块单元混杂了多个关注点）问题。\n​\t面向切面的编程（简称AOP）为这种横切关注点的封装提供了一种有效的手段\n​\t模块化\n​\t模块化：将整个产品或系统分解为大小合适、相对独立的模块\n​\t信息隐藏：\n​\t将实现细节隐藏在内部，仅通过受限的接口对外提供访问。\n​\t过度公开则可能会导致不必要的耦合。\n​\t重构\n​\t很多敏捷方法都建议进行重要的设计活动——重构。是实现所谓的演化式设计的一种重要手段。\n​\t推崇在增量和迭代化的特性实现过程中不断发现设计中的问题并通过重构不断进行改进。\n​\t重构为在不改变代码外在行为的前提下，对代码作出修改以改进程序的内部结构。\n​\t为了：提高软件的可维护性和可扩展性。\n​\t复用\n​\t不同层次：\n​\t源代码复制粘贴\n​\t软件库API调用\n​\t软件设计模式（需要结合具体问题需要进行实例化）\n​\t面向特定类型软件应用的软件框架（spring框架）\n6.3 面向对象软件设计 基本步骤：识别设计类、明确设计类职责和协作、细化设计类内部细节\n潜在设计类 ​\t来自问题域中的设计类、位于接口上的设计类、与基础设施相关的设计类（实现数据库访问之类的设计类）\n判断设计类合理性 明确职责与协作 ​\t关注点分离、高内聚低耦合\n细化内部细节 ​\t类属性需要细化的主要是访问修饰符、属性类型及初始值\n​\t方法需要细化的主要是访问修饰符、参数及类型、返回值类型、前置及后置条件\n​\t类内部需要用到的局部数据结构和算法\n设计描述 ​\tUML类图：描述面向对象的静态设计结构，包括类及类之间的静态关系\n​\tUML顺序图：特定场景中类与类之间的动态交互关系\n​\tUML状态图：通过状态转换的方式描述类的实例对象的行为\n​\tUML包图：以包的形式描述更大粒度的模块之间的静态结构关系\n​\tUML通信图：类的实例对象间关系的基础上描述对象间消息发送的顺序\n​\tUML活动图：描述由类方法调用构成的业务处理过程及算法流程\n其它内容 模块独立性\n高内聚、低耦合\n​\t内聚形态\n​\t功能内聚、层次内聚、通信内聚、顺序内聚、过程内聚、时间内聚、功用内聚\n​\t通信内聚：模块中仅包含访问同样一组数据的操作\n​\t耦合形态\n​\t内容耦合、共用耦合、控制耦合、印记耦合\n​\t内容耦合：消除内容耦合的主要手段是实现信息隐藏，提供接口等\n​\t共用耦合：考虑共享全局变量\n​\t控制耦合：某个方法需要根据实际情况进行调整，引入多态，设置抽象方法来消除控制耦合\n6.4 面向对象程序设计原则 单一职责原则 每个类、接口、方法都应该只具有单一的职责，强调的是类、接口、方法的内聚性\nJavaEE中的分层框架模式实际上体现了单一职责原则\n开闭原则 软件实体应当对扩展开放，对修改关闭。\n实现开闭原则的关键是抽象\n定义一个抽象层，只规定功能而不提供实现，实现通过定义具体类来完成（继承和多态）\n需求变化时不是通过修改抽象层来完成，而是通过定义抽象层新实现完成了。\n例子：JavaEE多层模式下,可以定义业务、DAO接口，是和其他层对接的规范。可以增加不同的实现类，而不是去修改原来的实现类。\n里氏替换原则 子类对象可以出现在任何父类对象出现的地方\n里氏代换原则对如何良好继承提出了衡量依据\n里氏代换原则是使代码符合开闭原则的一个重要保证\n依赖倒置原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象\n其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合\n依赖倒置原则核心就是要面向接口编程\n例子：早期电脑所有硬件整合在一起，一个模块坏全部坏，现在的电脑依赖于插槽（规范），更换cpu、内存、卡等方便\n接口分离原则 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。\n例子：在车站售票窗口排队的人有买票的，有查开车信息，有退票的，不必排在同一窗口中。多开几窗口，每个窗不同功能，让不同需求的人排在不同窗口，可以节约时间和人力。\n迪米特法则 强调不要和“陌生人”说话，只与直接“朋友”交谈\n迪米特法则的初衷在于降低类之间的耦合\n外观模式和中介者模式都是迪米特法则的应用\n6.5 面向切面的编程AOP 面向切面的编程方法支持横切关注点解耦和模块化封装\n将散布出去的关注点进行整合封装\n开发人员在基本程序上定义连接点，相关工具自动将切面编织到对应的连接点上并形成最终的完整程序\n横切关注点单独以“切面”这种新引入的模块化机制来进行模块化封装和实现\n•切面（Aspect）：实现关注点的模块化单元\n•通知（Advice）：由切面所封装的、将插入到基本程序中指定地方执行的功能代码\n•连接点（Join point）：基本程序结构或者执行流上的一种可以明确定义的位置\n•编织（Weave）：将基本程序与切面集成到一起获得完整程序的过程\n6.6 设计模式 这些设计问题的具体形式有所差异，但可抽象为共性问题\n要素 名称：有意义的、能揭示设计模式目的的名称\n问题：关于设计模式所针对的问题域描述，解释了该模式何时适用\n解决方案：对于设计解决方案的描述。\n使用效果\n分类 创建型模式：与类的实例对象创建相关的设计模式，关注于对象创建过程的抽象和封装\n​\t工厂方法、抽象工厂、单例、建造者、原型\n结构型模式：与类和对象的结构组织相关的设计模式，关注于如何实现对象的组合\n​\t适配器、装饰器、代理、外观、桥接、组合、\n行为型模式：与类和对象之间的交互行为和通信相关的设计模式，关注于类和对象之间的交互关系和职责分配\n​\t策略、观察者、模板方法\n单例模式 一个类只允许有一个对象实例\n例如操作系统中的任务管理器和回收站、网站的计数器、金融交易的引擎、应用程序的日志引擎等\n解决：私有构造函数，静态实例对象，对外共有静态方法返回实例对象\n适配器模式 使用场景：一个类所需要的接口与另一个类所提供的接口不匹配，但功能相同或相近\n解决：额外引入的适配器类，继承了Adaptee从而具备了该类所实现的能力，同时实现了Target接口\n组合模式 客户端获得抽象组件对象的引用后可以直接调用其操作方法，而不用关心它是原子对象还是复合对象\n例如：在画图工具中的复合图形绘制中，抽象的组件对象是抽象图形，原子对象是基本图形（三角形、圆形等，可以有多个），复合对象是复合图形。可以按照抽象图形调用其操作（例如绘制、移动、删除），从而实现整个图形的操作，而不用关心其是一个原子图形还是复合图形\n策略模式 策略模式突出体现了面向对象设计的开闭原则。\n对算法策略进行封装，称为抽象算法策略，实现该抽象方法即可有具体的算法策略。使得算法策略的扩展变得更加容易，避免了通过多重选择语句选择不同的算法策略。\n观察者模式 观察者模式通过主题类与具体观察者类的解耦实现了对于具体观察者类扩展的支持，MVC？\n例如消息队列、事件驱动编程（Java中的Swing）\n7. 体系结构设计 体系结构设计从数据设计开始，并创建系统体系结构的一个或多个表示。然后在对多个可选体系结构风格或者模式分析的基础上，选择一个最符合顾客需求和质量基础的结构。\n7.1 “4+1”视图 逻辑视图 面向：分析师/设计师\n聚焦：结构\nUML类图、UML组件图\n实现视图 面向：开发人员\n聚焦：软件管理\nUML包图\n运行视图 面向：系统集成人员\n聚焦：性能、可伸缩性、吞吐量等\nUML顺序图\n部署视图 面向：安装部署人员\n聚焦：系统拓扑、交付、安装、通信\nUML部署图\n用例视图（+1） 面向：最终用户\n聚焦：功能\nUML用例图\n7.2 软件体系结构风格 风格？举例：\nC/S风格可以实现复杂的客户端逻辑并充分利用客户端计算机资源；\n​\t功能强大并针对特定操作系统专门开发的客户端软件\n​\t大部分业务逻辑可以在客户端实现，而服务器端可以相对简单甚至只提供数据库服务\nB/S风格依赖于用户计算机上所安装的浏览器来展现界面并实现用户交互\n层次化体系结构风格 每个层次都有明确的功能和职责划分，上层依赖于下层而下层则不能依赖于上层\n以数据为中心的体系结构 一种以数据为中心的体系结构风格\n以数据的形式存在的知识在中心知识库中被集中保存和管理，围绕知识库的一组软件组件通过共享知识库间接进行交互\n实现简单并且能够依托成熟的数据库系统实现大量数据的共享。\n但：当中心知识库数据量大到一定程度之后难以实现高效的数据访问和管理\n数据流体系结构 例如管道-过滤器模式\n即其中的组件是按照数据流进行组织\n组件间关系主要体现在输入输出数据流上，因此耦合相对较松\n人机交互性较强的软件系统，例如需要图形用户界面支持的系统，但适合于以数据传输和处理逻辑为主的系统（例如数据批处理系统）\n面向对象的体系结构 系统的构件封装了数据和必须用于该数据的操作，构件之间的通信和合作是通过信息传递实现的。\nMVC 模型：所有应用特定内容和处理逻辑\n视图：包含所有接口特定功能并能够显示终端用户所需的内容的操作逻辑\n控制器：管理对模型和视图的访问并协调数据流。\n分布式软件体系结构 CAP定理：对于同时存在数据读取（如读取商品数量）和更新（如更新商品数量）操作的分布式系统，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）三个属性无法同时被满足，即如果想满足其中两个那么剩下的一个必须被牺牲\nBASE原则：牺牲数据的强一致性来换取高可用性并在最后能实现最终一致性\n"},{"section":"Blog","slug":"/en/blog/svd/","title":"【泛学内容】奇异值(SVD)分解","description":"this is meta description","date":"July 2, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"数学相关, 泛学内容","tags":"线性代数, 奇异值分解, 特征值分解","content":"奇异值分解 一、特征值分解 必要条件 待分解矩阵$A_{n \\times n}$为方阵，同时具有n个线性无关的特征向量，可进行相似对角化（特征值分解）。\n定理内容 记特征值为$\\lambda_{1} \\le \\lambda_{2}\\le \u0026hellip; \\le \\lambda_{n}$，对应的n个线性无关的特征向量为$v_{1},v_{2},\u0026hellip;,v_{n}$，则存在正交矩阵$V$，满足以下式子。其中$V$为特征向量按列排列，且为正交矩阵，即$V=(v_{1},v_{2},\u0026hellip;,v_{n})$。\n$$ V^{-1}AV=V^{T}AV=\\Lambda = \\begin{pmatrix} \\lambda_{1} \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026hellip; \u0026amp; \\\\ \u0026amp; \u0026amp; \\lambda_{n} \\end{pmatrix} $$\n上式对$A$进行了相似对角化，通过可逆矩阵$V$来得到$A$的相似矩阵$\\Lambda$。也相当于为$A$进行了特殊的表达，即转化为$A=V\\Lambda V^{-1}$，从而将A这个线性变换转化为“旋转-缩放-旋转”的形式。\n简要分析 考虑到对于任何一个方阵$ A_{n \\times n }$，可以将其看作n维空间中的一个线性变换，它的一个特征向量$\\hat{v}$以及对应的特征值$\\lambda$，可以看作为在经过线性变换$A$后，特征向量$\\hat{v}$的方向并未发生改变，只是进行了缩放比为$\\lambda$的缩放。即满足$A \\hat{v} = \\lambda \\hat{v}$。\n若能够找到n组特征向量与特征值，且这n个特征向量相互线性无关，那么将这n个特征向量组成一个基则能够保证在该基之下，线性变换A能够与一个对角矩阵相似（即A在V基下的线性变换为一个对角阵）。具体原因在于：$A(v_{1},v_{2},\u0026hellip;,v_{n})= \\begin{pmatrix} \\lambda_{1} \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026hellip; \u0026amp; \\\\ \u0026amp; \u0026amp; \\lambda_{n} \\end{pmatrix} (v_{1},v_{2},\u0026hellip;,v_{n}) $。而对于基$V$，可以进行正交化，最终将矩阵$A$进行分解得到“正交阵-对角阵-正交阵”的形式，即将线性变换分解为“旋转-缩放-旋转”。（正交阵带来的正交变换不改变距离、夹角、内积等性质，即为旋转；对于对角阵，只对各基方向进行成比例缩放）\n二、奇异值分解 定义 将一个非零的$m \\times n$实矩阵$A$，$A \\in R^{m \\times n}$，表示为以下三个实矩阵的乘积形式的运算，即矩阵的因子分解。其中$U$时$m$阶正交矩阵，$V$时$n$阶正交矩阵，$\\Sigma$是由降序排序的非负的对角线元素组成的$m \\times n$矩形对角矩阵。 $$ A=U\\Sigma V^{T} $$ 满足： $$ UU^T=I \\\\ VV^T=I \\\\ \\Sigma = diag(\\sigma_{1},\\sigma_{2},\u0026hellip;,\\sigma_{p})\\\\ \\sigma_{1} \\ge \\sigma_{2} \\ge \u0026hellip; \\ge \\sigma_{p} \\ge 0 \\\\ p \\le min(m,n) $$ 则$\\sigma_i$为矩阵$A$的奇异值，$U$ 的列向量称为左奇异向量，$V$的列向量称为右奇异向量。\n奇异值分解存在定理 任意给定一个实矩阵，其奇异值分解一定存在。证明见《统计学习原理》P273。\n紧奇异值分解与截断奇异值分解 紧奇异值分解是与原始矩阵$A$等秩的奇异值分解，截断奇异值分解是比原始矩阵$A$低秩的分解。\n具体地，截断奇异值分解中，只取最大的k个奇异值（$k \u0026lt; R(A)$）来组成$\\Sigma$。\n举例：\n对于以下矩阵$A$，其秩为3。\n$$ A= \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 4 \\\\ 0 \u0026amp; 3 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 2 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{pmatrix} $$\n$A$的紧奇异值分解为：$A=U_r \\Sigma_r V_r^T$，其中：\n$$ U_r= \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; \\sqrt{0.2} \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; \\sqrt{0.8} \\\\ \\end{pmatrix}, \\Sigma_r = \\begin{pmatrix} 4 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 3 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; \\sqrt{5} \\\\ \\end{pmatrix}, V_r^T = \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{pmatrix} $$\n$A$的截断奇异值分解为：$A=U_k\\Sigma_kV_r^T$，其中：\n$$ U_r= \\begin{pmatrix} 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \\\\ \\end{pmatrix}, \\Sigma_r = \\begin{pmatrix} 4 \u0026amp; 0 \\\\ 0 \u0026amp; 3 \\\\ \\end{pmatrix}, V_r^T = \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{pmatrix} $$\n相当于缺失了一部分信息，但也可能够根据剩余的奇异值还原原有矩阵的信息，实现一定程度的数据压缩。例如以上截断奇异值分解可以进行以下还原：\n$$ A_2=U_2\\Sigma_2V_2^T= \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 4 \\\\ 0 \u0026amp; 3 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{pmatrix} $$\n几何含义 对于线性变换$A=U\\Sigma V^T$，即等价于经过旋转$V^T$，缩放$\\Sigma$，旋转$U$。$U$和$V$都是正交阵，对应的线性变化仅为旋转。如下图所示。\n计算方法 给定$m \\times n$的矩阵$A$，进行奇异值分解$A=U\\Sigma V^{T}$。\n（1）求$A^TA$的特征向量和特征值。\n计算对称矩阵$W=A^TA$，有以下特征方程： $$ (W-\\lambda E)x=0 $$ 求解特征方程可得特征值$\\lambda_{i}$，将特征值从大到小进行排列：$\\lambda_{1} \\ge \\lambda_{2} \\ge \u0026hellip; \\ge \\lambda_{n} \\ge 0$。带入特征方程能够得到对应的的特征向量。\n（2）求解n阶的正交矩阵$V$\n将求得的特征向量进行单位化，得到单位特征向量$v_1,v_2,\u0026hellip;,v_n$，构成n阶的正交矩阵$V=[v_1,v_2,\u0026hellip;,v_n]$。\n（3）求$m \\times n$对角阵$\\Sigma$\n计算$A$的奇异值： $$ \\sigma_i=\\sqrt{\\lambda_i} \\ , i=1,2,\u0026hellip;,n $$ ,那么可以构造出$\\Sigma$，主对角线的元素为奇异值，其余为0。 $$ \\Sigma=diag(\\sigma_1,\\sigma_2,\u0026hellip;,\\sigma_n) $$ （4）求m阶的正交矩阵$U$\n对A的前r个正奇异值，令$u_j=\\frac{1}{\\sigma_j}Av_j,j=1,2,..,r$。得到部分正交矩阵： $$ U_1=[u_1 \\ u_2 \\ \u0026hellip; \\ u_r] $$ 求$A^T$的零空间中的一组标准正交基${u_{r+1},u_{r+2},\u0026hellip;,u_{m}}$，记为$U_2$。\n则能够得到： $$ U=[U_1 \\ U_2] $$ （5）得到奇异值分解结果。 $$ A=U\\Sigma V^T $$\n"},{"section":"Blog","slug":"/en/blog/web-vue/","title":"【课程笔记】Web前端开发-Vue","description":"this is meta description","date":"March 25, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"Web前端开发","content":"HTML CSS 复合属性\nborder:宽度 样式 颜色\nfont:风格 粗细 字号/行高 字体\nbackground:背景色 url 平铺 定位 固定\ntransition:属性 时长 速度曲线 延时\nlist\nJavaScript 数组操作 push、unshift\t压入\npop、shift\t弹出\nreverse、sort改变原数组\nsplice：删除，返回删除区间数组，传入起始索引+长度 长度为0则表示添加\nslice：截取，不改变原数组，传入区间\nsubstring：类似slice，end无负值\nsubstr：截取，第二个参数为长度\n正则：\n？：0/1\n+：\u0026gt;=1\n*：\u0026gt;=0\nVue.js 1.概要介绍 概念 Vue是一套用于构建用户界面的渐进式框架，Vue被设计为自底向上逐层应用。\n声明式编程：不需要直接操作DOM元素。Vue是一个响应式系统：数据和DOM元素绑定在一起，所有的元素都是响应式的。\nMVVM模式 Model-View-ViewModel。Model指的是数据部分，主要负责业务数据；View指的是视图部分，即DOM元素，负责视图的处理；ViewModel连接视图和数据的数据模型，负责Model监听或者View的修改。\n把需要改变的视图数据初始化到Vue中，然后通过修改Vue中的数据从而实现对视图的更新。\n核心技术 组件化和虚拟DOM技术。Vue通过虚拟DOM技术来减少对DOM的直接操作。\n2.基础技术 2.1 基本架构 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;!-- 插值表达式，将data中数据渲染到页面 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;msg\u0026#34;\u0026gt; \u0026lt;!-- 数据双向绑定 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 实例化Vue程序 var vm = new Vue({ el:\u0026#39;#app\u0026#39;, //Vue管理的DOM节点入口，值为选择器 不能为html或者body data: { //指定初始化数据 msg:\u0026#34;Hellowrold\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 2.2 Vue实例 el唯一根标签 class或者id选择器可以用来将页面结构与Vue实例对象中的el绑定。\ndata初始数据 Vue的数据对象为data，Vue会将data的数据转换为get、set接口从而让data的属性能够相应数据变化。\n可以通过vm.$data访问原始数据对象。vm.name等价于vm.$data.name，由于Vim实例代理了data对象的所有属性。\nmethods定义方法 methods属性用来定义方法，方法中this指向Vue实例本身。\n其中绑定事件语句**@click等价于v-on:click**，v-on为事件监听指令，直接与事件类型配合使用。\n\u0026lt;button @click=\u0026#34;showInfo\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;!-- 绑定事件 --\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data: { msg:\u0026#34;Hellowrold\u0026#34; }, methods: { //定义事件处理方法 showInfo() { this.msg=\u0026#34;Click\u0026#34; //this指向该Vue实例vm } //或者写为 showInfo:function() { } } }) computed计算属性 一些数据需要随着其他数据的变动而变动，使用computed计算属性。\n事件处理方法中，this指向的Vue实例的计算属性结果会被缓存起来，只有依赖的响应式属性变化时，才会重新计算，返回最终结果。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;自变量X:{{dataX}}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;dataX\u0026#34;\u0026gt; //双向绑定数据 \u0026lt;p\u0026gt;自变量Y:{{dataY}}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;dataY\u0026#34;\u0026gt;\t//双向绑定数据 \u0026lt;p\u0026gt;计算结果X+Y:{{Sum}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#34;#app\u0026#34;, //挂载唯一根标签 data: { dataX:0, dataY:0, }, computed: { //计算属性 Sum作为绑定的目标数据 Sum() { return Number(this.dataX) + Number(this.dataY) } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; watch状态监听 原有的事件出发不能自动监听Vue实例的状态变化，watch只需监听当前Vue实例中的数据变化。\n例如：\nwatch: { Sum(newName,oldName) { console.log(newName,oldName) } } 监听Sum变量的变化，如果发生变化则打印旧值和新值。\nfilter过滤器 可以在插值表达式中使用filter，使用管道符|，语法为**{{data|filter}}**。\n其中filter定义为函数形式，将data作为参数传入filter函数，以实现指定操作。P9例代码\nv-bind属性绑定也可以使用过滤器，如“v-bind:id=\u0026ldquo;data”，表示绑定id属性为data，data后面可以加过滤器。\n2.3 Vue数据绑定 绑定样式 使用v-bind将样式数据绑定给DOM元素。\n可以1.绑定样式属性；2.绑定样式对象；3.绑定样式类\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-bind:style=\u0026#34;{backgroundColor:pink,width:width,height:height}\u0026#34;\u0026gt; 这里使用的是绑定样式属性值，具体值也是Vue实例的data数据 \u0026lt;/div\u0026gt; \u0026lt;div v-bind:style=\u0026#34;myDiv\u0026#34;\u0026gt; 这里使用的是绑定样式对象，对象在Vue实例data中定义 \u0026lt;/div\u0026gt; \u0026lt;div v-bind:class=\u0026#34;box\u0026#34;\u0026gt; 这里使用绑定样式类class的方法实现样式的绑定，类值也在Vue实例data中 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data: { //样式对象 myDiv:{backgroundColor:\u0026#39;red\u0026#39;,width:\u0026#39;300px\u0026#39;,height:\u0026#39;100px\u0026#39;}, //样式属性值 pink:\u0026#39;pink\u0026#39;, width:\u0026#39;100%\u0026#39;, height:\u0026#39;200px\u0026#39;, box:\u0026#39;box\u0026#39; //box类的样式在style标签中声明 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-model指令 实现数据的双向绑定，通常用于表单数据上，格式为：v-model=\u0026ldquo;data\u0026rdquo;\nv-text指令 实现在DOM元素内部插入文本内容，格式为：v-text=\u0026ldquo;txt\u0026rdquo;\nv-html指令 在DOM元素内部插入HTML标签内容，可以是HTML结构。\nv-bind指令 实现属性数据的单向绑定，格式为：v-bind:value=\u0026ldquo;values\u0026rdquo;。其中value为元素属性，如style、value等，可以简写为： :value=\u0026ldquo;values\u0026rdquo;。\nv-on指令 属于事件监听指令，直接与事件类型配合使用。格式为：v-on:events=\u0026ldquo;methods\u0026rdquo;，其中events为事件类型，如click，methods为Vue实例中定义的具体方法。可以简写为@events=”methods“。\n注意，event会作为响应函数的默认形参，代表原生DOM事件，当调用的函数有多个参数传入时，需要使用原生DOM事件时，则通过$event作为实参传入。\nv-for指令 遍历数组，以**（项，索引）**的形式遍历，其中索引可以省略，但高版本的Vue最好不要省略。\n迭代对象时，语法为v=for=\u0026rdquo;(value,key,index) in Object\u0026quot;。其中value为每个对象的属性值，key为属性名，index为索引值。后两个可选。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 以（项，索引）的形式遍历data列表 --\u0026gt; \u0026lt;div v-for=\u0026#34;(item,index) in list\u0026#34;\u0026gt; 索引为:{{index}},内容为:{{item}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data: { list:[2,3,4,5] } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-if指令 控制元素的隐藏和显示，和v-show功能类似，v-show操作的是display属性，元素始终被渲染并保留在DOM中，而v-if会对元素进行删除和重建，性能较差。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 绑定事件，反转flag --\u0026gt; \u0026lt;button @click=\u0026#34;flag=!flag\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;!-- 判定flag，为true则显示 --\u0026gt; \u0026lt;div v-if=\u0026#34;flag\u0026#34; style=\u0026#34;background-color:red\u0026#34;\u0026gt;Try v-if\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ flag:true } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 2.4 Vue事件 使用按键修饰符监听按键 监听键盘事件时，需要检查常见的键值。Vue允许为v-on添加按键修饰符来监听按键。\n例如v-on:keyup.enter=\u0026ldquo;func\u0026rdquo;。该事件为回车键被按下。\n格式：v-on:keyup.按键名，或者@keyup.按键名\n常见的按键名包括.enter .tab .delete .esc .space \u0026hellip;\n.stop阻止事件冒泡 通过在事件后面加.stop,例如click.stop，可以使得事件冒泡行为被阻止，即事件不会向上传递至父级元素。\n.prevent阻止默认事件行为 对于HTML标签的自身特性，例如a会进行自动跳转，可以使用.prevent修饰符对事件进行控制，使得元素的默认事件行为被阻止。例如在a标签中加入语句v-on:click.prevent，即可阻止跳转行为。\n.capture事件捕获 对于默认情况，事件由内到外执行，即冒泡顺序，而.capture事件捕获则时由外及内的。\n.self自身触发 该事件修饰符来实现只有DOM元素本身会触发事件。即若某事件是冒泡触发的，而非其元素本身受到的触发，则不会执行事件触发。\n.once只触发一次 阻止事件的多次触发。\n修饰符顺序 事件修饰符可以控制事件按照一定规则触发。\n例如，v-on:click.prevent.self阻止所有的单击,v-on:click.self.prevent阻止对元素本身的单击。\n2.5 Vue组件 全局注册 使用Vue.component()方法进行全局注册组件。\n1.通过Vue.extend()方法生成组件构造器，内容包含data，template，watch等。(与new Vue接收相同的选项)\n（Tips:此类配置选项在组件内部有独立作用域，不能从外面直接访问。）\n2.调用Vue.component()方法注册组件。\n3.在Vue实例的作用范围使用组件。\n例如：\nvar myConponent = Vue.extend({ //data在组件中必须为一个函数，通过返回值来返回初始数据 data() { return { count:0 } }, template:\u0026#39;\u0026lt;button v-on:click=\u0026#34;count++\u0026#34;\u0026gt;被单击{{count}}次\u0026lt;/button\u0026gt;\u0026#39; }) //2.注册组件 Vue.component(\u0026#39;my-conponent\u0026#39;,myConponent); //3.挂载app并在元素中使用组件 var vm = new Vue({ el:\u0026#39;#app\u0026#39; }) 其中组件构造器可以省略调用extend方法构造，用JavaScript对象来定义，如下。\nVue.component(\u0026#39;myConponent\u0026#39;,{ //data在组件中必须为一个函数，通过返回值来返回初始数据 data() { return { count:0 } }, template:\u0026#39;\u0026lt;button v-on:click=\u0026#34;count++\u0026#34;\u0026gt;被单击{{count}}次\u0026lt;/button\u0026gt;\u0026#39; }) 局部注册组件 通过Vue实例的components属性来实现，如下。其中myConponent1为组件构造器。\nvar vm = new Vue({ el:\u0026#39;#app\u0026#39;, components:{ myConponent: myConponent1} }) template模板 Vue提供了\u0026lt;template\u0026gt;标签来定义结构的模板，在该标签中书写HTML代码，通过id值绑定到目标组件内的template上。\n例如\u0026lt;template id=\u0026ldquo;tmp1\u0026rdquo;\u0026gt; HTML代码 \u0026lt;\\template\u0026gt;，组件构造器内：template:\u0026rsquo;#tmp1'\n组件间切换 可以采用v-if和v-else来进行显示与否的切换。也可以使用\u0026lt;component\u0026gt;标签的is属性值来进行组件的切换，is的属性值即为显示的组件名称。通过v-bind对该属性值进行绑定即可实现切换。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 超链接事件被取消默认响应，事件操作为修改comName --\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; @click.prevent=\u0026#34;comName=\u0026#39;login\u0026#39;\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; @click.prevent=\u0026#34;comName=\u0026#39;register\u0026#39;\u0026#34;\u0026gt;Register\u0026lt;/a\u0026gt; \u0026lt;!-- 通过component标签的is属性进行显示的组件切换，v-bind将该属性进行绑定 --\u0026gt; \u0026lt;component v-bind:is=\u0026#34;comName\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 组件定义 Vue.component(\u0026#39;login\u0026#39;,{ template:\u0026#39;\u0026lt;div\u0026gt;登录页面\u0026lt;/div\u0026gt;\u0026#39; }) Vue.component(\u0026#39;register\u0026#39;,{ template:\u0026#39;\u0026lt;div\u0026gt;注册页面\u0026lt;/div\u0026gt;\u0026#39; }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ comName:\u0026#39;login\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 2.6 组件间通信 组件实例具有局部作用域，需要一些工具来实现组件间通信，例如父组件向子组件传递数据信息。\nprops传值 props即为道具，用来接受父组件中定义的数据，其值为数组，数组中是父组件传递的信息。\nprops是以从上到下的单向数据流传递，且父级组件的props更新会向下流动到子组件，但反过来不行。\nprops在声明组件对象中（组件构造器）定义，有三种方式：（1）数组形式传递属性名；（2）对象形式传递属性名和数据类型；（3）指定属性名、数据类型、必要性、默认值。\n举例：\n\u0026lt;body\u0026gt; \u0026lt;template id=\u0026#34;tmp1\u0026#34;\u0026gt; \u0026lt;!-- 采用template标签来构造组件模板 --\u0026gt; \u0026lt;div\u0026gt;父组件消息:{{name}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 父组件处传入name的值 --\u0026gt; \u0026lt;my-parent name=\u0026#34;传入信息12132\u0026#34;\u0026gt; \u0026lt;/my-parent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;my-parent\u0026#39;,{ //在组件构造器中声明，表示接受name数据，它在父组件处传入 props:[\u0026#39;name\u0026#39;], template:\u0026#39;#tmp1\u0026#39; }) var vm = new Vue({ //挂载 el:\u0026#39;#app\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; Tips：如果在默认情况下，无法从外面去给组件内部的值进行赋值，使用props可以想象成开通某个管道，使得数据能够通过该管道进入到组件内部。\n可以使用v-bind来动态绑定传入数据的值，如下代码。\n\u0026lt;body\u0026gt; \u0026lt;template id=\u0026#34;tmp1\u0026#34;\u0026gt; \u0026lt;!-- 采用template标签来构造组件模板 --\u0026gt; \u0026lt;div\u0026gt;父组件消息:{{name}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 使用v-bind来绑定name这个属性，值也是从父节点（此处）来的 --\u0026gt; \u0026lt;my-parent v-bind:name=\u0026#34;inputdata\u0026#34;\u0026gt; \u0026lt;/my-parent\u0026gt; \u0026lt;!-- 双向绑定 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;inputdata\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;my-parent\u0026#39;,{ //在组件构造器中声明，表示接受name数据，它在父组件处传入 props:[\u0026#39;name\u0026#39;], template:\u0026#39;#tmp1\u0026#39; }) var vm = new Vue({ //挂载 el:\u0026#39;#app\u0026#39;, data:{ //声明一个数据，从来接受文本框的数据 inputdata:0 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; $emit传值 $emit能够将子组件中的值传递到父组件中，触发父组件中定义的事件，子组件的数据信息通过传递参数的方式完成。\n例如：子组件通过this.$emit触发父组件的自定义函数，将其data作为参数传出，父组件通过事件响应函数接收该传出的参数，完成组件间传值。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;parent\u0026gt;\u0026lt;/parent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;click\u0026#34;\u0026gt; Send \u0026lt;/button\u0026gt; \u0026lt;!-- 双向绑定给子组件的data --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;parents\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 在child组件上绑定了一个名为childfn的事件，事件处理方法为transContent --\u0026gt; \u0026lt;child @childfn=\u0026#34;transContent\u0026#34;\u0026gt;\u0026lt;/child\u0026gt; From child: {{message}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; //父组件parent Vue.component(\u0026#39;parent\u0026#39;,{ template:\u0026#39;#parents\u0026#39;, data() { return { message:\u0026#39;\u0026#39; } }, methods:{ //对于事件处理方法，将传入的形参赋值给父组件的数据message transContent(payload) { this.message = payload } } }) //子组件child Vue.component(\u0026#39;child\u0026#39;,{ template:\u0026#39;#child\u0026#39;, data() { return{ message:\u0026#39;child message\u0026#39; } }, methods: { click() { //按钮按下后响应该方法 //子组件触发自定义事件childfn，并且将message作为参数传出 this.$emit(\u0026#39;childfn\u0026#39;,this.message); } } }) var vm = new Vue({el:\u0026#39;#app\u0026#39;}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 2.7 Vue的生命周期 每个Vue实例在被创建时要经过一系列初始化过程，三大阶段：初始化显示、更新显示、销毁Vue实例\n初始化阶段的钩子函数：\nbeforeCreate()实例创建前：数据和模板均为获取到\ncreated()实例创建后：最早可访问到data数据，但模板未获取到\nbeforeMount()数据挂载前：模板已经获取到，但数据未挂载到模板上\nmounted()数据挂载后：数据已经挂载到模板中\n更新阶段的钩子函数：\nbeforeUpdate()模板更新前：data改变后，更新数据模板之前调用\nupdated()模板更新后：将data渲染到数据模板中\n销毁阶段的钩子函数\nbeforeDestroy()实例销毁前\ndestroyed()实例销毁后，vm实例在这两个阶段都存在，但是销毁之后获取不到页面中的div，所以，实例销毁后无法操作DOM元素。\n2.8 自定义指令 除了内置指令外，Vue允许注册自定义指令。\n注册全局指令 //指令名不要带v- Vue.directive(\u0026#39;指令名\u0026#39;,{ //el代表使用该指令的DOM元素 //binding可获取使用了此指令的绑定值 inserted:function(el,binding) { //逻辑代码 } }) 注册局部指令 directive:{ \u0026#39;指令名\u0026#39;:{ inserted:function(el,binding) { //逻辑代码 } } } 全局自定义的案例 Vue.directive(\u0026#39;upper-text\u0026#39;,{ //一般对样式的操作在bind中 bind:function(el) { el.style.color=\u0026#39;red\u0026#39; }, //一般对js的操作在inserted中 //el为指令作用的DOM元素 //binding用于获取使用该指令的绑定值(value)、表达式(expression) inserted:function(el,binding) { el.innerHTML=binding.value.toUpperCase() } }) 2.9 一些全局API Vue.use（插件相关） 用于在Vue中安装插件，通过插件可以为Vue添加全局功能。插件可以是一个对象或者函数，如果是对象，必须提供install方法，用来安装插件。\n使用Vue.use进行插件的安装，随后可以使用插件中的内容。\n\u0026lt;body\u0026gt; \u0026lt;!-- 使用插件中的自定义指令 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; v-my-directive\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 定义一个对象，表示插件 let MyPlugin = {} // 定义该插件的安装函数，传参Vue构造器，和可选的配置对象 MyPlugin.install = function (Vue, options) { console.log(options) //插件中注册全局的自定义指令 Vue.directive(\u0026#39;my-directive\u0026#39;,{ bind(el,binding) { el.style=\u0026#39;width:100px;height:100px;background-color:#ccc\u0026#39; } }) } //安装插件 Vue.use(MyPlugin,{someOption:true}) //实例化Vue对象并挂载元素 var vm = new Vue({ el:\u0026#39;#app\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; Vue.extend（构造子类） 用来构建一个Vue子类，对Vue构造器进行拓展。\n\u0026lt;body\u0026gt; \u0026lt;!-- app1报错，Vue中没有title，app2则不报错，Vue2是Vue的子类，包含title的data --\u0026gt; \u0026lt;!-- \u0026lt;div id=\u0026#34;app1\u0026#34;\u0026gt;app1:{{title}}\u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;div id=\u0026#34;app2\u0026#34;\u0026gt;app2:{{title}}\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var Vue2 = Vue.extend({ data() { return { title:\u0026#39;hello\u0026#39; } } }) // var vm1 = new Vue({ // el:\u0026#39;#app1\u0026#39; // }) var vm2 = new Vue2({ el:\u0026#39;#app2\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; Vue.set（添加属性） 用于向响应式对象中添加一个属性，确保新属性也是响应式的。格式为Vue.set(vm.obj,\u0026rsquo;tar\u0026rsquo;,\u0026lsquo;data\u0026rsquo;)。及向Vue实例vm中的obj数据对象中添加一个属性tar，属性值为data。需注意无法动态地添加根级属性，即添加的属性不能和obj同级。\nVue.mixin（全局混入） 用于全局注册一个混入（Mixin），将影响之后创建的每一个Vue实例。向实例中注入指定的行为（函数）。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 注册全局混入 Vue.mixin({ //注入钩子函数created created() { //取到自定义属性myOption并在控制台输出 var myOption = this.$options.myOption if(myOption) { console.log(myOption.toUpperCase()) } } }) //实例化时，由于全局注入了，钩子函数生效 var vm = new Vue({ //钩子函数检测该属性并在控制台输出 myOption:\u0026#34;Hello Mixin!\u0026#34; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 对于混入，局部创建则为在Vue实例化时为mixins属性传入一个混入对象。\n//混入对象 var mixin = { created: function () { document.write(\u0026#39;混入调用\u0026#39; + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;) } } //传入混入对象，以数组形式传入，这样会进行合理的合并 new Vue({ mixins: [mixin], created: function () { document.write(\u0026#39;组件调用\u0026#39; + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;) } }); 如果 methods 选项中有相同的函数名，则 Vue 实例优先级会较高。其次是混入对象中的。\n2.10 一些实例属性 vm.$props 接收从上级组件向下传递的数据，见传值一节。\nvm.$options 获取指定的选项（el,data,methods等），以及自定义的选项。或者说属性？\nvm.$el 用来访问vm实例使用的根DOM元素。即挂载的目标，返回的是一个DOM对象。\nvm.$children 获取当前实例的直接子组件，但返回值不保证顺序，也不是响应式的。\nvm.$root 用来获取当前组件树的根Vue实例，如果当前实例没有根实例，则获取到该实例本身。注意：是根组件，不是父组件。\nvm.$slot 插槽就是定义在组件内部的template模板，可以通过$slot动态获取。插槽用于决定将所携带的内容，插入到指定的某个位置\n每个默认插槽会接收组件标签中的所有内容，对于指定name的插槽，通过template标签的v-slot属性来完成命名指定。或者在指定标签中使用slot属性进行插槽的选定。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt; \u0026lt;!-- 内容插入到插槽当中 --\u0026gt; Hello \u0026lt;!-- 使用template模板结构定义插槽 --\u0026gt; \u0026lt;template v-slot:second\u0026gt;World\u0026lt;/template\u0026gt; \u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;first\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 启用插槽 --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;!-- 启用插槽指定name为second --\u0026gt; \u0026lt;slot name=\u0026#34;second\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 注册组件 Vue.component(\u0026#39;my-component\u0026#39;,{template:\u0026#39;#first\u0026#39;}) var vm = new Vue({el:\u0026#39;#app\u0026#39;}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; vm.$attrs 可以获取组件的属性，但不包括class、style以及被声明为props的属性。\n2.11 createElement\u0026amp;render 渲染 createElement()函数返回的是一个描述节点，用来告诉Vue在页面上渲染什么样的节点，亦称为虚拟节点，VNode。\n第一个参数：HTML标签名或者组件选项对象\n第二个参数：可选，可以传入一个与模板中属性相对应的数据对象\n第三个参数：是由createElement构建而成的子级虚拟节点，也可以用字符串生成文本虚拟节点。\n代码样例1：含有默认插槽\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt; 成功渲染，此处为默认插槽 \u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 注册组件 Vue.component(\u0026#39;my-component\u0026#39;,{ render(createElement) { // 传入createElement函数返回的VNode // 该VNode告知标签类型、样式属性、子级虚拟节点 return createElement(\u0026#39;p\u0026#39;,{ style: { color:\u0026#39;red\u0026#39;, fontSize:\u0026#39;16px\u0026#39;, backgroundColor:\u0026#39;#eee\u0026#39; } //this.$slots.default 理解为一个创建默认插槽 },this.$slots.default) } }) var vm = new Vue({el:\u0026#39;#app\u0026#39;}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 代码样例2：含有命名插槽\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt; \u0026lt;!-- 各模板通过v-slot来定义指定的命名插槽 --\u0026gt; \u0026lt;template v-slot:header\u0026gt; \u0026lt;div style=\u0026#34;background-color: #ccc;height: 50px;\u0026#34;\u0026gt; header \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:content\u0026gt; \u0026lt;div style=\u0026#34;background-color: #ddd;height: 50px;\u0026#34;\u0026gt; content \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:footer\u0026gt; \u0026lt;div style=\u0026#34;background-color: #eee;height: 50px;\u0026#34;\u0026gt; footer \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;my-component\u0026#39;,{ render(createElement) { //该VNode类型为div，包含三个子级虚拟节点 return createElement(\u0026#39;div\u0026#39;, [ //三个子级虚拟节点，其各自的子节点包含命名插槽 createElement(\u0026#39;header\u0026#39;,this.$slots.header), createElement(\u0026#39;content\u0026#39;,this.$slots.content), createElement(\u0026#39;footer\u0026#39;,this.$slots.footer), ] ) } }) var vm = new Vue({el:\u0026#39;#app\u0026#39;}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; render函数写法 render函数由Vue调用，其中传入的参数为createElement函数，返回参数为createElement函数的返回值。\nrender(createElement) { return createElement(...) } render:(createElement) =\u0026gt; {return createElement(...)} render:createElement =\u0026gt;createElement(...) render:h=\u0026gt;h(APP)//h传入组件 3.Vue过渡和动画 3.1 transition组件 Vue为\u0026lt;transition\u0026gt;标签内部的元素提供了三个进入过渡和三个离开过渡的类。\n内置的class类名实现过渡 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 用于div的隐藏和显示的切换 --\u0026gt; \u0026lt;button v-on:click=\u0026#34;toggle\u0026#34;\u0026gt; Click \u0026lt;/button\u0026gt; \u0026lt;!-- name属性设置在过渡中切换的类名前缀,默认为v- --\u0026gt; \u0026lt;transition name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;chart\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data: { show:true, }, methods: { toggle() { this.show=!this.show } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 其中transition标签设置name，前缀为box，在CSS中实现以该box-为前缀的过渡类，不设置则默认为v-。该标签自动应用这些class在达到效果。\n过渡类有：v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to。\n在CSS中操作transition（过渡）和animation（动画）来达到不同的效果。\n.chart { width: 200px; height: 50px; background-color: aqua; } /* 通过css内置类名来实现过渡,name前缀为box */ .box-enter-active, .box-leave-active { transition: width 3s; /*某一项属性 + 持续的时间*/ } .box-enter, .box-leave-to { width: 0px; } .box-enter-to, .box-leave { width: 200px; } 自定义类名 无需对transition标签的name属性进行设置，可以通过设置以下属性来配置自定义的css类。例如animate.css中已定义了一系列动画类。\nenter-class、enter-active-class、enter-to-class、leave-class、leave-active-class、leave-to-class\nappear初始渲染动画 给元素添加初始渲染的动画效果。在transition标签中进行相关属性的设置。\nappear-class表示初始class样式；appear-to-class表示过渡完成的class样式；appear-active-class会应用到整个过渡过程中。\n三者的顺序要求见vue.js教材P69。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;show=!show\u0026#34;\u0026gt; Click \u0026lt;/button\u0026gt; \u0026lt;!-- 为transition标签设置appear属性 第一个appear代表开启此特性 --\u0026gt; \u0026lt;transition appear appear-active-class=\u0026#34;animated swing\u0026#34; enter-active-class=\u0026#34;animated bounceIn\u0026#34; leave-active-class=\u0026#34;animated bounceOut\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;show\u0026#34;\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; 使用@keyframes创建CSS动画 与前面提到的CSS过渡用法相比，@keyframes动画中的v-enter类名在节点插入DOM后并不会立即删除，而是在animationend（动画结束）事件触发时删除。\n@keyframes规则创建动画，即将一套CSS样式逐步演变成另一套，过程中可以多次改变CSS样式，通过百分比或者from和to（相当于0%和100%）来规定动画的状态。\n基本语法如下为： @keyframes 规则名字 {百分比 {样式；}}\n例子如下：\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;show=!show\u0026#34;\u0026gt;@keyframes创建CSS动画\u0026lt;/button\u0026gt; \u0026lt;!-- 内置class类实现过渡的方法 --\u0026gt; \u0026lt;transition name=\u0026#34;bounce\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;circular\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;原型\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ show:true } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; transition标签中绑定name属性为bounce，在CSS中的过渡类将以他为前缀。CSS代码如下。\n\u0026lt;style\u0026gt; div.circular { width: 100px; height: 100px; background: red; border-radius: 50%; margin-top: 20px; text-align: center; line-height: 100px; color:aqua; } /* CSS中操作动画,通过animation */ .bounce-enter-active { animation: Ami .5s; } .bounce-leave-active { animation: Ami .5s; } /* 定义动画规则 */ @keyframes Ami { 0% { transform:scale(0); background: aqua; } 20% { transform:scale(1); background: burlywood; } 50% { transform:scale(1.5); background: blueviolet; } 100% { transform:scale(1); background: burlywood; } } \u0026lt;/style\u0026gt; 常见的一些CSS属性 animation：绑定动画，后带上绑定的动画规则名+时长\ntransition：绑定过渡，后带上需要变动的属性+时长，如果属性为all则为所有效果\nopacity：不透明度，0为隐藏，1为显示\ntransfrom：包括scale缩放，translateX水平方向移动等。\n使用钩子函数实现动画 Vue可以借助JavaScript来完成动画。在\u0026lt;transition\u0026gt;标签中定义了一些钩子函数。在methods中编写钩子函数。示例见教材P71。\n3.2多元素过渡 不同标签名的元素过渡 不相同标签名的元素可以使用v-if和v-else来实现过渡。\n相同标签名元素的过渡 需要通过key特性设置唯一值来标记，通过key让Vue来进行区别。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 进行切换 --\u0026gt; \u0026lt;button @click=\u0026#34;f=!f\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;!-- 设置唯一的key值以区分button --\u0026gt; \u0026lt;button v-if=\u0026#34;f\u0026#34; key=\u0026#34;edit\u0026#34;\u0026gt; EDIT \u0026lt;/button\u0026gt; \u0026lt;button v-else key=\u0026#34;save\u0026#34;\u0026gt;SAVE\u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ f:true } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 过渡模式 新旧两个元素参与过渡的时候，新元素的进入和旧元素的离开会同时触发。可以使用transition提供的过渡模式mode，它有两个值，分别为in-out和out-in。前者为新元素进来后旧元素再离开，后者表示旧元素离开后新元素再进来。\n多组件过渡 多组件过渡不需要使用key特性，使用动态组件即可。动态组件需要通过Vue中的\u0026lt;component\u0026gt;元素绑定is属性来实现。\n3.3 列表过渡 对于列表过渡，需要使用v-for和transition-group组件来实现。\n\u0026lt;transition-group\u0026gt;标签相当于给每个包裹的元素在外面加了一个transition标签。\n列表的每一项都需要进行过渡，列表在循环时要给每一个列表项添加唯一的key属性值。\n列表的进入和离开过渡 以下案例实现简单的列表过渡\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 绑定响应函数 --\u0026gt; \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;ADD\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;remove\u0026#34;\u0026gt;REMOVE\u0026lt;/button\u0026gt; \u0026lt;!-- 定义过度类前缀 --\u0026gt; \u0026lt;!-- 修改tag,渲染出p标签 --\u0026gt; \u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;p\u0026#34;\u0026gt; \u0026lt;!-- item赋给唯一的key属性 --\u0026gt; \u0026lt;span v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{item}} \u0026lt;/span\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ items:[1,2,3,4,5], nextNum:6 }, methods:{ randomIndex() { return Math.floor(Math.random()*this.items.length) }, add() { this.items.splice(this.randomIndex(),0,this.nextNum++) }, remove() { this.items.splice(this.randomIndex(),1) } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 其中CSS样式为：\n\u0026lt;style\u0026gt; .list-item{ display: inline-block; margin-right: 10px; background-color: red; border-radius: 50%; width: 25px; height: 25px; text-align: center; line-height: 25px; color: #fff; } .list-enter-active,.list-leave-active { transition: all 1s; } .list-enter,.list-leave-to { opacity: 0; transform: translateY(30px); } \u0026lt;/style\u0026gt; 列表的排序过渡 通过v-move特性，在元素改变定位的过程中应用，可以通过name属性来自定义前缀，也可以通过move-class属性来设置自定义类名，和过渡类一致。\n4.Vue路由 实现URL和组件之间的一一对应。更新视图而不更新请求页面（单页面应用SPA）。\n4.1 vue-router 实现单页面前端路由时，提供了hash模式和history模式。默认为hash模式，使用URL的hash来模拟一个完整的URL，当URL改变时，页面不会重新加载。#就是hash符号，也成为锚点或者哈希符。hash值是指导浏览器动作的，对服务器没有影响。\n基本使用如下。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 该标签实现跳转链接功能 --\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt; 首页 \u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt; 关于我们 \u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 占位符使用，将路由规则中匹配的组件进行展示 --\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 组件模板 --\u0026gt; \u0026lt;template id=\u0026#34;sy\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;ab\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;关于我们\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 路由表 var routes=[ { path:\u0026#39;/\u0026#39;, component:{ template:\u0026#39;#sy\u0026#39; } }, { path:\u0026#39;/about\u0026#39;, component:{ template:\u0026#39;#ab\u0026#39; } } ] //通过全局路由构造函数构造一个路由器，其中配置路由表 var router = new VueRouter({ routes:routes }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, //将路由规则对象注册到实例上 router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; query方式传参 参数值存放在query对象，通过user组件对象的$route属性访问当前路由，调用query获取相关参数信息。\n使用query传参，参数会以查询字符串的形式显示在浏览器地址栏中。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/user?id=10\u0026amp;name=admin\u0026#34;\u0026gt; Login \u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;tmp\u0026#34;\u0026gt; \u0026lt;!-- 通过query获取参数对象 --\u0026gt; \u0026lt;h3\u0026gt;id:{{this.$route.query.id}} + name:{{$route.query.name}}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var user = { template:\u0026#34;#tmp\u0026#34;, //钩子函数输出当前路由 created() { console.log(this.$route) } } // 路由表对象 var router = new VueRouter({ routes:[ {path:\u0026#39;/user\u0026#39;, component:user} ] }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, // 注册路由 router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; params方式传参 将参数放在路径中或者隐藏，如下例子。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 此处会进行参数的解析 通过params进行参数的获取 --\u0026gt; \u0026lt;router-link to=\u0026#34;/user/10/admin\u0026#34;\u0026gt; Login \u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;tmp\u0026#34;\u0026gt; \u0026lt;!-- 插值表达式中省略了this --\u0026gt; \u0026lt;h3\u0026gt; id:{{$route.params.id}} name:{{$route.params.name}}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var user = { template:\u0026#39;#tmp\u0026#39;, created() { console.log(this.$route) } } var router = new VueRouter({ routes:[ // 在path中路径中以冒号的形式设置参数，传参id和name // 在link to中进行解析 {path:\u0026#39;/user/:id/:name\u0026#39;,component:user} ] }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.2 嵌套路由 嵌套子路由通过属性children实现，children也是一组路由。在路由表中的某一路由对象中加入children属性即可。例如\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34; tag=\u0026#34;li\u0026#34;\u0026gt;关于公司\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/contact\u0026#34; tag=\u0026#34;li\u0026#34;\u0026gt;联系我们\u0026lt;/router-link\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;about-tmp\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;about-detail\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;北京xx科技有限公司简介\u0026lt;/h1\u0026gt; \u0026lt;!-- 结构为：父路由地址/要去的子路由 --\u0026gt; \u0026lt;router-link to=\u0026#34;/about/detail\u0026#34;\u0026gt;公司简介\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/about/governance\u0026#34;\u0026gt;公司治理\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;contact-tmp\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;about-detail\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;联系我们\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;公司位于北京市海淀区中关村科技园内\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var about ={template:\u0026#39;#about-tmp\u0026#39;} var contact={template:\u0026#39;#contact-tmp\u0026#39;} //子路由对应的两个组件 var detail = { template:\u0026#39;\u0026lt;p\u0026gt; xx 是全球领先的 \u0026lt;/p\u0026gt;\u0026#39; } var governance = { template:\u0026#39;\u0026lt;p\u0026gt;公司坚持以客户为中心\u0026lt;/p\u0026gt;\u0026#39; } var router = new VueRouter({ //路由表 routes:[ //重定向路由 redirect { path:\u0026#39;/\u0026#39;,redirect:\u0026#39;/about\u0026#39; }, //带有子路由的路由对象 { path:\u0026#39;/about\u0026#39;, component:about, //子路由也是一组路由表 children:[ { //这里的path不用加上/，否则默认都从根路径开始请求 path:\u0026#39;detail\u0026#39;,component:detail }, { path:\u0026#39;governance\u0026#39;,component:governance } ] }, { path:\u0026#39;/contact\u0026#39;,component:contact } ] }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.3 命名路由 通过v-bind指令，绑定\u0026lt;router-link\u0026gt;标签的to属性，to属性中，name用于唯一标识某一条路由。在路由中，需通过name属性进行设置。\n传入对象的话to前面要加冒号。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 标签中绑定name属性，选定用哪一条路由，并传参数，该参数在路由对象通过params可获取 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;user1\u0026#39;,params:{id:123}}\u0026#34;\u0026gt;Login\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var usercomponent ={ template:\u0026#39;\u0026lt;h3\u0026gt; user component \u0026lt;/h3\u0026gt;\u0026#39;, created() { //打印当前路由的信息 console.log(this.$route) } } var router = new VueRouter({ //给路由中加入name属性，以标识一条路由 routes:[ { // 使用冒号的形式匹配参数 path:\u0026#39;/user/:id\u0026#39;, // 为路由进行命名 name:\u0026#39;user1\u0026#39;, // 映射的组件 component:usercomponent } ] }) // 挂载并注册路由 var vm = new Vue({ el:\u0026#39;#app\u0026#39;, router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.4 命名视图 使用\u0026lt;router-view\u0026gt;可以为视图进行命名，其中定义name属性表示视图的名字，后续可以根据不同的name值展示不同的页面。如果没有设置名字，那么默认为default.\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 默认为default --\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view name=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;router-view name=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;h-tmp\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;header\u0026#34;\u0026gt;header头部区域\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;s-tmp\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;sidebar\u0026#34;\u0026gt;sidebar侧导航区域\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;m-tmp\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;main\u0026#34;\u0026gt;mainBox主体区域\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var header = {template:\u0026#39;#h-tmp\u0026#39;} var sidebar = {template:\u0026#39;#s-tmp\u0026#39;} var mainBox = {template:\u0026#39;#m-tmp\u0026#39;} var router = new VueRouter({ routes:[ { path:\u0026#39;/\u0026#39;, //根据命名的视图进行组件的分配 components: { \u0026#39;default\u0026#39;:header, \u0026#39;left\u0026#39;:sidebar, \u0026#39;main\u0026#39;:mainBox } } ] }) var vm = new Vue({el:\u0026#39;#app\u0026#39;,router:router}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.5 编程式导航 router.push() 可以导航到不同的URL地址。这个方法会向history栈添加一条新的记录。\n单击\u0026lt;router-link\u0026gt;时，router.push()方法会在内部调用。\nrouter.replace() 用法和push类似，只是不会在history栈中添加新的记录。\nrouter.go() 参数是一个正数，代表在history历史中前进几步或者后退几步。\n5.Vuex状态管理 Vuex对象store可以理解为一个容器，立马包含了应用中大部分的状态state，定义组件初始状态，相当于Vue实例中的data属性；mutations通过事件处理方法改变数组状态，最终将state状态反应到组件中，类似于Vue实例中的methods属性。\n计数器案例 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt; {{this.$store.state.count}} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const store = new Vuex.Store({ state: { //定义初始数据count count:0 }, mutations: { //定义事件处理方法increase //接收参数为state初始状态，通过state获取到count的值并进行操作 increase(state) { state.count++ } } }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, store, methods: { increment() { //显式的提交mutation，提交状态变更 this.$store.commit(\u0026#39;increase\u0026#39;) } } }) \u0026lt;/script\u0026gt; 6.Vue.js Ajax(axios) axios为第三方Ajax请求库。使用：结合生命钩子函数获取数据，渲染数据。\n举例：\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{info}} \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data() { return { info:null } }, mounted () { axios //发送GET请求 .get(\u0026#39;https://www.runoob.com/try/ajax/json_demo.json\u0026#39;) // 获取数据的处理 .then(response =\u0026gt; (this.info = response)) // 请求失败处理 .catch(function (error) { console.log(error); }); } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 7.组合式API 7.1 基本概念 组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：\n**响应式API：**例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。\n**生命周期钩子：**例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。\n**注入依赖：**例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。\n\u0026lt;template\u0026gt; Count is: {{ state.count }}, doubleCount is: {{ state.doubleCount }} \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;加\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive, computed } from \u0026#34;vue\u0026#34;; export default { setup() { const state = reactive({ count: 0, doubleCount: computed(() =\u0026gt; state.count * 2), }); function add() { state.count++; } return { state, add } } } \u0026lt;/script\u0026gt; 7.2 setup组件 setup() 函数在组件创建 created() 之前执行。\nsetup() 函数接收两个参数 props 和 context。\n第一个参数 props，它是响应式的，当传入新的 prop 时，它将被更新。\n第二个参数 context 是一个普通的 JavaScript 对象，它是一个上下文对象，暴露了其它可能在 setup 中有用的值。\n7.3 ref函数 ref() 函数可以根据给定的值来创建一个响应式的数据对象，返回值是一个对象，且只包含一个 .value 属性。\n在 setup() 函数内，由 ref() 创建的响应式数据返回的是对象，所以需要用 .value 来访问。\n7.4 reactive函数 作用：reactive是一个函数，接收一个普通的对象传入，把对象数据转化为响应式对象并返回\n7.5 生命钩子函数 在 Vue3 组合 API 中实现生命周期钩子函数可以在 setup() 函数中使用带有 on 前缀的函数：\n"},{"section":"Blog","slug":"/en/blog/network/","title":"【课程笔记】计算机网络","description":"this is meta description","date":"March 12, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"计算机网络","content":"Chapter1. 计算机网络与因特网（概述） 1.1 相关概念： 1.因特网服务提供者ISP（Internet Service Provider），提供IP地址，从而通过ISP接入因特网。\n2.分组交换机（packet switch），如路由器（router）和链路层交换机（link-layer switch）。\n3.主机（host）、端系统（end system），两者意义相同，主机可进一步被分为客户（client）和服务器（server）。\n1.2 网络边缘 - 接入网（access network） 1.定义 指端系统连接到其边缘路由器（edge router）的物理链路。边缘路由器是端系统到任何其它远程端系统的路径上的第一台路由器。\n2.家庭接入网（residential access nets） 常见类型：数字用户线（Digital Subscriber Line，DSL）和电缆因特网接入（cable Internet access）。\n数字用户线：每个用户的DLS调制解调器（modem）使用现有的电话线（双绞铜线）与位于本地电话公司的本地中心局（center office，CO）中的数字用户接入复用器（DSL access multiplexer，DSLAM）来交换数据。\n电缆接入：采用频分复用（frequency division multiplexing）。且这个系统中应用了光纤和同轴电缆，被称为混合光纤同轴（Hybrid Fiber Coax，HFC）。与DSL类似，电缆调制解调器（cable modem）与电缆调制解调器端接系统（Cable Modem Termination System，CMTS）进行数据交换。 光纤到户（Fiber to the home，FTTH）\n3.企业接入网（Enterprise access networks ） 以太网（Ethernet），通过以太网交换机与机构路由器相连，用户通过双绞铜线与以太网交换机相连。\n局域网（LAN）\n4.无线接入网（Wireless access networks） wireless LANs（无线局域网） 与 wide-area wireless access（广域无线接入）\n5.物理媒介（Physical media） 引导型媒体（guided media）\n双绞线（twisted pair ,TP）、同轴电缆（coaxial cable）：两个同心的铜导体、光缆（fiber optic cable）\n非引导型媒体（unguided media）\n地面微波（terrestrial microwave）、卫星无线电信道（satellite）\n6.主机发送数据报文（Host: sends packets of data） 将应用数据分成L bits长度的小块，称为包（packets）。\n以R(bits/sec)的传输速率（transmission rate）将数据包送入接入网。\n链路传输速率，也就是链路容量（link capacity），也就是链路带宽（bandwidth）。\n报文传输时延（packet transmission delay）：将l位数据包传输到链路所需的时间。计算式为L/R。\n1.3 网络核心 1.分组交换网络（包交换网络）Packet-switching 主机将应用层消息分解成包，数据块种有目的地址、源地址等辅助信息。\n单个分组传递到相邻节点，存储后查找转发表，转发到下一个节点。\n在源和目的地之间，每个分组都通过通信链路和分组交换机（packet switch），分组交换机有两类：路由器和链路层交换机。\n关键为存储与转发（store and forward）。对于路由器，在对输出链路传输当前分组的第一个比特之前，需要接收到整个分组。\n则对于长度为L bits的分组，需要L/R的时间完成源到路由器之间的传输，该时间过后路由器接收到整个分组，再进行下一次传输，总时延为2L/R。\n排队时延和分组丢失（queue delay and loss）\n分组丢失（丢包）（packet lost）：输出缓存（output buffer）或称输出队列（output queue）容量有限。\n两个关键的网络核心功能：路由、转发（routing and forwarding）\n每台路由器具有一个转发表（forwarding table），用于将目的地地址映射成输出链路。\n2.电路交换网络 circuit switching 包含以下三个步骤：（1）建立连接；（2）通话；（3）释放连接。效率较低，线路上真正用来传输的时间往往不到10%。\n3.报文交换网络 报文交换是分组交换的前身。报文被整个地交换而非拆分成若干个分组。\n1.4 计算机网络的分类 1.按网络的覆盖范围分类 广域网(Wide Area Network，WAN)\n城域网(Metropolitan Area Network，MAN)\n局域网(Local Area Network，LAN)\n个域网(Personal Area Network，PAN)\n2.按网络的使用者分类 公用网（Public Network）\n专用网（Private Network）\n3.按其它角度分类 传输介质分类：无线和有线\n网络拓扑分类：总线型、星型、环形、网状型\n交换方式分类：电路交换、报文交换、分组交换\n传输技术分类：点对点、广播\n1.5 计算机网络的性能指标 1.速率 指数据的传送速率，每秒传送多少个比特，也称为数据率（Data Rate）和比特率（Bit Rate）。单位为bps。\n**注意：**数据量单位中的K、M、T、G为2的10次、20次、30次、40次幂；速率单位中的k、M、G、T为10的3次、6次、9次、12次。\n2.带宽Bandwidth 在模拟信号在中带宽的单位为HZ，指某个信号所包含的各种不同频率成分所占的频率范围。\n计算机网络中表示线路的数据传输能力，单位和速率单位一致。\n传输速率从主机接口速率、线路带宽、交换器或者路由器接口速率中取最小值。（木桶效应）\n3.吞吐量throughput 单位时间通过某个网络或者接口的实际数据量。常被用于对于实际网络的测量。\n通信相关的应用程序增多时、吞吐量也会随之增大，但是受到网络带宽的限制。\n4.时延delay/latency 由传输时延（transmission delay ，发送时延）、传播时延（propagation delay）、排队时延（queuing delay）、处理时延（processing delay）四部分组成。\n传输时延 或称发送时延，指主机或者路由器发送路由器所耗费的时间，从发送分组的第一个比特开始到最后一个比特发送完毕的时间。 $$ 发送时延=\\frac{分组长度(b)}{发送速率(b/s)} $$\n传播时延 指电磁波在链路上传播一定距离所耗费的时间。 $$ 传播时延=\\frac{链路长度(m)}{电磁波在链路上的传播速率(m/s)} $$\n排队时延 分组进入路由器后，在路由器的输入队列中排队缓存并等待处理。\n网络通信量很大时，可能会造成路由器的队列溢出，使分组丢失，这时候排队时延相当于无穷大。\n处理时延 例如检查分组首部是否误码、提取地址、查找转发接口等。\n5.时延带宽积 $$ 时延带宽积=传播时延(s)×链路带宽(b/s) $$\n表示该链路能够容量的比特数目。也成为以比特为单位的链路长度。\n6.往返时间 往返时间（Round-Trip Time，RTT）指从发送端发送数据分组开始，到发送端受到从接收端发来的相应的确认分组的耗费时间。\n1.6 计算机网络体系结构 1.开放系统互连参考模型 国际标准化组织（International Organization for Standardization，ISO）提出开放系统互连参考模型（Open Systems Interconnection Reference Model，OSI/RM，简称OSI）。是一个七层协议的体系结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n2.TCP/IP参考模型 是一个四层协议的体系结构，网络接口层、网际层、运输层、应用层。核心协议是网际协议IP。\n传输控制协议（Transmission Control Protocol，TCP）和用户数据报协议（User Datagram Protocol，UDP）是TCP/IP体系结构传输层中的两个重要协议。\n3.原理参考模型 五层协议的体系结构：物理层、数据链路层、网络层、传输层、应用层。\n4.各层的任务 应用层：解决通过应用进程的交互来实现特定网络应用的问题\n运输层：解决进程之间基于网络的通信问题\n网络层：解决数据包在多个网络之间传输和路由的问题\n数据链路层：解决数据包在一个网络或者一段链路上传输的问题\n物理层：解决使用何种信号来表示比特0和1的问题\n1.7 专用术语 1.对等实体和实体 实体是指任何可发送或者接收信息的硬件或者软件进程。\n对等实体就是通信双方相同层次中的实体。\n2.协议 协议是控制两个对等实体在“水平方向”进行“逻辑通信”的规则的集合。\n计算机网络协议由三个要素：语法、语义、同步\n语法 用来定义通信双方所交换信息的格式\n语义 用来定义通信双方所要完成的操作。\n同步 用来定义通信双方的时序关系。\n3.服务 在协议的控制下，两个对等实体在水平方向上的逻辑通信使得本层能够向上一层提供服务。要实现本层协议，还要使用下一层所提供的服务。\n在同一系统中相邻两层的实体交换信息的逻辑接口被称为服务访问点。服务访问点用于区别不同的服务类型。\n数据链路层的服务访问点为帧的“类型”字段；网络层的服务访问点为IP数据包的“协议”字段；传输层的服务访问点为“端口号”字段。\n上层要使用下层提供的服务，必须通过与下层交换一些命令，成为服务原语。\n4.数据包术语 对等实体之间传送的数据包被称为该层的协议数据单元（Protocol Data Unit，PDU）。\n物理层：比特流（bit stream）\n数据链路层：帧（frame）\n网络层：分组（packet）；如果是IP协议，也成为IP数据报\n运输层：使用TCP协议，为TCP报文段（segment）；使用UDP协议，为用户数据报（datagram）\n应用层：应用报文（message）\nChapter2. 应用层 2.1 网络应用体系结构 1. 客户/服务器方式 客户和服务器是指通信中所涉及的两个应用进程。客户/服务器方式（Client/Server，CS）所描述的是进程之间服务和被服务的关系。\n基于C/S方式的应用服务通常是服务集中型的。\n2. 对等方式 没有固定的服务请求者和服务提供者，分布在网络边缘的各端系统中的应用进程是对等的，被称为对等方。\n基于P2P的应用是服务分散型 ，突出的特征之一就是它的可拓展性。\n2.2 动态主机配置协议 1.DHCP的作用 网络中的主机开机后自动启动DHCP程序，向DHCP服务器请求网络配置参数，包括IP地址、子网掩码、默认网关、DNS服务器。\nDHCP可为计算机自动配置网络参数，使得计算机“即插即联网”（Plug-and-Play Networking）。\n2.DHCP工作过程 下层协议 使用UDP提供的服务\nUDP端口号 DHCP服务器使用67；DHCP客户使用68\n工作流程 （1）DHCP DISCOVER DHCP客户端广播DHCP发现报文（DHCP DISCOVER）。\n源IP为0.0.0.0，目的IP为255.255.255.255。\n（2）DHCP OFFER DHCP服务器发现DHCP发现报文后，根据封装的MAC地址来查找数据库，查看是否有针对该MAC的配置信息。\n如果有则采用这些配置信息发送DHCP提供报文（DHCP OFFER）；如果没有，则采用默认配置信息进行发送。\n源IP为DHCP服务器的IP地址，目的IP仍为255.255.255.255。\n网络中的所有设备都会接收到DHCP OFFER，对于服务器会丢弃报文；对于主机则会进行检验是否为本主机发出的请求。\nTips：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址时，会使用ARP来确保所选的IP地址从未被网络中的其它主机占用。\n（3）DHCP REQUEST DHCP客户向所选择的DHCP服务器发送一个DHCP请求报文（DHCP REQUEST）。\n源IP为0.0.0.0，目的IP为255.255.255.255。以告知网络中的DHCP服务器是否被选择。\nDHCP REQUEST中封装事务ID、DHCP客户端的MAC地址和接收的租约中的IP地址，提供租约的服务器IP等信息。\n（4）DHCP ACK 服务器向DHCP客户端发送DHCP确认报文（DHCP ACK）。\n源IP为服务器的IP地址，目的IP仍为广播。\nDHCP客户收到该ACK报文段后，就可以使用所租用到的IP地址了。\nTips：在使用租用的IP地址之前，主机还会通过ARP检测该IP地址是否被网络中的其他主机占用。若被占用，则发送DHCP谢绝报文（DHCP DECLINE），并重新发送DHCP DISCOVER。\n（5）更新租用期 当IP的租期过半，DHCP客户会向DHCP服务器发送DHCP REQUEST来请求更新租用期。\n这里的REQUEST报文的源IP为原先租用到的IP地址，目的IP为DHCP服务器的地址。\n（6）续租响应 1.DHCP服务器同意续租，发送DHCP ACK。\n2.DHCP服务器拒绝续租，发送DHCP否认报文（DHCP NACK）。DHCP服务器收到NACK后，需要立即停止使用该租用的IP地址，并重新发送DHCP DISCOVER来获取IP地址。\n3.DHCP服务器未响应，在租用期过了87.5%后，DHCP客户必须重新发送DHCP REQUEST，若未响应，则在租用期到期后立即停止使用IP并重新获取IP地址。\n（7）DHCP RELEASE DHCP客户可以随时提前终止DHCP服务器所提供的租用期，发送DHCP释放报文（DHCP RELEASE）。\n源IP为0.0.0.0，目的IP为255.255.255.255。\n备注 DHCP为了增强协议的健壮性，规定：如果TCP/IP协议栈在初始化的过程中不接受单播IP数据包，则对于DHCP DISCOVER和DHCP REQUEST报文中，通过设置”BROADCAST“标志位为1，告知DHCP服务器，之后使用广播形式进行通信；反之”BROADCAST“标志位设置为0，并在报文中填入自己的MAC地址，则DHCP服务器在数据链路层封装帧的时候可以填入该MAC地址。\n3.DHCP中继代理 DHCP DISCOVER广播报文不会被路由器进行转发，需要给路由器配置DHCP服务器的IP地址并使之成为DHCP中继代理。\n当成为DHCP中继代理的路由器收到广播的DHCP发现报文后，会将其单播给DHCP服务器。\n2.3 域名系统 DNS使用UDP，熟知端口号为53.\n1.因特网的域名结构 域名的结构由若干分量组成，各分量之间用.隔开，分别代表不同级别的域名。每一级的域名都由英文字母和数字组成，不超过63个字符，也不区分大小写。完整的域名不超过255个字符。\n如：\u0026hellip;三级域名.二级域名.顶级域名。eecs.nbu.edu.cn。\ncn是顶级域名，代表中国；edu是在其下注册的二级域名，代表教育机构；nbu是在edu下注册的三级域名，代表宁波大学；eecs代表该校自行管理的四级域名，为信息学院。\n顶级域名 顶级域名（Top Level Domain，TLD）分为以下三类。\n1.国家顶级域名(nTLD)\n2.通用顶级域名(gTLD)：com代表公司企业；net代表网络服务机构；org代表非营利性组织；int代表国际组织；edu代表美国教育机构；gov代表美国政府部门；mil代表美国军事部门\n3.反向域(arpa)：用于反向域名解析。\n二级域名 在国家顶级域名下注册的二级域名由该国家自行确定。\n我国将二级域名划分为以下两类：\n1.类别域名：共七个，ac科研机构；com工商金融等企业；edu教育机构；gov政府部门；net提供网络服务的机构；mil军事机构；org非营利性组织。\n2.行政区域名：共34个，适用于我国各省、自治区、直辖市。\nTips：名称相同的域名其等级未必相同。\n2. 因特网上的域名服务器 域名系统DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。\n分为以下四个类型：\n根域名服务器 最高层次的域名服务器，每个根域名服务器都知道所有的顶级域名服务器的域名和IP地址。\n因特网上共有13个不同IP地址的根域名服务器，但每台服务器实际上是分布在世界各地的计算机组成的服务器群集。\n顶级域名服务器 这些域名服务器负责管理在其下注册的所有二级域名。\n当收到DNS查询请求时就会给出响应的回答，这可能是最终的查询结果，也可能是下一级权限域名服务器的IP地址。\n权限域名服务器 负责管理某个区的域名，每个主机的域名都必须在某个权限域名服务器所在处注册登记。\n权限域名服务器知道其管辖的域名和IP地址的映射关系。也知道其下级域名服务器的地址。\n本地域名服务器 主机发送DNS请求报文时首先会被送往该主机的本地域名服务器。\n本地域名服务器有代理的作用，会将报文转发给上述的域名服务器的等级结构中。\n本地域名服务器也叫默认域名服务器，其IP地址需要直接配置在需要域名解析的主机中。\n3.域名解析过程 因特网有两种域名查询方式：递归查询和迭代查询。\n递归查询主要是各级域名服务器接受上一级的委托后直接对下一级的域名服务器发起查询请求。\n迭代查询通过本地域名服务器依次访问根域名服务器、顶级域名服务器、权限域名服务器，对应的服务器地址由上一级域名服务器给出。\nTips：对于含有CDN的服务器的访问，在权威服务器处可能不会直接返回对应的IP地址，而是返回其对应的CDN服务器的权威域名服务器的域名。（重定向）\n4.域名系统高速缓存 高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。（记录时间通常为2天）\n不但在本地域名服务器中需要高速缓存，在用户主机中也需要。许多用户主机在启动时则从其本地域名服务器下载所有映射信息，只有在查询信息不存在时则向本地域名服务器发出查询请求。\n5.DNS记录和报文 DNS服务器存储了资源记录（Resource Record，RR），RR提供了从主机名到IP地址的映射。\nRR是一个四元组：{name，value，type，ttl}。\nTTL是该记录的生存时间，记录了应当从缓存中删除的时间。\nType A 此时Name是主机名，value是对应的IP地址。\n一条类型为A的RR提供了从标准主机名到IP地址的映射。\nType NS 对该域中的主机来说Name是域（如foo.com），Value是一个知道如何获取该域中主机IP地址的权威域名服务器的主机名。\n例如(foo.com dns.foo.com NS)就是一条类型为NS的RR。\nType CNAME Value是主机别名（host aliasing）Name对应的规范主机名（canonical hostname）。\n该记录能够向查询的主机提供一个主机对应的规范主机名。\n主机别名要比规范主机名来的容易记忆。\nType MX Value是一个别名为Name的邮件服务器的规范主机名。\nMX记录允许邮件服务器主机名具有简单的别名。通过MX记录，一个公司的邮件服务器和其他服务器（例如它的Web服务器）可以拥有相同的别名。\nDNS报文格式 首部区域 第一个字段（标识符）是一个16bit的数，用于标识该查询。会被复制到对查询的回答报文中，以便让客户用来匹配发送的请求和接收的回答。\n标识字段含有若干标识：1.查询/回答 2.权威的 3.希望递归 4.递归可用。\n首部中也包含一些有关数量的字段：问题数、回答RR数、权威RR数、附加RR数。\n问题区域 包含Name字段和Type字段\n回答区域 包含了对最初请求的名字的资源记录。再回答区域可以包含多条RR，因此一个主机名能有多个IP地址。\n权威区域 权威区域包含了其它权威服务器的记录\n附加区域 附加区域包含了其他有用的记录。例如：一条MX请求的查询，回答区域包含了一个RR，提供了规范主机名，在附加区域中，该记录也提供了对于邮件服务器的规范主机名所对应的IP地址。\n2.4 文件传输协议 FTP提供交互式的访问，允许客户明确文件类型与格式，并允许文件具有存取权限。\nFTP常见的用途是在计算机之间传输文件，尤其是用于批量传输文件。FTP的另一个用途是让网站的设计者将构成的网站内容的大量文件批量上传到他们的Web服务器。\n1.FTP的工作原理 FTP采用C/S方式，由主动模式和被动模式。\n主动模式 FTP服务器主动连接FTP客户。\n（1）FTP服务器监听监听端口号21，FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户和服务器之间传送FTP的相关控制命令。\n（2）有数据要传输时，FTP客户通过命令通道告知FTP服务器，让FTP服务器和FTP客户的另一个临时端口号建立TCP连接，为数据通道。\n（3）FTP服务器使用20端口和FTP客户告知的临时端口号建立TCP连接，用于文件的传输。\n被动模式 其余步骤与主动模式类似，在数据通路的建立过程中，为客户向服务器发起TCP连接。即在FTP服务器协商好临时端口后被动地等待FTP客户的TCP连接。\n2.5 电子邮件 1.电子邮件的组成 用户代理 用户代理是用户和电子邮件系统的接口，又称为电子邮件客户端软件。\n邮件服务器 邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接受邮件，还要维护用户的邮箱。\n电子邮件协议 发送方使用用户代理通过邮件发送协议（例如SMTP），将邮件发送给发送方的服务器；发送方服务器通过邮件发送协议将邮件发送到接收方的服务器；接收方使用用户代理通过邮件读取协议（例如POP3和IMAP）从接收方服务器中读取邮件。\n2. 电子邮件的发送和接受过程 （1）发送方作为SMTP客户，与发送方邮件服务器中的SMTP服务器进行TCP连接，端口号为25。\n（2）发送方邮件服务器中的SMTP客户和接收方邮件服务器中的SMTP服务器进行TCP连接，端口号为25。\n（3）接收方的用户代理作为POP3客户，从接收方邮件服务器中的POP3服务器进行TCP连接，端口号为110。\n3. SMTP的基本工作过程 SMTP使用C/S方式通信，负责发送邮件的SMTP进程为SMTP客户，负责接收邮件的SMTP进程为SMTP服务器。\nSMTP客户给SMTP服务器发送14条命令，SMTP服务器收到命令后给SMTP客户发送21种应答。\n（1）TCP连接建立后，服务器推送”服务就绪“给用户。\n（2）客户使用”HELO“命令向服务器说明身份，告知自己的域名。\n（3）服务器认为身份有效，发送应答代码250，否则发送其它错误代码（如421服务不可用）\n（4）客户收到应答后，使用”MAIL FROM”命令告知邮件来自何处。\n（5）服务器若认为合法则发送250。\n（6）客户收到应答后，使用命令“RCPT To“来告诉服务器去往何处。\n（7）服务器若由该收件人邮箱，则发送250。\n（8）客户收到应答后，发送”DATA”命令告知服务器准备进行内容的发送。\n（9）服务器若准备接收则发送代码354。\n（10）客户收到应答后，开始发送数据。\n（11）客户完成数据发送后，还要发送结束符\u0026rsquo;.\u0026rsquo;。\n（12）服务器若收件成功，则发送250。\n（13）客户收到应答后，使用命令“QUIT”请求断开连接。\n（14）服务器发回响应代码221表示接受请求并主动断开TCP连接。\n4.电子邮件的信息格式 首部包含From、To、Cc、subject，其中From和To是必填的。\nFrom 填入发件人的电子邮件地址，一般由邮件系统自动填入。\nTo 填入一个或者多个收件人的电子邮件地址。\nCc 抄送人的地址。\nSubject 邮件的主题，反应的是邮件的内容。\n5.多用途因特网邮件拓展 SMTP只能传输ASCII码文本数据，通过多用途因特网邮件拓展（Multipurpose Internet Mail Extensions，MIME）将非ASCII码的数据转换为ASCII码数据。随后采用SMTP协议进行传输。\n6.常用的邮件读取协议 邮局协议 邮局协议（Post Office Protocol，POP），POP3是其第三个版本。\nPOP3是个非常简单、功能有限的邮件读取协议。用户只能以下载并删除的方式或者下载并保留的方式对邮件服务器上的邮件进行简单管理，不能进行如创建文件夹、分类等操作。\nTCP连接，熟知端口号为110。\n因特网邮件访问协议 因特网邮件访问协议（Internet Message Access Protocol，IMAP）是功能比POP3强大的邮件读取协议。用户在自己的计算机上可以操作邮件服务器的邮件，就像在本地操作一样。IMAP是一个联机协议。\nTCP连接，熟知端口号为143。\n2.6 超文本传输协议 1.万维网 万维网是一个大规模的、联机式的信息存储所，是运行在因特网上的一个分布式应用。万维网通过网页之间的超链接，将不同网站的网页连接成一张逻辑上的信息网。\n2.统一资源定位符 万维网使用统一资源定位符（Uniform Resource Locator，URL）来指明因特网上的各种类型的“资源“的位置。\n由协议、主机、端口、路径组成。\u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;\n3.HTTP简介 超文本传输协议（HyperText Transfer Protocol，HTTP）定义了以下功能的实现方法：1.浏览器（即万维网客户进程）向万维网服务器请求万维网文档；2.万维网服务器把万维网文档传输给浏览器。\n基于TCP连接的，周知端口号为80.\n非持续连接方式 HTTP/1.0采用非持续连接方式。在该方式下，每次浏览器进程请求一个文档都要与服务器建立TCP连接，收到响应后则关闭连接。\n请求一个文档由接近2RTT的开销。\n持续连接方式 HTTP/1.1支持持续连接方式，万维网服务器在发送响应后仍然保持TCP连接，使同一个万维网客户和自己可以继续在这条TCP连接上传输后续的HTTP请求报文和响应报文。节省了很多RTT。\n4.报文格式 HTTP请求报文格式 第一行是请求行。”方法“字段开始，后跟一个空格，后跟URL，后再跟一个空格，后跟”版本“字段，最后回车换行（CRLF）。\n第二行开始是首部行。每一个首部行由”首部字段名“开始，后跟一个冒号，再跟一个空格，然后是该字段的取值。最后回车换行。\n可以有很多首部行。\n最后的首部行下面是一个空行。\nHTTP响应报文格式 第一行是状态行。由”版本“字段开始，后跟空格，后跟”状态码“字段，后跟空格，最后跟”短语“字段，最后CRLF。\n除状态行，其余部分和HTTP请求报文格式类似。\n状态码 常见的状态码包括\n200 OK：请求成功，信息返回在响应报文当中。\n301 Moved Permanently：请求的对象被永久转移了，新的URL在响应报文当中的”Location“首部行中。\n400 Bad Request：一个通用差错代码，表示该请求不能被服务器理解。\n404 Not Found：被请求的文档不在服务器上。\n505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP版本。\n5.Cookie Cookie提供了一种机制，使得万维网服务器能够”记住“用户，而无须用户主动提供标识信息。\n过程如下：\n（1）浏览器初次向Web服务器发送HTTP请求报文，Web服务器回为其产生一个唯一的Cookie识别码，并以此为索引在Web服务器的后端数据库中创建一个项目，用来记录该用户访问该网站的各种信息。\n（2）Web服务器给浏览器发回HTTP响应报文，包含一个首部字段”Set-Cookie“，该字段的取值就是Cookie识别码。浏览器收到响应报文后，就在特定的Cookie文件夹中添加一行，记录域名和识别码。\n（3）再次访问时，每发出一个HTTP请求报文，浏览器都会从Cookie文件中取出该网站的Cookie识别码，放到HTTP请求报文的Cookie首部行中。\n6.Web缓存和代理服务器 原始服务器会给每个响应对象设置一个”修改时间“字段（Last-Modified）和一个有效日期字段（Expires）。当主机需要请求原始服务器中的某个文档时，首先向代理服务器（Proxy server）发送请求，若代理服务器中该文档未过期，则直接将响应报文发送回给主机，否则该代理服务器就向原始服务器发送请求报文，其中包含首部行”If-modified-since“，取值即为该文档的修改日期。\n原始服务器比较该字段值和该文档的修改时间，若一致则回送304 Not Modified。代理服务器更新有效时间，并向主机发回响应。\n若不一致则原始服务器给代理服务器发送带有该文档的响应报文，则代理服务器也更新了该文档的内容和有效期，随后再将该文档响应发送会给主机。\nChapter3. 运输层 3.1 概述 运输层（Transport layer）协议为运行在不同主机上的应用进程提供了逻辑通信（logic communication）。\n传输层协议是在端系统中而不是在路由器中实现的。\n将主机间交付拓展到进程间交付被称为运输层的多路复用（multiplexing）和多路分解（demultiplexing）。\n3.2 多路复用和多路分解 将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。\n在源主机中将不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，将报文段传输到网络层的工作为多路复用。\n1.端口号 TCP/IP体系的运输层使用端口号来区别应用层的不同应用进程。\n端口号用16比特表示，取值为0~65535；\n熟知端口号 well-known port number, 0~1023，IANA（因特网号码分配管理局）将这些端口号指派给了TCP/IP协议中的一些重要的应用协议。\n例如FTP使用21/20；HTTP使用80；DNS使用53；SMTP使用25；DHCP使用67/68；BGP使用179；HTTPS使用443；RIP使用520\n登记端口号 1024~49151，为没有熟知端口号的应用程序使用，但需要进行手续登记以防重复。\n短暂端口号 49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。\n2.TCP的多路分解和复用 TCP套接字是由一个四元组进行标识的：（源IP、源端口、目的IP、目的端口）【需要向源进行反馈】\n发送方复用：IP数据报首部中协议字段为6，表示封装的是TCP报文段\n接收方分解：网络层根据首部协议字段向上交付给UDP\n3.UDP的多路分解和复用 UDP套接字是由一个二元组进行标识的：（目的IP、目的端口）\nIP数据报首部中协议字段为17，表示封装的是UDP用户数据报\n接收方分解：网络层根据首部协议字段向上交付给TCP\n4.特例 OSPF报文并不使用运输层的UDP或者TCP进行封装，而是直接使用网络层的IP进行封装，封装时的协议字段值为89。\n3.3 UDP和TCP的对比 UDP是无连接的；TCP是面向连接的\nUDP支持广播、多播和广播；TCP仅支持单播\nUDP是面向应用报文的，对应用进程交付下来的报文既不合并也不拆分，而是保留这些报文的边界。\nTCP是面向字节流的，将应用进程交付下来的应用报文仅仅看作一连串的、无结构的字节流。TCP不保证接收方应用进程所接收到的数据块和发送方应用进程所发出的应用层报文之间具有对应大小的关系。\nUDP用户数据报首部仅有8各字节；TCP报文段首部大小20~60字节不等。\n3.4 用户数据报协议UDP 1.UDP报文段结构 首部+应用数据报文\n首部中包含：源端口号、目的端口号、长度、检验和\n2.UDP检验和 UDP校验和提供了差错检测功能，但是对差错恢复无能为力。\n发送方的UDP对报文段中的所有16比特字的和进行反码运算，注意在求和时遇到的所有溢出都要进行回卷操作。\n接收方将所有16比特字进行相加，包括检验和，如果没有差错结果必然为16个1。\n3.5 传输控制协议TCP 1.TCP报文段首部格式 TCP发送数据时，从发送缓存中取出一部分或者全部字节并给其添加一个首部使其成为TCP报文段后再进行发送。\n由20字节的固定首部和最大40字节的扩展首部组成。\n源端口（Source Port）和目的端口（Destination Port）占16比特，标识发送该TCP报文段的应用进程。\n序号（Sequence number）占32比特，当序号取到最后一个时，下一个序号回到0。指出本TCP报文段数据载荷的第一个字节的序号。\n确认号（Acknowledgement number）占32比特，和序号类似，指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认（comulative acknowledgment，累计确认）。\n确认标志位ACK：取值为1时确认号字段才有效；取值为0时确认号字段无效。TCP规定在连接建立后传送的所有TCP报文段ACK需置1。\n首部长度（Header Length）占4比特，并以4字节为单位，用来指出TCP报文段数据载荷部分的起始处距离TCP报文段起始位置的距离。首部固定长度为20字节，因此该字段最小为0101（5*4=20），最大为60，即该字段最大为1111（15*4=20）\n保留字段：占6比特，目前应置为0\n窗口（Window size value）占16比特，以字节为单位，指出发出本报文段的一方的接收窗口。\n检验和（checksum）占16bit\n紧急指针（urgent pointer）16bit，以字节为单位，指明紧急数据的长度。发送方有紧急数据时，可以将其插队到缓存最前面，并立刻封装进行发送。紧急指针会指出本报文段数据载荷包含了多长的紧急数据，紧急数据后面是普通数据。接收方也不必缓存直接上交。\n同步标志位SYN：在TCP建立连接时用来同步序号。\n终止标识位FIN：用来释放TCP连接。\n复位标志位RST：用来复位TCP连接，当RST=1时，表明TCP连接出现了异常，必须释放连接后重连。还可以用来拒绝一个非法的报文段或者拒绝打开一个TCP连接。\n推送标志位PSH：接收方的TCP接收到PSH为1的报文段回尽快上交应用进程，不必等到接收缓存都填满后再上交。\n紧急标志位URG：和紧急指针字段配合使用。为1时紧急指针字段有效。\n选项字段包含：\n最大报文段长度（Maximum Segment Size，MSS）用来指出TCP报文段数据载荷部分的最大长度。\n窗口扩大选项：用来扩大窗口，提高吞吐率。\n时间戳选项：用于计算RTT，处理序号超范围清空，防止序号绕回（Protect Against Wrapped Sequence Numbers，PAWS）\n2.“三次握手”建立TCP连接 TCP客户：\nCLOSED状态\u0026mdash;(发送SYN包,SYN=1,seq=x)\u0026mdash;SYN-SENT状态\u0026mdash;(接收SYN,ACK包,发送ACK=1,seq=y,ack=x+1)\u0026mdash;ESTABLISHED\nTCP服务器：\nCLOSED状态\u0026mdash;LISTEN监听\u0026mdash;(接收SYN包,发送SYN=1,ACK=1,seq=y,ack=x+1)\u0026mdash;-SYN-RCVD状态\u0026mdash;(接收ACK=1,seq=x+1,ack=y+1)\u0026mdash;ESTABLISHED\nTips：\nTCP请求报文段没有数据载荷（SYN=1的报文段不能携带数据，但是要消耗掉一个序号）；\n对于最后一个ACK，TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不会消耗序号，即如果该ACK不携带数据，客户端发送的下一个报文段的序号仍为x+1。\n3.”四次挥手“释放TCP连接 Tips：\nTCP规定FIN等于1的TCP报文段即使不携带数据，但也要消耗掉一个序号。\nMSL（Maximum Segment Lifetime）意思是最长报文段寿命，RFC建议为2分钟。进入时间等待是为了避免数据报丢失而导致服务器方不断地进行超时重传。也可以使得本次TCP连接所产生的报文段从网络中消失，从而使得新的TCP连接中不会出现旧连接的报文段。\n保活计时器 当TCP服务器每次收到TCP客户进程的数据时，就重新设置并启动保活计时器（Keepalive Timer）。若保活计时器定时周期内未收到TCP客户进程发来的数据，到期后TCP服务器进程就向TCP客户进程发送一个探测报文段，反复发送10次若仍无响应则判断TCP客户进程所在主机出现故障，接着就关闭当前的TCP连接。\n4.可靠数据传输协议rdt rdt1.0 经完全可信的信道传播\nrdt2.0 经有比特差错信道的可靠数据传输；\n假定分组按序被接收\n基于重传机制的rdt：自动重传请求（Automatic Repeat reQuest，ARQ）\nARQ中处理比特差错的功能：差错检测、接收方反馈、重传\n它是一种停等协议（stop-and-wait）\n概括以下就是：基于差错检测和反馈机制，根据反馈来判断是否进行重传\n但是反馈的ACK和NAK也可能出错，sol：进行重传，并通过seq判断是重传的NAK（ACK）还是新发出的。\nrdt2.1 对seq进行模2操作，若接收新分组则模2结果发生变化\nrtd2.2 在ACK、NAK中将参数0、1带入，以减少一定的状态\nrdt3.0 经有比特差错和丢包可能的信道的可靠数据传输\n发送方负责检测和恢复丢包工作\n这里引入了倒计时定时器（countdown timer）[重传计时器]\n但rdt3.0仍为停等协议，于是引出了流水线（pipelining）工作\n对于流水线中的差错、超时、丢失，处理的两种基本方式是回退N步（Go-Back-N，GBN）和选择重传（Selective Repeat，SR）\n回退N步GBN GBN协议也常被成为滑动窗口协议（sliding-window protocol），N通常被成为窗口长度（window size）\nGBN的发送方必须做到以下若干事件的响应：\n上层调用 发送方首先检查发送窗口是否已满，若未满则产生一个分组并将其发送，反之将数据返回给上层\n收到ACK 由于采用累计确认（cumulative acknowledgment），若收到序号为n的分组的确认，即ack=n+1，那么表明接收方已经正确的接收到了序号为n及其以前的所有分组。\n超时事件 如果出现超时，那么发送方将重传所有已经发送但还未被确认过的分组。\n一个窗口中有一个计时器，它一般为最早已经发送但未被确认的分组的计时器。\n如果收到ACK后，仍有已经发送但未被确认的分组，则计时器被重启，反之停止该计时器。\n选择重传SR 对于GBN，单个分组的差错可能引起GBN重传大量分组，而许多分组根本没有必要重传。\n对于选择重传SR，通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。\n对于发送方 SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组被收到为止。\n[如果收到了一个ACK，倘若该ACK处于窗口之中，那么则标记该分组已被确认，如果该分组正好为send_base，即第一个已发送但未被确认，那么则进行窗口移动，基需要send_base移动到具有最小序号的未确认分组处。窗口移动后，如果有序号落在未发送分组中，则发送]\n对于接收方 如果接收窗口内的分组被收到，那么则送回一个ACK。如果以前没有收到该分组，那么进行缓存。如果该分组的序号等于接收窗口的基序号rev_base，则该分组及其以前的缓存号连续，分组交付给上层。\n如果序号是以前接受过的，那么则发送一个冗余ACK即可。\nTCP的选择确认 TCP的选择确认（selective acknowledgement，SACK）允许TCP接收方有选择地确认失序报文段，而不是累计确认最后一个正确接收的有序报文段。\n5.TCP的流量控制 TCP未其应用提供了流量控制服务（flow-control service）以消除发送方使接收方缓存溢出的可能性。\n注意：TCP发送方也可能因为IP网络的拥塞而被遏制，这种形式的发送方的控制被称为拥塞控制（congestion control）。\nTCP让发送方维护一个成为接收窗口的变量rwnd。接收窗口给发送方一个指示，该接收方还有多少可用的缓存空间。\nTCP发送方的发送窗口=min[自身拥塞窗口，TCP接收方的接收窗口]\n当发送方接收到来自接收方的确认报文，则将发送窗口移动至ack处，随后根据确认报文中的接收窗口大小动态地调整发送窗口。\nTCP发送方当接收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文，以避免死锁。\n6.TCP的拥塞控制 某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变差，这种情况叫做拥塞（congestion）。\n发送方要维护一个叫做拥塞窗口（Congestion Window）的状态变量cwnd，其值取决于网络的拥塞程度和所采用的TCP拥塞控制算法。\n判断网络拥塞的依据是：没有按时收到应到达的确认报文段而产生了超时重传。\n发送方维护的发送窗口（Sender Window）的状态变量swnd。swnd=min(cwnd,rwnd)。\n发送方还要维护一个慢开始门限（SSThresh）的状态变量ssthresh：\ncwnd\u0026lt;ssthresh，使用慢开始算法；cwnd\u0026gt;ssthresh，停止使用慢开始算法而改用拥塞避免算法；等于则都可以使用。\n慢开始 slow-start\ncwnd初始值为1个MSS（最大报文段长度）；ssthresh也有初始值，假设为16.\n每当传输的报文段首次被确认就增加一个MSS，即每个确认报文段就将cwnd增加一个MSS。\n相当于在一个传播轮次中cwnd翻倍。\n当即将超过ssthresh时，继续翻倍显然不合理，当cwnd等于ssthresh时，进入拥塞避免。\n拥塞避免 congestion avoidance\n每个RTT只将cwnd的值增加一个MSS。相当于对于每一个新到达的确认，cwnd增加一个MSS*（MSS/cwnd）字节。\n例如MSS是1460字节并且cwnd是14600字节。则在一个RTT内发送10个报文段。每到达一个ACK就增加1/10MSS的cwnd，因此在收到对所有10个报文段的确认后，cwnd就增加了一个MSS。\n是一种线性增长。\n当重传计时器超时，则判断网络很有可能出现了拥塞，进行：\n1.将ssthresh更新为发生拥塞时的cwnd的一半；2.将cwnd减少为1，重新开始执行慢开始算法。\n快速重传 fast retransmit\n对于拥塞，对于发送方来说可以有两种指示方式：1.重传计时器超时，2.收到三个冗余的ACK\n所谓快速重传就是发送方要尽快进行重传，而不是等待重传计时器超时后再进行重传。即收到三个冗余的ACK。这就要求了接收方要立即发送确认信息，即使受到了失序的报文段也要立即发出对已收到的报文段的重复确认（发出冗余ACK）。\n快速恢复 fast recovery\n发送方一旦收到三个冗余ACK，就知道仅仅丢失了个别报文段。于是不启动慢开始算法，而执行快速恢复算法。\n发送方将慢开始门限ssthresh和cwnd值调整为当前窗口的一半，开始执行拥塞避免算法。\n也有的快速恢复是把快速恢复开始时的cwnd再增大一点，即等于新的ssthresh+3。（TCP Reno）[既然发送方收到三个冗余ACK，则代表有三个数据报文段已经离开了网络，在接收方的接收缓存中，网络中减少了三个报文段，因此可以将cwnd适当扩大一些]\n7.TCP可靠传输的实现 滑动窗口机制（sliding window）\n对于不按序到达的数据，TCP无明确规定，通常对不按序到达的数据先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，然后再按需交付上层的应用进程\nTCP要求接收方必须有累积确认和捎带确认机制，这样可以减少传输开销。接收方不应过分推迟发送确认，否则会导致不必要的重传，TCP标准规定，确认推迟的时间不应超过0.5s。\n8.TCP超时重传时间的选择 指数加权移动平均 Exponential Weighted Moving Average，EWMA\n初始状态下：EstimatedRTT=SampleRTT；\n当获取新的样本时：EstimatedRTT=(1-α)·EstimatedRTT+α·SampleRTT （RFC推荐α=0.125）\n偏差加权移动平均 测量得到的样本RTT值：SampleRTT；RTT偏差：DevRTT；\n初始状态下：DevRTT=SampleRTT/2；\n在获取新的样本时：DevRTT=(1-β)·DevRTT+β·|SampleRTT-EstimatedRTT|（RFC推荐β=0.25）\n超时重传时间RTO TimeoutInterval=EstimatedRTT+4·DevRTT\n初始的TimeoutInterval的值为1秒。同时，当出现超时情况时，其值加倍；反之收到报文则通过上式进行计算。\n相关问题 当出现重传时，发送方极有可能无法判断收到的确认报文是对原发送报文的确认还是重传报文的确认，会导致对RTT的估计出错，因此Karn提出一个算法：在计算加权平均往返时间时，只要报文段重传了，就不采用其样本RTT。即重传时EstimatedRTT不被重新计算。\n而如果报文段的时延突然上升且保持。在原来计算出的重传时间RTO中不会受到确认报文段，于是重传。根据Karn，重传不被重新计算，这样RTO无法被更新，导致重传不断进行。\n对Karn算法进行修正，即重传一次，RTO则增大一些，一般是变成两倍。\nChapter4. 网络层 4.1 概述 1. 数据平面和控制平面 数据平面 数据平面功能，即网络层中每台路由器的功能，该数据平面功能决定到达路由器输入链路之一的数据报（即网络层分组）如何转发到该路由器的输出链路之一。\n控制平面 控制平面功能，即网络范围的逻辑，该控制平面功能控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。\n2. 分组转发和路由选择 分组转发 forwarding\n当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。\n转发是在数据平面中实现的唯一功能。将一个分组从输入链路接口转移到适当的输出链路接口的路由器本地操作。\n通常在几纳秒中完成，因此通常使用硬件来实现。\n路由选择 routing\n网络层必须决定这些分组所采用的路由或者路径。计算这些路径的算法被称为路由选择算法（routing algorithm）。\n是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。\n3. 网络层向上层提供的服务 面向连接的虚电路服务 核心思想是“可靠通信应由网络自身来保障”\n必须首先建立网络层连接—虚电路（Virtual Circuit，VC），以保证通信双方所需要的网络资源。\n通信双方沿着已建立的虚电路发送分组。\n这是一条逻辑上的连接，分组沿着这条逻辑链接按照存储转发的方式进行传送。\n但不被使用。\n无连接的数据报服务 核心思想是：可靠的通信应由用户主机来保障。\n不需要建立网络层连接。每个分组可以走不同的路径。\n通信结束后双方没有需要释放的连接。\n分组可能误码、重复、失序。是一个尽最大努力（best effort）的分组交付功能。\n4.2 网际协议IP 网际协议（Internet Protocol，IP）是TCP/IP体系结构中网际层中的核心协议。\n配合使用的四个协议：\n地址解析协议（Address Resolution Protocol，ARP）\n逆地址解析协议（Reverse Address Resolution Protocol，RARP）\n网际控制报文协议（Internet Control Message Protocol，ICMP）\n网际组管理协议（Internet Group Management Protocol，IGMP）\n1. 异构网络互连 网络根据其用户需求的不同拥有不同的拓扑、性能、协议，对于这些众多的异构网络，通过路由器进行互连。这些异构网络的网络层都使用相同的网际协议IP，从网络层看他们都好像一个统一的网络，即IP网。\n2.IPv4地址概述 32比特的唯一标识符，由因特网名字和数字分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）进行分配。\nIPv4的表示方法 采用点分十进制表示方法\n分类编址 包含网络号和主机号两个部分\n网络号：用来标志主机（或路由器）的接口所连接到的网络。\n主机号：用来标志主机（或路由器）的接口。\n分类编址将IPv4地址分成以下五类：\nA类地址：网络号8b，主机号24b，网络号最前面一位固定为0.\nB类地址：网络号16b，主机号16n，网络号最前面两位固定10.\nC类地址：网络号24b，主机号8b，网络号最前面三位固定110.\nD类地址：多播地址，最前面四位固定1110.\nE类地址：保留地址，最前面四位固定1111.\n只有A、B、C类主机可以分配给网络中的主机（或路由器）的各接口。\n主机号全0的地址是网络地址，不能分配给接口，主机号全1的是广播地址，不能分配。\nA类地址 网络号8b，第一位固定0\n最小网络号0，保留\n最大网络号127，用作本地环回测试地址，不指派\n最小的本地环回测试地址为127.0.0.1，最大的本地环回测试地址为127.255.255.254\n第一个可指派的网络号为1，网络地址为1.0.0.0\n最后一个可以指派的网络号为126\n可以指派的网络数量为126\n每个网络可以分配的IP地址的数量为2^24-2 [24位主机号，减去全0和全1]\nB类地址 网络号16b，前两位固定10\n最小可指派的网络号为128.0[2字节的网络号]\n最大可指派的网络号为191.255\n可指派的网络数量为2^(16-2)=16384\n每个网络可以分配的IP地址的数量为2^16-2=65534\nC类地址 网络号24b，前三位固定110\n最小可指派的网络号为192.0.0\n最大可指派的网络号为223.255.255\n可指派的网络数量为2^(24-3)=2097152\n每个网络可以分配的IP地址的数量为2^8-2=254\n通过左起第一个十进制数可以判断网络类别：\n小于127的是A类，128~191的是B类，192~223的是C类\n地址0.0.0.0是一个特殊的IPv4地址，只能作为源地址使用，表示“在本网络上的本主机”，比如DHCP DISCOVERY。\n地址255.255.255.255只能作为目的地址使用，表示“只在本网络上进行广播（各路由器均不转发）”。\n对于网络的分配，需要考虑到其连接的路由器端口也需要IP地址，广播地址和网络地址各需要一个IP地址。\n划分子网 将原来分类编制后的网络号再进行一定的拓展，选取原本的若干主机号将其定位子网号，从而实现进一步的划分\n子网掩码：将网络号和子网号的对应位置置为1，主机号置为0，这样将IP地址和子网掩码进行与操作可以获取网络号和子网号。\n对于默认子网掩码，A类为255.0.0.0，B类为255.255.0.0，C类为255.255.255.0。\n无分类编址 无分类域间路由选择（Classless Inter-Domain Routing，CIDR）消除了传统的A、B、C类地址以及划分子网的概念。\n改为两级结构：网络号和主机号\n原网络号在CIDR被称为网络前缀（Network-Prefix），是不定长的。\n与子网掩码类似，CIDR采用了32位的地址掩码（Address Mask），它消除了划分子网的概念，但经常也被成为子网掩码。\n采用斜线记法（Slash Notation）[亦称为CIDR记法]，在地址后面加上斜线\u0026quot;\\\u0026quot;，表明其网络前缀的长度。\nCIDR将网络前缀相同的IPv4地址组成一个“CIDR地址块”。\n路由聚合 由于一个CIDR地址块可以包含多个地址，在路由表中可以利用CIDR地址块来查找目的网络。这种地址的聚合被称为路由聚合（route aggregation）。路由聚合也被称为构造超网（supernetting）。方法就是找最长的共同前缀。\n网络前缀越长，地址块越小，路由就越具体，因此当有多条转发条目匹配时，应当选择最长前缀的[最具体的]，被称为最长前缀匹配。\nIPv4地址的应用规划 将给定的IPv4地址块划分成几个更小的地址块（或子网）。分为使用定长的子网掩码（Fixed Length Subnet Mask，FLSM）和使用变长的子网掩码（Variable Length Subnet Mask，VLSM）。\n对于变长的子网掩码，其通过已申请到的CIDR地址块中按需划分出更小的地址块，每个块的起始位置不能随意选取。最好连续。\n3.地址解析协议 IPv4地址和MAC地址 MAC地址（Media Access Control Address，MAC，媒体存取控制位址）封装在帧首部（数据链路层的协议数据单元PDU）。IP地址在IP数据报的首部。\n分组传递过程中，源IP和目的IP始终不变，而源MAC和目的MAC会逐链路不断变化。\n路由器在收到IP数据报后，根据其首部中的目的IP地址的网络号部分，基于自己的路由表进行查表转发。查表转发的结果可以指明IP数据报的下一跳路由器的IP地址，但无法指明该IP地址所对应的MAC地址，因此引入了地址解析协议（Address Resolution Protocol，ARP）。\nARP 每台主机都会维护一个ARP高速缓存表，记录IP地址和MAC地址的对应关系。\n当ARP高速缓存表中找不到想要的MAC地址，那么主机就要发送ARP请求报文来获取对应的MAC地址。\nARP请求报文中包含源IP、源MAC、希望得到MAC的IP地址。被封装在MAC帧中进行发送，MAC帧的目的地址位广播地址（FF-FF-FF-FF-FF-FF）。\n其它主机收到广播帧后，将其封装的ARP请求报文上交处理。上层的ARP进程进行解析，判断是否发出响应。ARP响应报文告知目标IP对应的MAC地址，将ARP响应报文封装在MAC帧中发送，目的地MAC为发出ARP请求的源MAC，即进行单播。\n其它主机收到单播帧后，判断MAC地址，若不匹配则丢弃，匹配则上交ARP响应报文，上层进程解析，将其中的对应记录添加到ARP高速缓存表中。\n高速缓存表中有动态和静态两种类型：动态类型是指主机通过ARP协议自动获取的，生命周期一般为2分钟。\nTips：ARP协议解决同一个局域网上的IP和MAC的映射问题，而不能跨网络使用。\n除了ARP请求报文和响应报文，还有用于检查IP地址冲突的“无故ARP（或者免费ARP）（Gratuitous ARP）”\n4.IP数据报 转发过程 主机发送 源主机通过自己的IP和掩码相与得到自己所在的网络号，同时拿目的IP和自己的掩码进行相遇，得到的网络号如果不相等，那么判断不在同一个网络中。[考虑：如果在同一个网络中，那么使用同一个子网掩码与出来的结果必定相同]\n在同一个网络中的网络设备之间可以直接访问。\n每一个网络中存在一个默认网关，在间接交付时，源主机通过ARP获取默认网关的MAC。由默认网关代替源主机进行转发。\n路由器转发 路由器根据IP数据报的目的IP进行查表，如果找得到条目则进行转发，反之向源主机发送ICMP差错报告。\n通过给路由器接口配置IP和掩码，路由器能自行得出与该接口直连的网络号。\n路由器不对广播IP数据报进行转发，否则容易导致巨大的广播风暴，浪费资源。（路由器可以隔离广播域和冲突域）\n首部格式 版本（Version）：占4b，表示IP协议的版本\n首部长度（Header Length）：占4b，以4字节为单位，最小取值为0101（5），表示IP数据报首部只有20字节的固定部分\n区分服务类型（Differentiated Services Field）：占8b，区分不同类型的IP数据报，提供不同等级的服务质量\n总长度（Total Length）：占16b，表示IP数据段的总长度（首部+数据载荷）最大取值为65535，以字节为单位\n[每一种数据链路层协议规定了帧的数据载荷的最大长度MTU（Maximum Transmission Unit），因此有些IP数据报要进行分片操作，PPP和以太网协议一般取为1500字节。]\n标识（Identification）：占16b，属于同一个IP数据报的各分片应具有相同的标识，IP软件会维护一个计数器，每产生一个IPv4数据报，计数器的值就加一。\n标志（Flags）：占3b，最低位（More Fragment，MF），MF=1表示后面还有分片，反之表示本分片为最后一个分片；中间位（Don\u0026rsquo;t Fragment，DF），表示是否允许分片，DF=1则不允许分片；最高位为保留位，设为0.\n片偏移（Fragment offset）：占13b，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。以8个字节为单位。\n生存时间（Time to live，TTL）：占8b，最初以秒为单位，最大生存周期为255秒。转发时，将该字段的值减去IP数据报在本路由器上耗费的时间，若不为0则转发，否则就丢弃。现在以跳数为单位，每次减一。[防止在路由环路中反复转发]\n协议（Protocol）：占8b，指明数据部分是何种协议数据单元：常用的有：ICMP1；IGMP2；TCP6；UDP17；IPv6（41）；OSPF89\n首部检验和（checksum）：占16bit，检测是否出现差错。每经过一个路由器，checksum重新计算。\n源IP地址（Source）：32bit，Destination也是如此。\n5.IPv6地址 IPv6基本首部 基本首部Base Header，40字节，是固定的，因此首部中取消了首部长度字段。\n拓展首部（Extension Header）不属于首部，和后面的数据部分组合起来构成有效载荷（payload），也成为净负荷。、\nIPv6首部字段仅有8个。\n取消了区分服务（服务类型）字段，其中通信量类和流标号字段实现了该功能。\n版本Version：4b，IPv6则为6\n通信量类Traffic Class：8b，区别数据报的类别\n流标签Flow Label：20b，属于同一个流的IPv6数据报具有同样的流标号。即流标号用于资源分配。对于传统的非实时数据，流标号没有什么作用，置为0即可。\n[流就是因特网上从特定源点到特定终点的一系列IPv6数据报（如实时音视频数据的传输），流的路径上所有路由器保障指明的服务质量]\n有效载荷长度Payload length：16b，最大值为65535，有效载荷的字节数量（包括拓展首部和数据部分）\n下一个首部Next Header：8b，相当于IPv4中的协议字段。当IPv6没有拓展首部，则它指出了IPv6数据报封装的何种协议数据单元PDU。如果有扩展首部，那么其值标注后面第一个拓展首部的值。\n跳数限制Hop Limit：8b，即为TTL，最大255跳。\n源和目的（Source \u0026amp; Destination）：均为128b。\n扩展首部 为了提高路由器处理数据报的速度，将原来IPv4的选项字段放到了拓展首部中。只有源和终点的主机处理，传输过程中的路由器均不处理这里的拓展首部。\n拓展首部字段有六种类型：逐条选项；路由选择；分片；鉴别；封装安全有效载荷；目的站选项。每一个拓展首部都有若干个字段组成，他们的长度也各不相同。\n每一个拓展首部的一个字段都是8b的”下一个首部“字段。\n表示方法 冒号十六进制记法：128个划分为8组，每组16个，16个可以变成4位十六进制。\n不区别大小写。\n在此基础上使用”左侧0省略“和”连续0压缩“。\n左侧0省略：每一组之中最前面的0可以不写；\n连续0压缩：两个冒号中间的一连串0可以省略，但只能进行一次压缩\n还可以集合点分十进制的后缀。\nCIDR斜线表示法也可以继续使用。\n地址分类 目的地址的三种基本类型：单播（unicast）、多播（multicast）、任播（anycast）\n为指明地址：全0，只能用于还没一个配置到地址的主机作为源地址\n环回地址：最低比特为1其余为0\n多播地址：最高八位为1，即为FF00::/8\n本地链路单播地址：最高十个比特为1111111010，即为FE80::/10\n全球单播地址：剩余的即是，结构包含：48b的全球路由选择前缀(Global Routing Prefix)，相当于原来的网络号；16b的子网标识符(Subnet ID)，用于各共公司和机构构建子网；64b的接口标识符(Interface ID)，相当于主机号。\n从IPv4到IPv6的过渡 双协议栈 双协议栈（Dual Stack），一部分主机装有IPv4和IPv6两套协议栈；在不同协议栈的两部分分界处进行报文的转换。\n隧道技术 隧道技术（Tunneling），当IPv6数据报要进入IPv4网络时，将IPv6数据报重新封装成IPv4数据报，即整个IPv6数据报称为IPv4数据报的数据载荷。\n4.3 路由配置和路由选择 1.静态路由配置 路由器除了自行得出的直连路由和手动配置的非直连路由。还有一些特殊的路由：默认路由和特定主机路由。\n默认路由 默认路由条目中的目的网络填为0.0.0.0/0，其中0.0.0.0表示任意网络。由于最长前缀匹配，因此这里前缀为0的优先级最低。\n特定主机路由 网络前缀为/32，是最长的网络前缀，匹配优先级最高。\n2.路由选择协议 分类 域间路由选择（Interdomain Routing）-对应协议为外部网关协议（External Gateway Protocol，EGP）：RIP OSPF\n域内路由选择（Intradomain Routing）-对应协议为内部网关协议（Interior Gateway Protocol，IGP）：BGP\n集中式路由选择算法（centralized routing algorithm）：需要全局网络信息\u0026ndash;链路状态（Link state，LS）算法 分散式路由选择算法（decentralized routing algorithm）：通过迭代和信息交换的分布式计算\u0026ndash;距离向量（Distance-vector,DV）算法\n路由信息协议 路由信息协议（Routing Information Protocol，RIP）是内部网关协议IGP。RIP报文信息封装在UDP中，端口号520。\nAS内每个路由器都要维护一个距离向量，使用跳数（Hop Count）作为度量。\n距离等于16时相当于不可达。因此RIP只能适用于小型网络。\n当到达同一目的网络有多条RIP距离相等的路由时，可以进行等价负载均衡。\nRIP的特点：\n仅和相邻路由器交换信息；交换的信息是路由器的路由表；周期性交换（30S）\nBellmanFord思想进行更新。同一目的网络下，如果新路由表的下一条信息相同，则进行更新[因为可以知道是网络拓扑发生了变化]，如果下一跳的信息不同，那么则取最优，如果RIP距离相等，则保留，可以进行等价负载均衡。\n存在的问题：\n无穷计数问题（更新消息传递不及时，导致被误导），更正方案：路由表发生变化时则立马发送路由更新报文；水平分割[不让信息从原接口反方向传输]。\n开放最短路径优先协议 开放最短路径优先协议（Open Shortest Path First，OSPF），OSPF报文直接封装在IP数据报中。协议字段为89。\n基于链路状态并采用最短路径算法计算路由。\n链路状态 链路状态是指本路由器都和哪些路由器相邻，以及相应链路的代价，代价用来表示费用、距离、时延和带宽。\n思科路由器中OSPF协议计算代价的方法是：100Mb/s除以链路带宽，结果小于1则取1。[带宽越小，代价值越大]。\n邻居关系维护 通过问候（Hello）分组来建立和维护邻居关系。\nOSPF分组封装在IP数据报中，协议号字段为89。\nHello分组的发送周期为10秒，若40秒没有收到来自邻居的问候分组，则认为该邻居不可达。因此每个路由器都会建立一张邻居表。该40秒倒计时通过一个判活计时器进行计时。\n链路状态通告 使用OSPF的每一个路由器都会产生链路状态通告（Link State Advertisement，LSA）。包含：直连网络的链路状态信息和邻居路由器的链路状态信息。\n链路状态更新分组 LSA被封装在链路状态更新分组（Link State Update，LSU）中，使用洪泛法（Flooding）发送。即通过自己的所有接口进行转发，最终整个区域中所有的路由器都获得信息。\n链路状态数据库 使用OSPF的每个路由器都有一个链路状态数据库（Link State Database，LSDB），用于存储各路由器的LSA，各路由器的LSDB最终一致。\n最短路径计算 每个路由器根据LSDB可以得到一个带权有向图，执行Dijkstra可以得到以各自路由器为根的最短路径。\nOSPF区域划分 为了使OSPF协议能够用于规模较大的网络，OSPF把一个AS再划分成若干个更小的范围，称为区域（area）。\n每个区域都有一个32b的区域标识符，可以用点分十进制表示。主干区域的标识必须为0。每个区域一般包含的路由器不应超过200个\n如果路由器的所有接口都在区域内，则为区域内路由器（internal router）；一个接口用于连接自身所在区域，另一个接口用于连接主干区域，则为区域边界路由器（area border router）；主干区域的路由器被称为主干路由器（backbone router）；在主干区域中有一个专门和本AS外的其它AS交换路由信息的路由器，成为自治区域边界路由器。\n边界网关协议 边界网关协议（Border Gateway Protocol，BGP），BGP报文基于179端口的TCP连接。\nAS间的路由选择必须考虑相关政策，如政治，经济。\nBGP力求寻找一条能够到达目的网络且比较好的路由。主要进行可达性信息的传播。\n在BGP中，每对路由器[网关路由器]通过179端口的半永久TCP连接交换路由选择信息，即BGP连接（BGP connection）。\n跨越两个AS的BGP连接为外部BGP连接（eBGP），反之为内部BGP连接（iBGP）。\n可达性信息传递 AS3中一个网关路由器通过eBGP连接向其他路由器告知“AS3 x”，（x是AS3中一个网络）。则相当于告知x在AS3中，收到该可达性信息的路由器通过iBGP连接将信息转发给其所在AS的所有路由器，同时也通过eBGP连接向其它路由器告知\u0026quot;AS2 AS3 x\u0026quot;，这告知了x的位置，也告知了到达的路径。【TopDown的P263】\n确定最好的路由 到达目的子网可能有多条路径，那么如何进行路径的选择？\n可达性信息中告知的子网前缀中包含一些BGP属性（BGP attribute），比如AS-PATH和NEXT-HOP。\nAS-PATH告知当前可达性信息中到达该AS所经过的所有AS；当某个子网前缀通过某个AS时，该AS将ASName加入到该AS-PATH的现有列表中。\nNEXT-HOP是AS-PATH起始的路由器接口的IP地址。\n从一个简单的路由选择算法开始，即热土豆路由选择（hot potato routing），意思是对于一个路由器，希望尽可能快的把分组送出当前AS，而不用担心其AS外部到目的地的余下部分的开销。因此它通过AS内部协议来找到多个网关（或者到NEXT-HOP）所需要的开销，并选择具有最小开销的那个网关进行转发。\n实际上的路由选择算法较为复杂，路由器被指派一个本地偏好（local preference）作为其属性之一，路由选择优先选择属性值较高的，在余下具有相同最高本地偏好值的，将选择具有最短AS-PATH的路由，在余下的路由中（具有相同local preference和AS-PATH长度），使用hot potato，选择最靠近NEXT-HOP的路由进行跳转。\n3.路由器的基本结构 路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。\n路由选择部分：路由选择处理机[执行控制平面功能]，执行路由选择协议，计算路由表\n分组转发部分：输入端口、输出端口、交换结构，通过转发表进行转发\n路由表需要对网络拓扑变化的计算最优化，而转发表是从路由表得出的，转发表的结构应当使得查找过程最优化。\n输入端口 包含线路端接、数据链路拆封、查找、转发、排队\n输入端口查找目的IP地址（“匹配”），然后将该分组送入交换结构（“操作”）。[匹配+操作]\n输出端口 包含排队（缓存管理）、链路数据处理、线路端接\n交换结构 交换结构switching fabrics\n经总线交换 一次只有一个分组能够经过总线。\n工作过程大致为：输入端口为分组预先计划一个交换机内部标签，指示本地输出端口，使分组在总线上传送和传输到输出端口，所有端口都能收到该分组，但只有标签匹配的端口才能保存。\n经内存交换 在路由选择处理器的直接控制下完成。路由选择处理器从首部提取目的地址，在转发表中查找适当的输出端口，并将该分组复制到输出端口的缓存中。一个分组到达输入端口时，会通过中断方式向路由选择处理器发出信号。\n经互连网络交换 Crossbar，也成为交叉开关矩阵或者纵横式交换矩阵，能够并行转发多个分组。\n4.4 网际控制报文协议ICMP 网际控制报文协议（Internet Control Message Protocol，ICMP）\n被封装在IP数据报发送。包含终点不可达、源点抑制、时间超过、参数问题、改变路由（重定向）。\n1.差错报告报文 终点不可达 路由器发现无目的网络的转发条目则丢弃数据报并且往源主机发送ICMP差错报文，具体类型为终点不可达。\n具体也包含：目的网络不可达（Type3 Code0）；目的主机不可达（Type3 Code1）；目的协议不可达（Type3 Code2）；目的端口不可达（Type3 Code3）；目的网络未知（Type3 Code6）；目的主机未知（Type3 Code7）\n源点抑制 路由器由于网络拥塞而丢包，则往源主机发送该类型报文，以示减少发送速率。Type4。\n时间超过 路由器会将目的IP不为自己的IP数据报进行TTL减一，如果结果不为0，则转发，反之则丢弃并往回发送TTL过期，Type11.\n参数问题 路由器收到IP数据报后，进行checksum的检查，如果出现误码则丢弃并往回发送报文。Type12.\n改变路由 如果路由器发现更好的路由，则通过这种类型的ICMP报文告知主机变更路由。\n2.ICMP询问报文 回送请求和回答 即回显请求和回显回答（对ping的回答），收到回显请求的主机必须发送ICMP回显回答报文。可以用来判断目标是否可达。\n时间戳请求和回答 用来请求某个主机或路由器回答当前的时期和时间。用来时钟同步和测量时间。\n3.ICMP的应用 ping 分组网间探测（Packet InterNet Groper，PING），主机向目标发送四个回显请求报文。由于往返的ICMP报文上都有时间戳，容易计算出RTT。\ntraceroute 跟踪路由。windows版本的命令为tracert，UNIX版本的命令为traceroute。\n基本原理：主机给目的发送ICMP回显请求报文，IP数据报字段的TTL值被设置为1.TTL递减，当为0时像源主机发送ICMP差错报告报文，类型为超时。接下来继续发送TTL值为2、3、4的ICMP回显请求报文\n4.5 VPN与NAT 1. 虚拟专用网 虚拟专用网（Virtual Private Network，VPN），利用公用的因特网作为机构专用网之间的通信载体。\n由于很多机构所分配到的IP地址远小于其主机数目，可以进行专用地址（Private Address）的分配，不需要向因特网的管理机构申请。\n专用地址在机构内部使用，因特网中的所有路由器，其对目的地址是专用网络的IP数据报一律不转发。\n每个机构的专用网之中至少需要一个路由器具有合法的全球IP地址，这样经过VPN配置，各自的专用网才能利用公用因特网进行配置。\n专用网络 10.0.0.0~10.255.255.255（CIDR 10/8）\n172.16.0.0~172.31.255.255（CIDR 172.16/12）\n192.168.0.0~192.168.255.255（CIDR 192.168/16）\n工作过程 专用网内的主机向路由器发送IP数据报，路由器重新添加IP首部，将源和目的IP改为对应的专用网路由器的IP，同时加密原有IP报文。\n也被称为IP隧道技术\n同一机构不同部门的内部网络所构成的VPN称为内联网（Intranet或Intranet VPN，即内联网VPN）。\n有外部机构则为外联网（Extranet或Extranet VPN，即外联网VPN）。\n需要访问公司内部的专用网时，只需要在任何地点接入到因特网，运行VPN软件（进行IP的转换，否则专用网络的目标IP不会被转发），该PC和主机之间建立VPN隧道，可以访问到其中的资源。远程接入VPN（Remote Access VPN）。\n2. 网络地址转换 网络地址转换（Network Address Transition，NAT）。\nIPv4地址面临被耗尽的风险。NAT使得大量使用内部专用网络的用户共享少量外部全球地址来访问因特网上的主机和资源。\n通过网络地址和端口转换NAPT，维护一个NAT转换表。\n将专用网内的各专用地址映射成一个公网地址和唯一的端口号。当生成一个新的源端口号时，NAT可以任意选择一个当前未在NAT转换表中的源端口号。\n注意：专用地址不能充当服务器功能，即外网主机不能首先发起通信，这样当外网数据报到达NAT路由器时，在转换表中找不到对应的记录。需要网络应用自己使用一些特殊的NAT穿越技术。\n4.6 IP多播技术 1.基本概念 多播（Multicast）是实现“一对多”通信的技术。在因特网上进行的多播称为IP多播。\n和IP任播的区别 IP任播（anycast）：考虑CDN，是指一组具有相同IP地址的设备中实际只有一个接收数据包。在IP任播中，多个设备共享同一个IP地址，但是不同设备有不同的物理位置，因此数据包只被发送到最近的一个设备。\nIP多播（multicast）：在IP任播中，多个设备共享同一个IP地址，但是不同设备有不同的物理位置，因此数据包只被发送到最近的一个设备。\nIP任播是一种点对点的通信方式，而IP多播是一种点对多点的通信方式。\n2.多播地址 IPv4中，D类地址被作为多播地址。起始的四个比特固定为1110，剩余28比特任意变化。\n最小的IPv4多播地址为224.0.0.0；最大的为239.255.255.255。只能用作目的地址，而不能用作源地址。\n用每一个D类地址来标识一个多播组，使用同一个IP多播地址接收IP多播数据报的所有主机构成了一个多播组。\n每个多播组的成员是可以随时变动的，一台主机可以随时加入或者离开多播组。\n一台主机可以属于几个多播组。\n非多播组成员可以向多播组发送IP多播数据报。\nIP多播数据报也是best effort。\nIP多播地址可以分为预留的多播地址（永久多播地址）、全球范围可用的多播地址以及本地管理的多播地址。\n3.多播类型 分为两种：只在本局域网上进行的硬件多播和在因特网上进行的多播。\n而大部分主机都是通过局域网接入因特网，因此在多播的最后阶段一般都是局域网内的硬件多播。\n在局域网上进行硬件多播 由于MAC地址有多播MAC地址，只要将IPv4地址映射成局域网的硬件多播地址（即多播MAC地址）。MAC帧首部的MAC地址字段就设置为IPv4多播地址映射成的多播MAC地址。\n《深入浅出》P239\n在因特网上进行多播 必须考虑IP多播数据报经过多个多播路由器进行转发的问题。\n多播路由器必须根据IP多播数据报首部的IP多播地址将其转发到有该多播组成员的局域网。\n每个路由器则需要直到其接口所连局域网之中是否有某个多播组的成员。使用网际组管理协议（Internet Group Management Protocol，IGMP）。是网际层协议。作用是让连接在本地局域网上的多播路由器知道本局域网上的主机加入或者退出某个多播组。\nIGMP只在本网络中有效，IGMP并不能知道多播组所包含成员的数量，也不知道多播组的成员都分布在哪些网络。\n还需要使用多播路由选择协议。它建立了多播转发树。在多播转发树上进行洪泛，则所有多播组成员都能获取IP数据报。\n不同的多播组需要维护不同的多播转发树，必须动态的知晓多播组的变化。\n4.网际组管理协议 网际组管理协议（Internet Group Management Protocol，IGMP）。\n《深入浅出》P243\n5.多播路由选择协议 4.7 移动IP技术 1.基本概念 移动IP（Mobile IP）使得移动主机在各网络之间漫游时，仍能改变其原来的IP地址不变。也向非移动主机提供了相应机制，使得他们能够将IP数据报正确的发送到移动主机。\n归属代理接收外来的IP报文段，并向外地代理发送，外地代理收到信息后转发给移动主机。\n4.8 软件定义网络 1.核心思想 把网络的控制层面和数据层面分离，而让控制层面利用软件来控制数据层面中的许多设备。\n路由器中的路由表（匹配加操作表）由远程控制器计算、安装和更新。\n2.OpenFlow OpenFlow协议是一个得到高度认可的标准，可以被看成是SDN体系结构中控制层面与数据层面之间的通信接口。\nOpenFlow协议使得控制层面的控制器可以对数据层面中的物理设备进行直接访问和控制。\n3.泛化转发 转发分组可以分成以下两个步骤：\n1.进行匹配：查找转发表中的网络前缀，进行最长前缀匹配；\n2.执行动作：把分组从匹配结果指明的接口转发出去。\nSDN对转发过程进行了扩充，广义转发分为以下两个步骤：\n1.进行匹配：能够对网络体系结构中的各层首部中的字段进行匹配；\n2.执行动作：不仅转发分组，还可以负载均衡、重写IP首部（类似NAT）、人为的阻挡或丢弃一些分组（类似防火墙）。\n在SDN的广义转发中，完成”匹配+动作“的设备并不局限在网络层工作，因此不再称为路由器，而称为”OpenFlow交换机“或者”分组交换机“，或更简单地称为”交换机“。\n流表 在SDN中取代传统路由器中转发表（匹配加操作转发表）的是流表（Flow Table），[一个流就是穿过网络中的一种分组序列，而在此序列中的每个分组都共享分组首部某些字段的值]，OpenFlow交换机中的流表是由SDN远程控制器来管理的。SDN远程控制器通过一个安全信道，使用OpenFlow协议来管理OpenFlow交换机中的流表。\n每个OpenFlow交换机必须有一个或者多个流表。每个流表项包含：首部字段值、计数器、动作。\n首部字段值 其中包含一组字段，用来使如分组（Incoming Packet）的对应首部与之匹配，因此又称为匹配字段。匹配不上字段分组被丢弃，或者被送到SDN远程控制器做更多的处理。\n计数器 一个计数器记录已经与该流表项匹配的分组数量的计数器；另一个计数器记录流表项上一次更新的时间。\n动作 动作字段是指一组动作，当分组匹配某个流表项时，执行该流表项中动作字段指明的动作。包括：把分组转发到指明的端口、丢弃分组、把分组进行复制后再从多个端口转发出去、重写分组的首部字段（包括数据链路层、网际层和传输层的首部）。\n4.关键特征 1.基于流的转发\n2.数据层面与控制层面分离\n3.位于数据层面分组交换机之外的网络控制功能\n4.可编程的网络\nChapter5. 数据链路层 5.1 概述 1.相关概念 链路 Link，是从一个节点到相邻节点的一段物理链路，中间没有其它交换节点。\n数据链路 Data Link，是基于链路的，把实现控制数据传输的协议的硬件和软件加到链路上，就成了数据链路。\n帧 Frame，是数据链路层对等实体之间再水平方向进行逻辑通信的PDU。\n2. 提供服务 封装成帧 封装成帧（framing），就是网络层交付下来的分组添加一个首部和尾部。其中包含一些重要的控制信息，包括：帧首部有帧开始符、源地址、目的地址；尾部有帧校验序列和帧结束符。每一种数据链路层协议规定了帧的数据载荷的长度上限，即最大传输单元（Maximum Transfer Unit，MTU），例如以太网的MTU为1500字节。\n差错检测 可靠传输（可靠交付） 保障无差错地经过链路层移动每个网络层数据报文，但通常是通过确认和重传取得的，用于产生高差错率的链路，而对于低比特差错的链路，包括光纤，这种服务可能是不必要的开销，因此有些链路层协议不提供可靠交付服务。[考虑rdt]\n链路接入 介质访问控制（Medium Access Control，MAC）协议规定了帧在链路上的传输规则。对于点对点链路，MAC协议比较简单；对于多个节点共享单个广播电路，即所谓多路访问问题，MAC协议用于协调多个节点的帧传输。\n5.2 差错检测 1.奇偶校验 使用单个奇偶校验位（parity bit），如果信息D中有d比特，需要添加一个附加的比特（校验比特），满足d+1个比特中1的总数是偶数（偶校验）。\n2.checksum 同UDP的checksum\n3.CRC 循环冗余检验（Cyclic Redundancy Check，CRC）。\n发送方 给定最高次数为r的生成多项式G，共有r+1位。\n在待发送信息最后添加r位的0。\n进行除法运算，获得余数，余数个数需与r一致。\n将r位余数添加到待发送信息末尾。\n接收方 将接收信息直接进行除多项式操作，若余数不为0则发生了错误。\n5.3 多路访问链路和协议 0.点对点协议 由链路一端的单个发送方和链路的另一端的单个接收方组成。包括PPP和HDLC（high-level data link control，高级数据链路控制）\n点对点协议PPP（Point-to-Point Protocol）为在点对点链路传输各自协议数据报提供了一个标准方法，包括：\n1.对各种协议数据报的封装方法\n2.链路控制协议LCP，用于建立、配置以及测试数据链路的连接\n3.一套网络控制协议NCPs，其中的每一个协议支持不同的网络层协议\n使用PPP的数据链路层向上不提供可靠传输服务。\nPPP帧格式 其中FCS为Frame Check Sequence，取值为CRC计算出的校验位\n多路访问协议用于协调多个发送和接收节点对一个共享广播信道的访问（多路访问问题，multiple access problem）。防止碰撞collide\n包括信道划分协议（channel partitioning protocol）、随机接入协议（random access protocol）、轮流协议（taking-turns protocol）\n1.信道划分协议 时分多路复用TDM 将时间划分为时间帧（time frame），并进一步划分每一个时间帧为N个时隙（slot）。然后把每个时隙分配给N个节点中的一个。通常选择的时隙长度应使一个时隙内能够传输单个分组。但节点被限制R/N bps的平均速率。\n频分多路复用FDM 将信道划分为不同的频段，每个频段有R/N的带宽，并把每个频率分配给N个节点中的一个。\n码分多址CDMA 码分多址（Code Division Multiple Access，CDMA）对每个节点分配一种不同的编码，然后每一个节点用它唯一的编码来对将要发送的数据进行编码操作。\nCDMA将每个比特时间划分为m个更短的时间片，称为码片clip。每一个站点被指派一个唯一的码片序列，满足不同站点的码片序列正交，相同站点的码片内积为1，与自身反码的内积为-1.[以上内积均为规格化内积，即要除以码片长度m]\n各站点若要发送1则发送码片序列，要发送0则发送码片序列的反码（乘-1的结果）。\n各站点将接收到的码片向量与自身指派的码片序列进行规格化内积计算，为1则收到信息1，为-1则收到信息0，否则没有收到信息。\n2.随机接入协议 时隙ALOHA 每一个时隙等于传输一帧的时间，需要在每个时隙的起点进行帧的传输。\n若发送碰撞，则有p的概率在之后的每一个时隙进行重新发送，直到该帧被成功传输。\n时隙ALOHA是高度分散的，每个节点检测碰撞并独立地决定什么时候进行重传，需要在节点中对时隙进行同步。\n效率为Np(1-p)^(N-1)，可计算最大效率为1/e=0.37 [效率定义为长期运行中有效发送时隙占总时隙的份额]\nALOHA 时隙ALOHA要求节点同步从每个时隙开始时进行传输，第一个ALOHA协议实际上是一个非时隙、完全分散的协议。\n即在从上层接收到帧后，立即发送该帧，如果碰撞了，则立即在它完整的传输完该碰撞帧后重新以概率p再次传一次，1-p的概率等待一个帧传输时间。\n最大效率仅为1/2e，是时隙ALOHA的一半。·\n载波侦听多路访问CSMA 对于ALOHA，一个节点的传输独立于广播信道上的其他节点的活动。\n载波侦听多路访问（Carrier Sense Multiple Access，CSMA）的关键在于载波侦听（carrier sensing），即一个节点在传输前先听信道，在信道空闲时再开始传输。\n碰撞检测CD 具有碰撞检测的载波监听多路访问（CSMA/CD，CSMA with Collision Detection）\n当某节点执行碰撞检测时，一旦检测到碰撞将立即停止传播。[减少了无用的帧的干扰，提高性能]\n由于站点必须”边发送帧边检测碰撞“，因此站点不可能同时发送和接收，即不可能进行全双工通信，只能进行半双工通信（双向交替通信）。\n协议过程：\n1.从网络层获取数据报，装帧，并置于缓存中；\n2.如果听到信道空闲，则开始传输，如果信道忙，则等待，直到侦听到没有能量信号才开始传输；\n3.传输过程中，适配器监视来自其它使用该广播信道的适配器的信号能量的存在；\n4.如果检测到其它适配器的能量，则终止传输（碰撞发生，停止传输帧）；\n5.终止传输后，等待一个随机时间量，返回步骤2[其实这里需要等待一个96比特时间的空闲信道]。\n当碰撞节点数量较小时。间隔时间较短，反之应较长。\n对于随机时间量的选择，采用二进制指数后退算法（binary exponential backoff）\n随机时间量的选择\n当传输一个帧，其连续经历了n次碰撞，则节点随机从[0,1,2,\u0026hellip;,2^n-1]中选择一个K值，连续碰撞越多，K的选择范围越大。\n对于以太网，一个节点等待的实际时间量为512K比特时间，即发送512比特进入以太网所需时间量的K倍，n能够取得最大值为10\n强化碰撞\n发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32b或者48b的人为干扰信号（Jamming Signal），以便有更多的碰撞信号使得所有站点都能够检测出碰撞。\n碰撞避免CA 3.轮流协议 轮流协议(taking-turns protocol)，包含轮询协议（polling protocol）和令牌传递协议（token-passing protocol）等。\n轮询协议 要求这些节点之一被指定为主节点。主节点以循环的方式轮询每个节点，并告知其能发送的帧的最多数量。以此进行循环\n令牌传递协议 这种协议中没有主节点。一个称为令牌（token）的小的特殊的帧在节点之间以某种固定的次序进行交换。\n当一个节点收到令牌时，仅当他有一个帧要发送时，它才持有该令牌，否则将向下一个节点传递令牌。\n缺点就是一个节点的故障或者占用令牌可能会导致整个信道崩溃，需要某些恢复步骤来保障令牌返回到循环中。\n5.4 交换局域网 1.MAC地址 要将计算机连接到局域网，需要使用相应的网络适配器（Adapter），简称为网卡NIC。\nMAC（Medium Access Control，媒体接入控制）地址是数据链路层地址，作为唯一标志，由于广播信道天然的广播特性，需要通过MAC地址来进行判断帧是否发送给自己。\nMAC地址也称为LAN地址、物理地址等。被固化在NIC的EEPROM中。\nMAC地址格式 MAC地址长度6字节，共48比特。\n前24比特为组织统一标识符（Organization Unique Identifier，OUI），也成为公司标识符，后24位为网络接口标识符，由获得OUI的厂商自行分配。\n处理方式 如果是广播地址，接收\n如果目的MAC与NIC上固化的MAC相同，则接收\n如果目的MAC是NIC支持的多播地址，则接收。\n安全问题 用户应确保自己拥有的全球单播MAC地址不被泄露，为了避免WIF连接时的MAC泄露问题，大多数移动设备已经采用了随机MAC技术。\n2.以太网 以太网技术 以太网是到目前为止最流行的有线局域网技术。是第一个广泛部署的高速局域网。\n初始的以太局域网使用同轴电缆总线来互联节点，使用总线拓扑的以太网是一种广播局域网，即所有传输的帧传输到与该总线连接的所有适配器都会被处理。\n20世纪90年代后期，大多数机构使用一种基于集线器（Hub）的星形拓扑以太网结构。[集线器工作在物理层]\n集线器作用于各个比特而不作用于帧，当比特到达接口时，集线器重新生成这个比特，将其能量放大并从所有接口传输出去，因此该星型拓扑结构也为广播局域网。\n21世纪处，以太网继续使用星型拓扑，但是位于中心的集线器被交换机（switch）所替代。[交换式以太网]\nIEEE于1990年指定了10BASE-T星型以太网的标准802.3i，为以太网在局域网中的统治地位奠定了牢固的基础。\n[每个站点到集线器的距离不超过100m，由于距离太远可能导致信号衰减到相关协议无法工作，例如CSMA/CD，在IEEE802.3标准中，两个网段可以使用转发器（repeater）进行连接，从而获得更长的运行距离]\n标准中：10、100、1000、10G或40G分别代表该标准中的传输速率（Mbps）；BASE指的是基带以太网（意味着物理媒介仅承载以太网流量）；T代表物理媒介双绞铜线，F代表光纤。\n以太网帧 格式 其中类型标志着数据载荷中的网络层协议，0x0800代表了IPv4协议、0x0806代表了ARP分组\nFCS中为四字节的CRC字段\n此外，以太网帧以一个8字节的前同步码（Preamble）字段开始，该字段的前七个字节为10101010，最后一个字节是10101011，前七个字节用于唤醒接收适配器，并且将它们的时钟和发送方进行同步。[这里可以理解成数据链路层帧在下放到物理层时还要加上一个前导码]\n最小帧长和最大帧长 最小帧长：若发送的帧过小，则可能检测不到实际产生的碰撞；为了能够检测出碰撞，帧的发送时延就不能少于端到端的往返时延，即一个争用期2t。对于10Mb/s的共享总线以太网，最小帧长为512b，即64B。[如果遭遇碰撞，一定在帧的前64B之前，在这个时间内，发送方一定能够检测出碰撞，而停止发送，因而接收端接收到的帧长会小于64，由此判断收到了因碰撞而损坏的帧]\n就是在2t争用期中传输的比特长度：最小帧长=数据传输速率×争用期（往返时延）\n最长帧长：帧太长而过度占用信道，还可能使得接收方溢出。因此以太网V2的MAC帧的最大长度规定为1518B（数据载荷1500B）。此时数据载荷最小为46B，为了满足帧长大于64B。\n3.链路层交换机 交换机的任务就是接收入链路层帧并将它们转发到出链路\n过滤和转发 过滤（filtering）是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。\n转发（forwarding）是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。\n交换机的过滤和转发借助于交换机表\n交换机表中包含某局域网上某些主机和路由器的表项，但不必是全部。\n表项包含：MAC地址 通向该MAC地址的交换机接口 表项被放置在表中的时间\n对于表项的处理\n表中没有对于目的地址的表项，交换机则广播该帧\n表中存在相关联的表项，则转发到对应的接口即可\n若表中存在的表项的对应接口为传入接口， 则无需进行转发，丢弃该帧执行过滤功能即可。\n自学习 交换机表是通过自学习（self-learning）进行自动、动态和自治地建立的。\n对于每一个接口收到的入帧，该交换机在表中存储：1.该帧的源地址字段中的MAC地址；2.到达的接口；3.当前时间\n如果在一段时间（老化期aging time）后，交换机没有收到以某个地址为源的帧，则在表中删除，以处理PC被替代的问题。\n交换机是即插即用的设备（plug-and-play device）\n特点 消除碰撞\n将异质的链路互连\n易于进行网络的管理\n全双工工作，在自身内部同时连通多对接口\n也使用生成树协议STP，来产生能够连通全网而不产生环路的通信路径 [路由器没有生成树限制，允许丰富的网络拓扑，活跃链路可能有多条]\n[交换机不会进行广播风暴的处理]\n对比：\n集线器 路由器 交换机 流量隔离 无 有 有 即插即用 有 无 有 优化路由 无 有 无 4.虚拟局域网VLAN 虚拟局域网（Virtual Local Area Network，VLAN）是一种将局域网内的设备划分成和物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。\n同一个VLAN内可以广播通信，不同VLAN之间不能广播通信。\nIEEE 802.1Q帧 VLAN标记的最后12个比特称为VLAN标识符VID，它唯一地标识了以太网帧属于哪一个VLAN。取值范围为1~4094（0和4095不表示）\n802.1Q帧由交换机处理而非用户主机。\n当交换机收到普通的以太网帧时，会将其插入四字节的VLAN标记，转变为802.1Q帧。[打标签]\n当交换机转发802.1Q帧时，可能会删除VLAN标记，转变为普通帧，[去标签]\n交换机的端口类型 交换机的端口类型有三种：Access、Trunk、Hybrid\n对于缺省的VLAN ID[端口上]：思科交换机上称为本征VLAN，华为交换机称为Port VLAN ID，即端口VLAN ID，简称为PVID。[默认VLAN]\nAccess端口 一般用于连接用户计算机、只能属于一个VLAN\nAccess端口的PVID值于端口所属的VLAN的ID相同，默认为1\n对于接收的处理方法\n一般只接受”未打标签“的普通以太网MAC帧。根据接收帧的端口的PVID给帧”打标签“，即插入四个字节的VLAN标记字段，字段中的VID取值与端口的PVID相等\n对于发送的处理方法\n若帧中的VID与端口的PVID相等，则”去标签“并转发该帧；否则不转发\nTrunk端口 Trunk端口一般用于交换机之间或者交换机和路由器之间的互连。\nTrunk可以属于多个VLAN\n用户可以设置Trunk端口的PVID值，默认为1。\n对于接收的处理方法\n接收未打标签的帧，根据接收帧的端口的PVID给帧”打标签“\n或者直接接收已打标签的帧\n对于发送的处理方法\n对于VID等于PVID的帧，”去标签“再转发。\n对于VID不等于PVID的帧，直接转发。\nHybrid标签 接收方面与Trunk端口一致\n发送方面可以视作端口有多个PVID，查看帧的VID是否在”去标签“列表中再考虑是否进行去标签操作。\n5.5 数据中心网络 1.用途 1.他向用户提供网页、搜索结果、电子邮件或流媒体视频；\n2.用于特定数据处理任务的大规模并行计算基础设施，比如搜索引擎的分布式索引计算；\n3.为其它公司提供云计算服务\n2.体系结构 数据中心的主机称为刀片（blade），一般是包括CPU、内存和磁盘存储的商用主机。\n每个机架包含20~40台刀片，机架顶部有一个交换机，被称为机架顶部（Top of Rack，TOR）交换机，与主机互连。\n数据中心网络支持两种类型的流量：在外部客户和内部主机之间流动的流量，主机之间流动的流量。包含多个边界路由器（border router），与公共因特网相连。\n数据中心网络设计（data center network design）是互联网络和协议设计的艺术，专注于机架彼此连接和边界路由器相连。\n负载均衡 为了支持来自外部客户的请求，每一个应用都与一个公开可见的IP地址关联。\n数据中心内部，外部请求首先被定向到一个负载均衡器（load balancer），其任务是向主机分发请求，以主机当前的负载作为函数来在主机之间实现负载均衡。\n一个大型的数据中心通常会有几台负载均衡器，每台服务于一组特定的云应用。\n负载均衡器不仅平衡主机之间的工作负载，而且还提供类似NAT的功能，将外部IP地址转换为内部适当主机的IP地址。防止客户直接接触主机\n等级体系结构 数据中心通常使用路由器和交换机等级结构（hierarchy of router and switch）\n三层交换机结构，边界路由器和接入路由器相连，随后连接三层交换机（TOPDOWN P332 图6-30）\n每台接入路由器下的主机构成了单一子网。为了使得ARP广播流量本地化，这些子网都被进一步划分为更小的VLAN，每个VLAN包含数百个主机。\n依然存在主机到主机容量受限问题。解决方法包括：1.部署更高速率的交换机和路由器；2.将相关服务和数据放在尽可能近的位置，以减少通过第二层或者第一层交换机的机架间通信。3，增强TOR交换机和第二层交换机之间以及第二层交换机和第一层交换机之间的选择[多增加一些互连通路，增大可能带宽]\n3.发展趋势 1.降低成本\n2.集中式SDN控制和管理\n3.虚拟化：虚拟机（VM）将运行应用程序的软件和物理硬件解耦\n4.物理约束：数据中心的网络运行环境有极高的容量和极低的时延，拥塞控制协议会导致极低的效率，目前已经提出和部署了几种解决这个问题的方法，例如直接内存访问技术（RDMA）\n5.硬件模块化和定制化：采用基于航运集装箱的模块化数据中心（Modular Data Center，MDC）。\nChapter6. 无线网络和移动网络 6.1 概述 1.相关要素 无线主机 wireless host\n无线链路 wireless communication link 主要特性：链路速率和覆盖区域\n基站base station 负责向与之关联的无限主机发送数据，并从主机那里接收数据 [例如蜂窝网络中的蜂窝塔（cell tower）和802.11无线局域网中的接入点AP]\n与基站关联的主机通常被称为以基础设施模式（infrastructure mode）运行，所有的传统网络服务（地址分配、路由选择）由网络向通过基站向量的主机提供\n自组织网络中（ad hoc network），无线主机没有这样的基础设施，主机本身必须提供相关服务（地址分配、路由选择、DNS等）\n从一个基站转移到另一个基站，这一过程为切换（handoff或者handover）\n6.2 无线链路和网络特征 1.相关特性 递减的信号强度、来自其它源的干扰、多路径传播（multipath propagation）\n无线链路协议不仅采用有效的CRC错误检测码，还采用了链路层可靠的数据传输协议来重传受损的帧。\n2.信号特征 SNR：信噪比 BER：比特差错率\n对于给定的调制方案，SNR越高，BER越低；\n对于给定的SNR，有高比特传输率的调制技术将有较高的BER；\n隐藏终端问题（hidden terminal problem）：由于信号的衰减（fading），导致信号强度不足以至于一些终端无法检测对方的传输。\n6.3 802.11无线局域网 802.11n（WiFi 4） 2.4GHz、5GHz 600Mbps\n802.11ac（WiFi 5）5GHz\t3.47Gbps\n802.11ax（WiFi 6）2.4GHz、5GHz 14Gbps\n1.体系结构 802.11体系结构的基本构建模块是基本服务集（Basic Service Set，BSS）。\nBSS包含一个或者多个无限站点以及一个接入点（Access Point，AP）[中央基站base station]\n部署AP的无线局域网经常被称作基础设施无线局域网（infrastructure wireless LAN），其中的“基础设施”是指AP连通互联AP和一台路由器的有线以太网。\n信道和关联 每个无线站点在能够发送和接收网络层数据之前，必须和一个AP相关联。\n每个AP都有被分配一个单字或者双字的服务集标识符（Service Set Identifier，SSID）。还必须被分配一个信道号。\n802.11定义了11个部分重叠的信道号，当且仅当两个信道由4个或者更多信道隔开时它们才无重叠。\nWiFi丛林（jungle）是一个任意位置，无限站点能从两个或者多个AP中受到强信号。需要与其中一个AP相关联（associate）\n如何进行关联？\n每个AP周期性地发送信标帧（Beacon Frame），包括该AP的SSID和MAC地址。无线主机扫描11个信道，找到位于该区域的AP所发出的信标帧。\n扫描信道和监听信标帧的过程被称为被动扫描（passive scanning）\n无线主机也能完成主动扫描（active scanning），通过向位于无线主机范围内的所有AP广播探测帧[发送探测请求帧Probe Request Frame]完成的。[AP会发回探测响应帧Probe Request Frame]\n选定关联的AP后，无线主机发送关联请求帧，并且AP以一个关联响应帧进行响应。\n2.802.11MAC协议 802.11无线局域网选择的一种随机接入协议，为带碰撞避免的CSMA（CSMA with collision avoidance），即CSMA/CA。\n对于802.11，使用碰撞避免而非碰撞检测，其次，对于无线信道相对高的比特差错率，使用链路层确认/重传（ARQ）方案。\n原因在于：\n接收信号的强度通常远远小于发送信号的强度，构建具有检测碰撞能力的硬件代价较大。\n适配器会由于隐藏终端问题和衰减问题而无法检测到所有的碰撞。\n802.11不再使用碰撞检测，一旦站点开始发送一个帧，就完全发送，为了降低碰撞的可能性，采用了几种碰撞避免技术。\n链路层确认方案 链路层确认（link-layer acknowledgment）\n无线局域网发送帧时，会因为多种原因不能无损的到达目的站点，为了处理这种故障，使用链路层确认方案。\n目的站点收到一个CRC检验的帧后，等待一个短帧间间隔（Short Inter-Frame Spacing，SIFS）后发回一个确认帧。\n如果发送站点在给定的时间内未能收到确认帧，则假定出现了错误并重传该帧，使用CSMA/CA协议访问该信道。\nCSMA/CA 1.某站点最初监听到信道空闲，将在一个被称为分布式帧间间隔（Distributed Inter-frame Space，DIFS）的短时间后发送帧。\n2.否则，选择一个随机回退值，并且在信道空闲时递减该值。在侦听到信道忙时反而不递减\n3.计数该值若减为0，即侦听信道空闲，站点发送整个数据帧并等待确认\n4.如果收到确认，则OK，如果还要发送其他帧，从第二步继续开始。若未收到确认，传输站将重新进入第二步中的回退阶段，在更大范围内选取随机值\n为什么信道忙时也要等待？\n考虑：如果两个站点都要发送数据帧，而此时第三个站点已经开始了传输，双方都未立即发送。\n如果像CSMA/CD一般，两个站点检测到第三方发送完毕后立马则开始发送，则会导致碰撞，在CSMA/CD中会因为检测碰撞而放弃发送，因此避免帧的无用部分继续被发送，而对于802.11，它不会检测碰撞和放弃发送，受损帧会继续传输。因此对于802.11，无论如何都要进行碰撞避免。\n处理隐藏终端问题 802.11包含一个不错的预约方案，帮助在隐藏终端的情况下进行避免碰撞。\n为了避免由于隐藏终端问题导致的互相隐藏的两个终端之间的碰撞问题，允许站点使用短**请求发送（Request to Send，RTS）控制帧和允许发送（Clear to Send，CTS）**控制帧来预约对信道的访问。\n过程\n当发送方要发送一个DATA帧时，首先向AP发送一个RTS帧，指示传输DATA帧和确认ACK帧的总时间。当AP受到RTS帧时，广播一个CTS作为响应，该CTS帧有两个目的：给发送方明确发送许可，指示其它站点在预约期内不要发送。完成传输后广播ACK帧。\n优势\n1.缓解了隐藏终端的问题\n2.RTS和CTS帧很短，设计它们的碰撞将仅持续短RTS和CTS的持续续期，一旦它们被正确发送，后面DATA和ACK就能无碰撞。\n3.IEEE 802.11帧 分为数据帧、控制帧、管理帧\n帧格式 帧控制：\n类型：区别数据帧、控制帧、管理帧\n子类型：每个类型又有多个子类型\n持续期：\n实现CSMA/CA的虚拟载波侦听和信道预约。在数据帧、RTS、CTS帧中指出信道占用时间\n序号控制：\n用来实现802.11的可靠传输，对数据帧进行编号 [回想TCP报文段的编号]\n地址：\n【图中去往DS和来自DS同TopDown教材中的到AP和从AP】\n[对于01 和 10 ，地址1均为当前帧的发送目标地址，地址2均为当前帧的发送源地址【单段】]\n[对于以太网来说，AP透明]\n4.同IP子网的移动性 在同一个子网下的不同BSS之间的移动\n过程：\n随着H1逐步远离AP1，H1检测到来自AP1的信号减弱，开始扫描一个更强的信号。H1收到来自AP2的信标帧，H1与AP1解除关联，并与AP2进行关联，保持其IP地址和正在进行的TCP会话。\n在交换机角度来说，交换机是“自学习的”，新关联形成后，新AP会以主机为源发送以太网广播帧，同子网内的相关交换机对此进行学习。\n5.高级特色 速率适应\n功率管理：明确在睡眠和唤醒状态之间交替，通过定时器的设置保障节点在AP发送信标帧[100ms一次]前进行唤醒[唤醒只要250ns]。如果AP发送的帧[非信标帧]的目的节点在睡眠，则缓存。\n6.蓝牙 6.4 蜂窝网络 蜂窝网络的组成：\n1. 4G LTE蜂窝网络 移动设备 具有全球唯一的64位标识符，称为国际移动用户身份（IMSI），存储在其SIM（用户身份模块）卡上。在4G LTE中，这种设备称为UE（用户设备）。\n基站 位于运营商网络的“边缘”，负责管理无线电资源和其覆盖区域内的移动设备。基站协助无线电接入网中的设备认证和资源分配（信道接入）。\n2. LTE协议栈 TOPDOWN375\n3. LTE无线电接入网 LTE在下行信道上使用FDM和TDM的组合，称为正交频分复用（OFDM）。\n4. LTE附加功能 网络连接 三个阶段：\n1.连接到基站\n2.互相鉴别\n3.数据路径配置\n功率管理：睡眠模式 又有深度睡眠，在不传输或者接收数据时进入睡眠状态\n5. 全球蜂窝网络 网络的网络\n有许多归属蜂窝运营商网络，它们也组成网络，通过公共因特网或者互联网协议分组交换IPX进行互连。[IPX是一种专门用于互连蜂窝运营商的被管网络]\n6. 5G蜂窝网络 5G核心网络是管理所有5G移动语音、数据和因特网连接的数据网络。\n6.5 移动性管理原则 [4.7 移动IP技术]\n实践中的移动性 Chapter7. 网络安全 7.1 基本概念 安全通信（secure communication）具有以下若干性质\n保密性（confidentiality）、报文完整性（message integrity）、端点鉴别（end-point authentication）、运行安全性（operational security）\n7.2 密码学原理 明文（plaintext，cleartext） 密文（ciphertext）\n加密算法（encryption algorithm） 解密算法（decryption algorithm）\n在对称密钥系统（symmetric key system）中，密钥相同且秘密\n在公开密钥系统（public key system，也称为公钥系统）中，使用一对密钥，一个密钥公开，另一个密钥单方知晓\n1.对称密钥密码体制 单码代替密码 单码代替密码（monoalphabetic cipher），使用字母表中国的一个字母替换另一个字母。并非按照规则的模式进行替换，而是由偏移量k决定。\n即一对一，有26！种配对\n多码代替密码 多码代替密码（polyalphabetic encryption），使用多个单码代替密码，并按照某种次序进行交替选择。\n攻击类别 唯密文攻击 只能截取密文，不了解明文\n已知明文攻击 确定明文中存在的一些字符，确定明文和密文种的某些匹配\n选择明文攻击 入侵者能够选择某一明文报文并且得到其对应的密文形式。\n块密码 分块，分成大小为k的块\n块和块之间通过映射表进行转换，映射表为key\n通过公开置乱函数，获得加密结果\n一些流行的块密码包括，DES（Data Encryption Standard，数据加密标准），3DES和AES（Advanced Encryption Standard，高级加密标准）\nDES使用了具有56bit密钥的64比特块\n3DES相当于三次DES，使用不同的密钥\nAES使用了128比特块，能够使用128、192、256比特长的密钥进行操作。\n密码块链接 当对报文进行分块时，可能存在一些相同的密文块，容易被识别，为了解决这个问题，可以在密文中混合一些随机性，通过产生随机的异或数即可解决。\n这样的话传输方必须多传输一倍的长度用于传输该随机异或数。因此产生了一种密码块链接（Cipher Block Chaining，CBC）的技术。即第一块使用随机的异或数，后面的每一块所异或的数为前一块的结果。\n2.公开密钥加密 公钥（public key）是公开的，接收方B知道私钥（private key）。\n步骤：发送方通过公开的公钥进行加密操作，接收方使用一个众所周知的解密算法，使用密钥进行解密。\n公钥密码体制不仅用于加密，也可以很方便的应用于鉴别和数字签名。\n由于公钥密码算法效率较低，一般用于会话密钥的建立，对称密钥密码体制被用于其它大多数情况下的加密。\nRSA 公钥私钥生成 1.选取两个大素数p,q\n2.计算n=pq、z=(p-1)(q-1)\n3.选取e，使得gcd(e,z)=1，e\u0026lt;n\n4.求取d ，ed mod z =1\n5.公钥（n,e）私钥（n,d）\n加密过程 对于一个比特组合，表示成十进制的正数m，m\u0026lt;n\n则对于m的加密值c为 c = m^e mod n ，使用公钥\n解密过程 对c进行解密：m = c^d mod n，使用私钥\n会话密钥 会话密钥（session key），即通过公开密钥加密对一个对称密钥进行加密，随后发送后双方获取该对称密钥，最后通过对称密钥密码体制对大量数据进行加密传输。\nRSA工作原理 TOPDOWN409\n7.3 报文完整性和数字签名 1. 密码散列函数 散列函数以m为输入，得到一个称为散列的定长字符串。checksum和CRC都满足这个定义。\n密码散列函数（cryptographic hash function）具有一种性质：找到任意两个不同的报文x和y使得H(x)和H(y)相等在计算上是不可能的。\nMD5 SHA-1 SHA-1输出160比特的报文摘要，但计算要比MD5慢一些，但实际安全性也没有达到设计目标，很快被SHA-2和SHA-3替代。\n2. 报文鉴别码 1.对报文m计算散列H(m)，比如利用SHA-1\n2.将H(m)附在m后面发送，形成扩展报文(m,H(m))\n3.接收方收到(m,h)后，如果计算H(m)=h，则正常。\n但这种方法只能检测报文是否受损，对实际的报文来源无法判断。\n因此需要通信双方共享一个鉴别密钥s\n1.发送方级联m+s，计算H(m+s)，形成拓展报文(m,H(m+s))，发送。 [这个H(m+s)被称为散列报文鉴别码HMAC（Message Authentication Code,MAC）]\n2.接收方接收(m,h)，计算H(m+s)，如果等于h则正常。\n3. 数字签名 数字签名（digital signature）应当是可以鉴别的、不可伪造的。\n采用公钥密码可以实现。签署方通过私钥进行加密，保障了数字签名不可伪造。\n核验方通过公钥进行核实。\n而一般不直接对报文进行签署，这样会带来极大的计算量，可以使用散列算法计算该报文的一个固定长度的数据”指纹“，表示为H(m)，再对散列函数进行签名操作。\n4.公钥认证 数字签名的一个重要应用就是公钥认证（public key certification），即证实一个公钥属于某个特定的实体。\n将公钥和特定实体进行绑定通常是由认证中心（certification Authority，CA）完成的。\n一旦验证，CA会生成一个将其身份和实体的公钥绑定起来的证书（certificate）\nTOPDOWN 415\n7.4 端点鉴别 1.基本概念 通信双方验证另一方身份的一种技术。\n最简单的方法就是使用用户名和口令。\n为了避免用户名和口令在传输过程中被截获，因此要对其进行加密。但也有漏洞，攻击者可以直接截获该加密报文，之后直接发送即可使接收方误判。（重放攻击，Replay Attack，或为playback attack），需要使用不重数nonce，即不重复使用的大随机数。\n不重数可以使用户把重复的实体鉴别请求和新的实体鉴别请求区分开来。\n双方各会发送一个不重数，并等待对方使用对称密钥进行加密操作，随后接收到对方的报文进行解密，获取不重数，若相等即可判定对方的身份。[能够正确加密解密的只有知道对称密钥的加密双方，并且也知道对方是活跃的]\n7.5 安全电子邮件 1.概述 需要保障机密性、完整性、以及对发送方、接收方的鉴别\n2.PGP PGP（Pretty Good Privacy）是电子邮件加密方案的一个范例，如TOPDOWN422图8-21\nPGP软件的不同版本使用MD5或SHA来计算报文摘要，使用CAST、三重DES或IDEA进行对称密钥加密，使用RSA进行公开密钥加密。\n7.6 TLS 传输层安全性（Transport Layer Security，TLS），使TCP连接安全。\n1.宏观描述 握手 创建TCP连接 三次握手\n验证端点真实性 一方发送TLS Hello报文，另一方回答证书，证书已由CA证实过\n发送主密钥MS 用于生成TLS会话所需要的对称密钥。\n该主密钥通过对方的公钥进行加密得到加密后的主密钥（EMS）并发送给对方。\n至此只有通信双方知道了该主密钥\n密钥导出 双方都使用MS产生四个密钥，TOPDOWN425.\n密钥导出阶段结束，双方都有了四个密钥，两个加密密钥用于数据加密 ，两个HMAC用于完整性鉴别\n数据传输 双方共享四个相同的会话密钥，能够进行TCP安全传输。\n2.TLS记录 由类型字段、版本字段、长度字段、数据字段和HMAC字段组成。\n7.7 IPSec和虚拟专用网 IP安全（IP Security）协议称为IPSec，为网络层提供了安全性。\n为任意两个网络层实体之间的IP数据报提供了安全。\n许多机构使用IPSec创建了运行在公共因特网上的虚拟专用网（Virtual Private Network，VPN）\n对于VPN，其中流量经过因特网之前进行加密。\n在IPSec协议族中，由两个主要协议：鉴别首部（Authentication Header，AH）协议和封装安全性载荷（Encapsulation Security Payload，ESP）协议。\n7.8 防火墙和入侵检测系统 防火墙（firewall）是一个硬件和软件的结合体，它将一个机构内部网络与整个因特网隔离开，允许一些数据分组通过而阻止另一些分组。\n防火墙具有三个目标：\n1.从外部到内部和从内部到外部的所有流量都通过防火墙\n2.仅被授权的流量（由本地安全策略定义）允许通过\n3.防火墙自身免于渗透\nCisco和Check Point使当今两个领先的 防火墙厂商。\n防火墙现在经常在路由器中实现并使用SDN进行远程控制\n防火墙分为三类：传统分组过滤器（traditional packet filter）、状态过滤器（stateful filter）和应用程序网关（application gateway）\nChapter8. 多媒体网络 8.1 音频 比特率=采样频率✖量化位数\n举例：\nCD: 1.411 Mbps\nMP3: 96, 128, 160 kbps\nInternet telephony: 5.3 kbps and up\n8.2 视频 CBR（constant bit rate）：视频编码固定速率\nVBR:(可变比特率):视频编码速率随空间、时间编码量的变化而变化\n例如：\nMPEG 1 (CD-ROM) 1.5 Mbps\nMPEG2 (DVD) 3-6 Mbps\nMPEG4 (often used in Internet, \u0026lt; 1 Mbps)\n8.3 多媒体网络 三种应用类型\n流媒体，存储音频、视频\nstreaming: can begin playout before downloading entire file\n流媒体:可以在下载整个文件之前开始播放\nstored (at server): can transmit faster than audio/video will be rendered (implies storing/buffering at client)\n存储(在服务器端):传输速度比音频/视频呈现速度快(意味着在客户端存储/缓冲)\n例如：YouTube，Netflix，Hulu\nIP会话语音/视频\n人与人之间对话的互动性限制了对延迟的容忍\n例如 Skype\n直播音频，视频\n1.流式存储视频 "}]