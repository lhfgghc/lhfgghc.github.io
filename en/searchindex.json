[{"section":"Blog","slug":"/en/blog/domjudge/","title":"【技术文档】DOMjudge部署手册（Docker版）","description":"this is meta description","date":"May 17, 2024","image":null,"imageSM":null,"searchKeyword":"","categories":"技术文档","tags":"DOMjudge, 环境配置","content":"DOMjudge部署手册（Docker版） 校程序设计竞赛的筹办期间决定使用DOMjudge作为评测系统，因此考虑进行本地部署，过程中通过官方手册、网上各类教程进行了学习与配置，但过程并非顺利，本文一方面为自己的部署过程的记录，另一方面也提供一种可能的部署方法以供参考。\n本文采用docker进行安装，操作系统为Ubuntu20.04\n1. 相关版本信息 操作系统：Ubuntu 20.04（所用镜像为ubuntu-20.04.6-desktop-amd64.iso）\nDOMjudge：8.2.2\ndocker：26.1.2\n2. 组成部分简述 DOMjudge的组成其实官方中文文档描述的相当清楚了，简单来说包含三个部分：数据库、domjudge server、judgehost。\ndomjudge server提供前后端服务，与数据库相连，同时统一控制一或多台judgehost，方式为轮询，因此在只有一台domjudge server的情况下，可能会收到网络瓶颈的影响。\njudgehost为评测机，处理运行提交的代码并返回结果。\n本文方法中以上三部分均由docker进行部署！！\n3.准备工作 包括docker的安装与cgroups的配置，后者为了对进程的资源进行限制，实现docker容器间的隔离。\ndocker的安装 这里使用sh脚本的安装方式，指令如下。\ncurl -fsSL https://get.docker.com -o get-docker.sh sh get-docker.sh --mirror Aliyun 这里可以进行一下镜像源的更换，最后执行以下指令使命令生效。\nsudo systemctl daemon-reload sudo systemctl restart docker 使用以下命令查看docker版本以验证安装是否成功。\ndocker version 例如下图所示，可以顺利打印版本信息，成功安装。\ncgroups配置 使用vim或者vi等文本编辑工具编写/etc/default/grub的文件内容。\n找到GRUB_CMDLINE_LINUX_DEFAULT，进行如下修改，并保存退出。\nGRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet cgroup_enable=memory swapaccount=1 systemd.unified_cgroup_hierarchy=0\u0026#34; 例如下图所示。\n执行以下命令更新grub配置。之后重启系统使配置生效。\nupdate-grub 4. 数据库与前后端服务配置 数据库配置 使用命令如下，该命令将生成一个docker容器，其中运行mariadb，命名为dj-mariadb。\nsudo docker run -d -it --name dj-mariadb -e MYSQL_ROOT_PASSWORD=123 -e MYSQL_USER=domjudge -e CONTAINER_TIMEZONE=Asia/Shanghai -e MYSQL_PASSWORD=123 -e MYSQL_DATABASE=domjudge -p 13306:3306 mariadb --max-connections=1000 --max-allowed-packet=1073741824 --innodb-log-file-size=536870912 其中参数MYSQL_ROOT_PASSWORD和MYSQL_PASSWORD需要进行密码的指定。\n\u0026ndash;max-connections最大连接数设置为1000即可，\u0026ndash;max-allowed-packet设置为1G（1073741824字节），\u0026ndash;innodb-log-file-size设置为512M（536870912字节）。前者需要是最大测试点的2倍大小以上，后者为最大测试迪安10倍大小以上。\nDOMjudge Server的配置 使用命令如下，\nsudo docker run --link dj-mariadb:mariadb -d -it -e MYSQL_HOST=mariadb -e MYSQL_USER=domjudge -e MYSQL_DATABASE=domjudge -e CONTAINER_TIMEZONE=Asia/Shanghai -e MYSQL_PASSWORD=123 -e MYSQL_ROOT_PASSWORD=123 -p 80:80 --name domserver domjudge/domserver:latest 其中参数MYSQL_ROOT_PASSWORD和MYSQL_PASSWORD与数据库中指定的密码需要一致，数据库名称为dj-mariadb不变即可。其余-p参数是指定前端服务的开放端口，这里设置为80（其它也可以），则直接访问主机IP即可访问到。\n最后的domjudge/domserver:latest设置了domserver的镜像版本为最新，可以指定版本，如domjudge/domserver:8.2.2，这个版本需要与后续的judgehost的配置一致。\n后台访问 至此基于docker完成了数据库和前后端应用的配置。\n对于前后端应用，直接访问IP:Port即可进入前端页面，有一个默认的管理员账户admin，对于admin的密码，执行以下命令可以获取\nsudo docker exec -it domserver cat /opt/domjudge/domserver/etc/initial_admin_password.secret 对于密码，例如下图所示。\n5. judgehost评测机配置 单评测机配置 指令如下\nsudo docker run -d -it --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:ro --name judgehost-0 --link domserver:domserver --hostname judgedaemon-0 -e DAEMON_ID=0 -e JUDGEDAEMON_PASSWORD=KEYKEYKEY -e CONTAINER_TIMEZONE=Asia/Shanghai domjudge/judgehost:latest 其中\u0026ndash;link指令指定了链接的前后端应用，\u0026ndash;name指定了开启的容器名称，\u0026ndash;hostname指定了当前评测机的名称（这在DOMjudge后台可以看到），DAEMON_ID指定占用的CPU核，。\n由于是DOMjudge server统一控制，使用一个密钥KEY进行判别，即子段JUDGEDAEMON_PASSWORD的值，对于密钥KEY的获取方式，执行以下命令可以得到。\nsudo docker exec -it domserver cat /opt/domjudge/domserver/etc/restapi.secret 多评测机部署 只需要修改\u0026ndash;name、\u0026ndash;hostname、DAEMON_ID三者即可。\n首先可以手动配置，当然这太麻烦了，也可以使用docker-compose，但我在配置过程中出现了错误，未解决，遂放弃使用docker-compose的多评测机的配置方法。\n使用了最古老最简单的的shell脚本循环的方式。。如下（dom_start_judgehost.sh）。\n执行sh dom_start_judgehost.sh KEY num。即可完成多评测机的部署，KEY为前面步骤获取的密钥KEY，num为准备开启的评测机的数目。\n#!/bin/bash key=$1 judgehostnum=$2 for hostid in $(seq $judgehostnum) do sudo docker run -d -it --privileged -v /sys/fs/cgroup:/sys/fs/cgroup --name judgehost-$hostid --link domserver:domserver --hostname judgedaemon-$hostid -e DAEMON_ID=$hostid -e CONTAINER_TIMEZONE=Asia/Shanghai -e JUDGEDAEMON_PASSWORD=$key domjudge/judgehost:latest done 6. 手动检查 主要检查docker中的容器是否都处于正常运行状态。使用命令sudo docker ps -a查看。例如下图所示。其中开启了8个评测机judgehost、1个数据库、一个DOMjudge server，并且都处于正常运行中。\n访问IP，通过admin用户进入后台，可以使用Administrator中的Config checker进行检查。\n7. 比赛配置 DOMjudge的后台功能相当强大，琢磨一阵子后基本了解如何使用。\n队伍信息导入 需要使用tsv文件进行导入，分为队伍导入和用户导入两部分，对应文件名为teams.tsv和accounts.tsv。\n先导入teams.tsv。其中第一行仅包含两个内容：teams和一个1；第二行开始，用八个数据来描述一个队伍，依次为id、ICPCid、队伍类型、队伍名称、校名、校名缩写、国家、校名id。其中id为唯一标识一个队伍的id，但经过尝试，虽然将其设置为不重复值，但是导入DOMjudge后仍为自动生成的id值；ICPCid可以任意进行设置，若无特殊需要；队伍类型固定为3，即参赛者；队名根据实际情况选定；校名、校名缩写、国家等内容若无特殊需要可以设置为空；校名id一般为学校缩写。\n可以先在Excel中进行数据的处理，随后复制到tsv文件中（记事本打开即可），建议写上校名id以凑满八个位置，不然还需要键入四个tab。例如以下处理方式。（可能存在一种方式可以设置好team的id，注意复制到记事本后需要确保第一行没有额外的空格或者tab）\n其次导入accounts.tsv。其中第一行包含accounts和1。从第二行开始，每条记录用四个数据描述：第一个固定为team；第二个为用户名称，我选用该队的队员名称组合作为用户名称；第三个为用户名；第四个为密码。例如下图。\n注意，由于用户和队伍是分别导入的，因此有一个将用户和队伍进行配对的规则，即看用户的用户名，去掉开头的字母和前缀0，取非零的数字得到的结果，即为挂载的队伍id，例如team037会挂载id为37的队伍。\n由于我导入team后，系统自动分配了队伍id，从37开始，因此我的用户用户名从team037开始。对于密码，开始设置了一样的密码后再导入，DOMjudge提供了密码的随机生成功能，上图即为随机生成后的密码。\n赛题配置 下载DOMjudge中的示例赛题文件夹，其中包含problem.pdf（题面）、domjudge-problem.ini（赛题的一些基础配置，如时限、颜色等）、problem.yaml（一般包含题目名称）、data文件夹（数据）。对于data文件夹，其中可以有sample文件夹和secret文件夹，其中sample中的数据可以被选手下载，secret中的数据即为评测数据。需要注意测试数据需要以in和ans为后缀。\n需要注意，重新压缩文件时要选择以上文件进行压缩，不要选择整个文件夹进行压缩，即要做到：解压你的zip文件后，得到以上具体文件而非一个包含以上文件的文件夹。\n比赛设置 对于单次比赛，直接在DOMjudge后台进行contest设置即可，配置过程比较简单，包括比赛开始时间、比赛结束时间、封榜解榜时间、赛题、赛题对应颜色、开放的队伍等。\n8. 性能说明 压力测试 开启8个评测机，每个评测机占用单核CPU，设置30个并发进程，一秒请求约4次可AC代码，评测队列几乎没有在queued的。\n增加并发进程到50左右，或设置TLE代码，会导致评测队列拥挤，但还是测得过来的。（如下图，宏观来看一秒钟约能过20个O(1)评测，一次刷新能测完100次提交左右）\n结论即，评测机压力不大，主要瓶颈在于网络，测试时使用的百兆网口，100个并发请求狂交代码3分钟左右（就像是100个队伍不写代码疯狂交题的感觉，显然这是不容易出现的情况）后，出现以下状况。于是只能重启容器。\n比赛效果 60队+输出类签到题，没有queued压力，同时评测机所在主机还开了CDS供榜单的显示。\n9. ICPC Tools 比赛中使用ICPC-Tools进行榜单的实时显示。\n需要配置三部分内容：CDS(Contest Data Server)、presentation admin、presentation client。\nCDS连接到DOMjudge，通过特定的API用户访问比赛信息，presentation admin连接至CDS，进行presentation client的统一控制，presentation client连接至CDS，用于具体内容的显示。\n官方网站为：The ICPC Tools | Home CDS 首先要在DOMjudge中创建一个用户，具有API reader、API writer、Source code reader三个权限，记其用户名和密码分别为cdsuser和cdspwd（可能要符合DOMjudge的密码复杂性规则）。\n从官网下载CDS，选用版本为CDS v2.5.1082，开始选定为Stable版本但始终有问题。\n解压下载到的压缩包，记为cds，进入cds/usr/servers/cds/config/cdsConfig.xml，进行内容的修改，大致内容如下。\n\u0026lt;cds\u0026gt; \u0026lt;!-- location为数据存储的位置，建议为当前用户目录下的某个文件夹，不需要root权限 --\u0026gt; \u0026lt;contest location=\u0026#34;/home/nbuacm/contest-data\u0026#34; recordReactions=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;!-- url中，domjudgeip为DOMjudge所在的IP，cid为连接比赛的ID，在DOMjudge后台查看即可 --\u0026gt;\t\u0026lt;!-- 注意不要使用https，一般DOMjudge服务不支持该协议 --\u0026gt; \u0026lt;!-- user和password即为在DOMjudge中创建的cds用户 --\u0026gt; \u0026lt;ccs url=\u0026#34;http://domjudgeip/api/contests/cid\u0026#34; user=\u0026#34;cdsuser\u0026#34; password=\u0026#34;cdspwd\u0026#34; /\u0026gt; \u0026lt;/contest\u0026gt; \u0026lt;/cds\u0026gt; 保存后回到cds文件夹所在目录，执行cds/bin/server start cds以启动cds服务器，可以看到cds服务器启动的字样，可以将start换成stop以关闭服务器。服务开放在8443端口，需要使用https协议访问，即访问https://ip:8443，其中ip即为本机的IP。使用浏览器访问该IP，应当能够顺利进入到CDS的后台，能够查看到比赛的相关数据，对于CDS后台的管理员，账号密码默认为admin和adm1n（一般在目录cds/usr/servers/cds/users.xml中，如下图所示）。\n有文章说不建议将CDS和DOMjudge放在一个主机上，但对于小规模比赛来说，应当是无压力的，可以进行适当的压力测试以验证。\nPresentation Admin 称其为显示管理器。同样需要下载客户端，可在官网中下载，两个版本似乎都能够顺利运行。\n显示管理器可以运行在Windows平台上，需要安装java1.8及以上（本人测试使用java17，能够顺利运行）。下载到文件压缩包后解压，包含内容如下。\n使用以下命令进行启动，其中cdsip为CDS服务器所在的主机IP，注意使用https协议，默认的显示管理器的admin账号和密码为presAdmin和padm1n。\nICPC_FONT=\u0026#34;Microsoft Yahei\u0026#34; ./presAdmin.bat https://cdsip:8443 presAdmin padm1n 对于上述命令，需要在Bash环境中运行，可以安装一个Git Bash进行运行。顺利的话可以进入显示管理器的客户端界面，如下所示，其中左边部分为连接到同一个CDS的presentation client，右边为显示的样式。\npresentation client 为显示内容的设备，需要安装java1.8及以上（没试过java1.8，本人安装的是java17）。对于下载的版本，使用了最新版v2.5.1082，对于稳定版v2.4.727，出现报错状况，未能成功运行。\n运行命令如下，其中cdsip为CDS所在主机的IP，需要注意要加上/api，账号密码为默认即可，设置\u0026ndash;name参数以进行多个显示终端的区分。\nICPC_FONT=\u0026#34;Microsoft Yahei\u0026#34; ./client.bat https://cdsip:8443/api/ presentation presentat1on --name \u0026#34;Site 1\u0026#34; 顺利运行的话应当能够直接进入全屏显示的界面，同时在presentation admin中也能够看到指定的设备出现，如下图所示。\n在控制客户端中选择select all即可选择所有被控client，选择右侧显示样式点击apply即可完成显示。如下图所示，为测试的效果，一台被控主机接出三个屏幕以显示倒计时、榜单等信息。\n"},{"section":"Blog","slug":"/en/blog/autoencoder/","title":"【学习笔记】Auto-Encoder自编码器的简单实现","description":"this is meta description","date":"May 10, 2024","image":null,"imageSM":null,"searchKeyword":"","categories":"深度学习, 学习笔记","tags":"数据压缩","content":"【学习笔记】Auto-Encoder自编码器的简单实现 一、基本概念 通过神经网络学习数据的有效低维表示，即编码，后使用该编码进行数据的重建。用于数据压缩、特性学习等任务。使用机器学习或深度学习手段令算法自己求解出数据表示结果的领域被称之为表征学习（Representation Learning）\n包含Encoder和Decoder两部分。网络目的是最小化原始输入和重构输出之前的差异。\n二、简单的自编码器 自编码器往往具备以下特征：\n输出层的神经元数目往往与输入层的一致。 网络架构具有对称性，即编码-解码结构对称。 线性自编码器 编码器：输入层接受原始数据。通过一个到多个隐藏层进行数据的处理（通常包含全连接层），每个层后通常会有一个非线性激活函数，如ReLU或者Sigmoid。\n解码器：输入层接收来自编码器的低维编码。通过一个到多个隐藏层进行数据的重建（结构通常与编码器相反），最后一层的维度与原始输入一致。\n卷积自编码器 通常隐藏层中使用卷积来捕获空间信息，在解码的过程中会使用转置卷积。\n三、代码编写 数据集的处理 使用数据集为stl10（STL-10 dataset (stanford.edu) ），具有十万张无标签的图片，规格为96×96。通过该数据集进行简单的自编码器训练。\n首先解压初始的tar.gz压缩文件可以得到所有的相关数据的二进制文件，包括训练集数据train_X.bin，训练集标签train_y.bin。\n处理数据集的二进制文件，将文件拆分为独立的png文件方便后续的处理。使用以下代码处理unlabeled_X.bin。\nimport torch import torch.nn as nn from torch.utils.data import Dataset, DataLoader from torchvision import transforms import torchvision.transforms.functional as F import imageio import os from pathlib import Path import numpy as np import matplotlib.pyplot as plt from imageio import imsave import warnings warnings.filterwarnings(\u0026#39;ignore\u0026#39;) # 读取二进制文件得到所有图片 def read_images(bin_path): with open(bin_path, \u0026#39;rb\u0026#39;) as f: images = np.fromfile(f, dtype=np.uint8) images = np.reshape(images, (-1, 3, 96, 96)) images = np.transpose(images, (0, 3, 2, 1)) return images # plt画图 def plot_images(image): plt.imshow(image) plt.show() # 保存单张图片 def save_image(image, name): imsave(\u0026#34;%s.png\u0026#34; % name, image, format=\u0026#34;png\u0026#34;) # 保存所有图片 def save_images(images, root): idx = 0 for image in images: directory = root os.makedirs(directory, exist_ok=True) filename = directory + str(idx).zfill(6) save_image(image, filename) idx = idx + 1 if __name__ == \u0026#39;__main__\u0026#39;: data_path = r\u0026#39;E:\\\\Project\\\\AutoEncoder\\\\data\\\\stl10_binary\\\\unlabeled_X.bin\u0026#39; images = read_images(data_path) print(images.shape) save_path = r\u0026#39;G:\\\\DLData\\\\STL10\\\\all_images\\\\\u0026#39; save_images(images, save_path) 编写Dataset类，读取前面处理出来的png类型的图片。\n对于imageio的imread()函数，读取到的图片为numpy数组存储，范围为[0,255]，使用torchvision.transforms.functional中的to_pil_image()可以将其转换为PIL形式，可以进行后续的ToTensor()变换为张量，经过变换后范围为[0,1]。\ndef cv2_loader(path): img = imageio.imread(path) # 转换为PIL形式的图片 img = F.to_pil_image(img) return img class Stl10Dataset(torch.utils.data.Dataset): def __init__(self, root, transform=None, train=True, loader=cv2_loader): self.root = root self.filenames = os.listdir(self.root) # self.filenames = self.filenames[:5000] self.transform = transform if self.transform is None: self.transform = transforms.Compose([ transforms.ToTensor(), # transforms.Normalize() ]) self.loader = loader print(len(self.filenames)) def __getitem__(self, item): filename = self.filenames[item] image = self.loader(os.path.join(self.root, filename)) if self.transform is not None: image = self.transform(image) return image def __len__(self): return len(self.filenames) 模型的定义 import torch import torch.nn as nn class AutoEncoder(nn.Module): def __init__(self, channel=3): super().__init__() self.channel = channel self.encoder = nn.Sequential( # [b,3,96,96] —\u0026gt; [b,16,96,96] nn.Conv2d(self.channel, 16, kernel_size=3, padding=1), # [b,16,96,96] —\u0026gt; [b,16,48,48] nn.MaxPool2d(kernel_size=2, stride=2), nn.ReLU(), # [b,16,48,48] —\u0026gt; [b,32,48,48] nn.Conv2d(16, 32, kernel_size=3, padding=1), # [b,32,48,48] —\u0026gt; [b,32,24,24] nn.MaxPool2d(kernel_size=2, stride=2), nn.ReLU(), # [b,32,24,24] —\u0026gt; [b,64,24,24] nn.Conv2d(32, 64, kernel_size=3, padding=1), # [b,64,24,24] —\u0026gt; [b,64,12,12] nn.MaxPool2d(kernel_size=2, stride=2), nn.ReLU(), ) self.decoder = nn.Sequential( # [b,64,12,12] ———\u0026gt; [b,32,24,24] nn.ConvTranspose2d(64, 32, kernel_size=4, stride=2, padding=1), nn.ReLU(), # [b,32,24,24] ———\u0026gt; [b,16,48,48] nn.ConvTranspose2d(32, 16, kernel_size=4, stride=2, padding=1), nn.ReLU(), # [b,16,48,48] ———\u0026gt; [b,3,96,96] nn.ConvTranspose2d(16, self.channel, kernel_size=4, stride=2, padding=1), nn.ReLU() ) def forward(self, x): x = self.encoder(x) x = self.decoder(x) return x def encode(self, x): return self.encoder(x) def decode(self, x): return self.decoder(x) if __name__ == \u0026#39;__main__\u0026#39;: net = AutoEncoder(channel=3) x = torch.randn(1, 3, 96, 96) y = net(x) print(y.shape) 模型训练 import torch import torch.nn as nn import torch.optim as optim from DataSet import Stl10Dataset from model import AutoEncoder from torch.utils.data import DataLoader from tqdm import tqdm import numpy as np import matplotlib.pyplot as plt def train(model, data_loader, optimizer, epochs, device): # 挂载GPU model.to(device) # 均方误差作为损失函数 criterion = nn.MSELoss().to(device) # 训练模式 model.train() for epoch in range(epochs): # 使用tqdm组件进行进度显示 with tqdm(total=len(data_loader), desc=f\u0026#39;Epoch {epoch + 1}/{epochs}\u0026#39;, unit=\u0026#39;batch\u0026#39;) as pbar: # 遍历数据集 for data in data_loader: # 把训练数据转移到GPU上 data = data.to(device) # 模型推理 output = model(data) # 计算损失 loss = criterion(output, data) # 清空上一轮的梯度 optimizer.zero_grad() # 反向传播计算梯度 loss.backward() # 调整模型参数 optimizer.step() # 在tqdm中进度显示Loss pbar.set_postfix({\u0026#39;Loss\u0026#39;: loss.item()}) pbar.update(1) # 每一个epoch结束进行一次简单的测试 test(model, data_loader, epoch) # 保存模型 if (epoch + 1) % 20 == 0: average_loss = loss.item() torch.save(model.state_dict(), f\u0026#39;model_{epoch + 1}.pth\u0026#39;) # 测试模型 def test(model, data_loader, selected_idx): # 测试模式 model.eval() # 不影响梯度 with torch.no_grad(): for i, img in enumerate(data_loader): if i == selected_idx: # 找到选中的数据，其实用cpu计算就好了 img = img.cuda() encoded = model.encode(img) decoded = model.decode(encoded) # 由于返回的shape可能为[b,c,h,w]，取这个batch中的一个 # squeeze()压缩第一维度 [1,c,h,w]-\u0026gt;[c,h,w] # 使用permute调整维度顺序，最后转换为numpy数组用于图片的显示 original_img = img[0, :, :, :].cpu().squeeze().permute(1, 2, 0).numpy() decoded_img = decoded[0, :, :, :].cpu().squeeze().permute(1, 2, 0).numpy() # 显示图片 plt.figure(figsize=(6, 3)) plt.subplot(1, 2, 1) plt.title(\u0026#34;Original\u0026#34;) plt.imshow(original_img) plt.axis(\u0026#39;off\u0026#39;) plt.subplot(1, 2, 2) plt.title(\u0026#34;Decoded\u0026#34;) plt.imshow(decoded_img) plt.axis(\u0026#39;off\u0026#39;) plt.show() break if __name__ == \u0026#39;__main__\u0026#39;: # 数据路径 data_path = r\u0026#39;G:\\\\DLData\\\\STL10\\\\all_images\\\\\u0026#39; device = torch.device(\u0026#39;cuda:0\u0026#39; if torch.cuda.is_available() else \u0026#39;cpu\u0026#39;) batch_size = 32 learning_rate = 0.001 # 模型的定义 model = AutoEncoder(channel=3).to(device) # 优化器 optimizer = optim.Adam(model.parameters(), lr=learning_rate) # 数据集 dataset = Stl10Dataset(data_path) # 数据加载器 data_loader = DataLoader(dataset=dataset, batch_size=batch_size, shuffle=False, pin_memory=True) # 模型的训练 train(model=model, data_loader=data_loader, optimizer=optimizer, epochs=100, device=device) # 模型的测试 data_loader = DataLoader(dataset=dataset, batch_size=1, shuffle=False, pin_memory=True) test(model=model, data_loader=data_loader, selected_idx=3) 四、训练结果 大约25个epochs后，Loss约为0.003，由于编码后的shape[b,64,12,12]仍然较大，能够保存较多的信息，效果如下图所示。当调整最终的编码shape，例如为[b,16,12,12]，最终解码得到的图片会更为“模糊”。\n参考资料 自编码器算法介绍 - 知乎 (zhihu.com) 自编码器（AE、VAE）的原理与代码实现 - 知乎 (zhihu.com) "},{"section":"Blog","slug":"/en/blog/bert/","title":"【学习笔记】BERT的基本结构与原理","description":"this is meta description","date":"March 14, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 学习笔记","tags":"自然语言处理, 文本分类","content":"【学习笔记】Transformer \u0026amp; BERT 1. Transformer 完全基于注意力机制（Attention）的模型。\n考虑RNN处理文本问题，当输入的句子长度较长时，RNN很可能会遗忘之前句子中出现的词或者内容，Transformer中的Attention就使得句子中重要的内容的权重增大，以保证不会被遗忘，同时可以并行计算。\nEncoder的网络结构 Transformer为Encoder-Decoder结构，首先关注Encoder。\n内部结构为：输入经过Input Embedding模块进行向量化，并且直接加上位置编码Positional Encoding，随后数据依次进入Muti-Head Attention模块，Add\u0026amp;Norm模块，Feed Forward模块，另一个Add\u0026amp;Norm模块，整个结构重复N次。\nPositional Encoding 来表示输入句子向量中的每个词的所在位置，使Transformer能够获得句子的时序信息。常见的计算方法就是使用正弦函数和余弦函数来构造每个位置的值，或者使用一些可训练的参数。\nSelf-Attention 对于注意力机制，可以简单理解为对于任意一个需求的查询$Q$，都会面临各种要素的键值对$K,V$，通过匹配$Q$和$K$来获取指定的$V$的整合来作为该查询$Q$所能得到的反馈。相当于不同的查询$Q$具有不同的注意力点，得到的$V$也是不同的。例如将中文翻译成英文的过程，对于每一个中文单词，都有一个到英文句子的映射，对于英文句子中的某些单词具有更强的注意力。\n简易的表达式如下，即根据$K$和$Q$的相似度加权取$V$进行组合。\n$$ att((K,V),Q)=\\sum_{i=1}^{N}\\frac{exp(\\mathbf{k_i}\\mathbf{q})}{\\sum_{j}exp(\\mathbf{k_j}\\mathbf{q})}v_i $$\n考虑到查询一般是一个词，词向量可能和$QKV$的维度不一样，因此考虑设置线性变换矩阵，将词向量线性变换到与$QKV$相同的维度。使用矩阵形式进行描述，首先计算$Q$和$K$的内积，并处以$\\sqrt{d_k}$以防止内积过大，并通过softmax进行归一化。\n$$ att(Q,K,V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V $$\n而自注意力机制则考虑的是同一序列中不同位置的关联程度，它只关注输入本身或者对象本身，可以筛选全局中的重要信息，并且建立全局中的依赖关系。例如一个句子中的某一个单词，会聚焦于这个句子其它位置的单词。（自注意力的$Q$和$K$是相同来源的）\nMulti-Head Attention 考虑：一段文字可能有多个维度的注意力，例如情感、时间、逻辑，则需要从多个不同的维度抓住输入信息的特点，因此有了多头注意力Multi-Head Attention，把输入序列映射为多组不同的$QKV$，分别进行计算后将结果进行合并(concat)。\n在代码实现中，与上图的过程有所不同，只用了一个大一点的变换矩阵得到$QKV$，然后在特征维度上进行划分，得到h组$QKV$，对每一组$QKV$计算一个结果后进行concat。\nBERT中的self-attention实现代码片段：\nclass BERTSelfAttention(nn.Module): # BERT 的 Self-Attention 类 def __init__(self, config): # 初始化函数 super(BERTSelfAttention, self).__init__() # 隐藏层(词向量)的维度需要是注意力头的整数倍，使得能够准确划分 if config.hidden_size % config.num_attention_heads != 0: raise ValueError( \u0026#34;The hidden size (%d) is not a multiple of the number of attention \u0026#34; \u0026#34;heads (%d)\u0026#34; % (config.hidden_size, config.num_attention_heads)) self.num_attention_heads = config.num_attention_heads # 每个注意力头的维数 self.attention_head_size = int(config.hidden_size / config.num_attention_heads) self.all_head_size = self.num_attention_heads * self.attention_head_size # 将输入进行线性变换 self.query = nn.Linear(config.hidden_size, self.all_head_size) self.key = nn.Linear(config.hidden_size, self.all_head_size) self.value = nn.Linear(config.hidden_size, self.all_head_size) def transpose_for_scores(self, x): # 调整维度，转换为 (batch_size, num_attention_heads, hidden_size, attention_head_size) new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size) x = x.view(*new_x_shape) return x.permute(0, 2, 1, 3) def forward(self, hidden_states): # 线性变换QKV mixed_query_layer = self.query(hidden_states) mixed_key_layer = self.key(hidden_states) mixed_value_layer = self.value(hidden_states) # 维度调整 query_layer = self.transpose_for_scores(mixed_query_layer) key_layer = self.transpose_for_scores(mixed_key_layer) value_layer = self.transpose_for_scores(mixed_value_layer) # 将\u0026#34;query\u0026#34;和\u0026#34;key\u0026#34;点乘，得到未经处理注意力值 attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) # 除以根号下的q的维度 attention_scores = attention_scores / math.sqrt(self.attention_head_size) # 使用 softmax 函数将注意力值标准化成概率值 attention_probs = nn.Softmax(dim=-1)(attention_scores) # 获取注意力分数 context_layer = torch.matmul(attention_probs, value_layer) # 调整维度并返回 context_layer = context_layer.permute(0, 2, 1, 3).contiguous() new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,) context_layer = context_layer.view(*new_context_layer_shape) return context_layer Add \u0026amp; Norm 进行了残差连接和归一化，归一化选用的是LN。（单独分析词向量的某一维度是意义不大的，因此不选用BN对相同的维度进行归一化）\nFeed Forward 全连接层的公式如下。先线性变换，然后ReLU非线性，再线性变换。经过FFN的维度并未发生变化，但本质上两层线性变换中，首先将输入映射到了一个更高的维度空间中，经过ReLU筛选后变回原来的维度。 $$ FFN(x)=max(0, xW_1+b_1)W_2+b_2 $$\n整体结构 两种输入模式 Transformer在进行训练时，同时具有outputs的数据，而在预测时，将上一轮的输出作为输入（不能够知道当前时刻以后的信息）。\nMasked Multi-Head Attention 与多头注意力大体一致，增加了掩码，对某些值进行了覆盖，使其在参数更新时不产生效果。Transformer中涉及到两种Mask：padding mask和sequence mask。\n对于padding mask：考虑到每次输入的序列长度是不一样的，需要对序列进行对齐操作（或者说是填充操作），这些填充的位置是没有意义的，即对于attention来说，不应该把注意力放在这些位置之上，因此可以在这些位置上加上很大的负数，那么经过softmax后，这些位置的概率会接近于0。\n对于sequence mask，为了让decoder不能够看到未来的相关信息，在解码的时候只能依赖于当前时刻之前的输出，因此需要将当前时刻之后的信息进行隐藏。这部分信息在训练的时候是有效的，在训练的时候outputs的数据是完整地进入到decoder中的，但在预测时不需要。一种做法是产生一个上三角值全为0的上三角矩阵。\n2. BERT 来源论文《Pre-training of Deep Bidirectional Transformers for Language Understanding》，BERT（Bidirectional Encoder Representations from Transformers）。\n基本原理 BERT整体是一个自编码的语言模型，设计了两大任务来预训练该模型：1. 采用MaskLM的方法来训练，在输入一句话的时候，随机地选一些要预测的词，然后用一个特殊符号[MASK]来代替，然后让模型根据所给的标签去学习这些地方该填的词。 2. 在双向语言任务的基础上额外增加了一个句子级别的连续性预测任务，即预测输入BERT的两段文本是否为连续的文本，这个任务可以让模型学习到连续的文本片段之间的关系。\nBERT与Transformer 在BERT中只使用了Transformer的Encoder模块，原论文中作者使用了12层和24层Transformer Encoder组成的BERT模型。但与Transformer Encoder相比，BERT中的输入向量表示多了Segment Embeddings。\nMasked LM 该任务即为：给定一个句子，随机抹去这句话的一些词，要求根据剩下的词去预测抹去的词是什么。相当于完形填空的任务。在文中，作者的做法为：随机选择15%的词用作预测，对于在原句中被抹去的词汇，80%用[MASK]替换，10%采用任意词替换，10%情况保持原词不变。这会使得在后续的微调任务中语句不会出现[MASK]标记，同时在预测一个词汇时，模型并不知道输入对应位置的词汇是否为正确的词汇（这有10%的概率），故使得模型更多依赖上下文信息去预测词汇，也赋予了模型纠错能力。\nNext Sentence Prediction 该任务即为：给定一篇文章中的两句话，判断第二句话中文本是否紧跟在第一句话之后。衍生的任务可以是段落重排序任务。\n联合这两个任务，使得模型输出的每一个词都能够尽可能全面地刻画输入文本的整体信息，为后续的微调任务提供更好的模型参数初始值。\n输入输出 BERT的输入为文本中各词的原始词向量（可以是随机的，也可以是经过Word2Ver算法进行预训练的结果）。模型的输出是文本中token经过全文语义信息的融合后的向量表示。如图。\n模型的输出除了字向量（Token Embedding）外，还包含文本向量（Segment Embeddings）和位置向量（Positional Embeddings）。\n文本向量：取值在模型的训练过程中自动学习，用于刻画文本的全局语义信息，并融合了单字的语义信息。\n位置向量：刻画Token的出现位置。\n实际上，在做 Next Sentence Prediction 任务时，在第一个句子的首部会加上一个[CLS] token，在两个句子中间以及最后一个句子的尾部会加上一个[SEP] token。\n3. 代码（以文本分类为例） BertTokenizer BERT分词器，对原句进行分词操作。\n使用from_pretrained()函数传入预训练的模型参数。\n**tokenize()**函数实现分词，中文默认会划分为一个个字，英文会按照空格进行划分。 同时会按照概率随机地进行Mask替换，也可以自行输入标记。\ntk = BertTokenizer.from_pretrained(model_name) text = \u0026#39;你的 我的 大家的\u0026#39; print(tk.tokenize(text)) # [\u0026#39;[UNK]\u0026#39;, \u0026#39;的\u0026#39;, \u0026#39;我\u0026#39;, \u0026#39;的\u0026#39;, \u0026#39;大\u0026#39;, \u0026#39;家\u0026#39;, \u0026#39;的\u0026#39;] text = \u0026#39;Hello BERT for me\u0026#39; print(tk.tokenize(text)) # [\u0026#39;hello\u0026#39;, \u0026#39;bert\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;me\u0026#39;] text = \u0026#39;Hello [MASK] BERT for me\u0026#39; print(tk.tokenize(text)) # [\u0026#39;hello\u0026#39;, \u0026#39;[MASK]\u0026#39;, \u0026#39;bert\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;me\u0026#39;] convert_tokens_to_ids() 函数能够将字映射到id上，通常配合分词器使用。convert_ids_to_tokens,将id转化成token，通常用于模型预测出结果，查看时使用。\ntk = BertTokenizer.from_pretrained(model_name) text = \u0026#39;Hello [MASK] BERT for me\u0026#39; tokenized_text = tk.tokenize(text) ids = [tk.convert_tokens_to_ids(i) for i in tokenized_text] print(ids) # [7592, 103, 14324, 2005, 2033] encode() 函数能够进行分词和token转换，相当于结合上述两个函数。输出结果也自动添加了开始标记和结束标记。特别地，encode函数可以传入列表，相当于可以手动地先进行分词，再传入进行token转换。\ntk = BertTokenizer.from_pretrained(model_name) text = \u0026#39;Hello [MASK] BERT for me\u0026#39; tokenized_text = tk.encode(text) print(tokenized_text) # [101, 7592, 103, 14324, 2005, 2033, 102] text = \u0026#39;今天的天气，有点差\u0026#39; tokenized_text = tk.encode(text) print(tokenized_text) # [101, 100, 1811, 1916, 1811, 100, 1989, 1873, 100, 100, 102] encode_plus() 函数可以在encode的基础之上生成input_ids、token_type_ids、attention_mask。它可以传入'123 123 123\u0026rsquo;之类的数据，会被当成英文单词进行按空格划分。\ntk = BertTokenizer.from_pretrained(model_name) text = \u0026#39;今天的天气，有点差\u0026#39; tokenized_text = tk.encode_plus(text) print(tokenized_text) # {\u0026#39;input_ids\u0026#39;: [101, 100, 1811, 1916, 1811, 100, 1989, 1873, 100, 100, 102], # \u0026#39;token_type_ids\u0026#39;: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], # \u0026#39;attention_mask\u0026#39;: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]} batch_encode_plus() 函数可以在encode_plus()函数的基础上进行词的批量处理。这会导致如果直接传入的是一个字符串，该函数会把它视作一个列表，因此可能需要套入一个列表。（该函数是从传入的列表依次取元素进行分词操作）\n常用参数有add_special_tokens=True, max_length=128, pad_to_max_length=True。表示是否添加特殊标记，输出的词向量维度，是否进行补零直到max_length长度。truncation=True为大于max_length后截断。\n处理好的input_ids和attention_mask的shape都是[batch, len]。\ntk = BertTokenizer.from_pretrained(model_name) text = \u0026#39;123 4\u0026#39; tokenized_text = tk.batch_encode_plus(text) print(tokenized_text) # \u0026#39;input_ids\u0026#39;: [[101, 1015, 102], [101, 1016, 102], [101, 1017, 102], [101, 102], [101, 1018, 102]] text = [\u0026#39;123 4\u0026#39;] tokenized_text = tk.batch_encode_plus(text) print(tokenized_text) # \u0026#39;input_ids\u0026#39;: [[101, 13138, 1018, 102]] BertModel 主要为Transformer的Encoder结构。\n输入：\nnput_ids：经过 tokenizer 分词后的 subword 对应的下标列表；attention_mask：在 self-attention 过程中，这一块 mask 用于标记 subword 所处句子和 padding 的区别，将 padding 部分填充为 0；\n输出：\nlast_hidden_state[batch_size, sequence_length, hidden_size]，对每一个词都有一个长度为hidden_size的词向量表示。\npooler_output[batch_size, hidden_size]，这是序列的第一个token(classification token)的最后一层的隐藏状态，它是由线性层和Tanh激活函数进一步处理的。\n使用BERT进行文本分类 class BertClassification(nn.Module): def __init__(self): super(BertClassification, self).__init__() self.model_name = \u0026#39;model\u0026#39; self.model = BertModel.from_pretrained(self.model_name) self.tokenizer = BertTokenizer.from_pretrained(self.model_name) self.fc = nn.Linear(768, 15) def forward(self, x): print(x) batch_tokenized = self.tokenizer.batch_encode_plus(x, add_special_tokens=True, max_length=128, pad_to_max_length=True) # input_ids[batch, len] attention_mask[batch, len] input_ids = torch.tensor(batch_tokenized[\u0026#39;input_ids\u0026#39;]) attention_mask = torch.tensor(batch_tokenized[\u0026#39;attention_mask\u0026#39;]) # last_hidden_state[batch, len, hidden_len] # pooler_output # hidden_states 可选 # attentions 可选 hidden_outputs = self.model(input_ids,attention_mask=attention_mask) # hidden_outputs[0][:,0,:].shape = [len, hidden_len] 取到CLS的Embedding output = self.fc(hidden_outputs[0][:,0,:]) return output 句子表征 分类任务中，需要得到一个句子的Embedding，常见的方法有：\n直接用CLS Token的Embedding作为句子表征（其实也就是pooler_output的内容）但有缺点在于压缩的信息太多了 最后几层上下文 Embedding 的平均值：会损失语义，尤其是对Self-Attention取平均，甚至会弱化本来得到的Attention。 最后一层的Embedding再走一层CNN或者别的深度网络，但会增加一些学习的成本。 参考文章 BERT模型的详细介绍-CSDN博客 12-NLP之Bert实现文本分类_bert文本分类-CSDN博客 BERT_Tokenizer - 知乎 (zhihu.com) 【transformers】tokenizer用法（encode、encode_plus、batch_encode_plus等等）_transformers tokenizer参数-CSDN博客 Bert系列：如何用bert模型输出文本的embedding_bert获取embedding-CSDN博客 "},{"section":"Blog","slug":"/en/blog/it-project-management/","title":"【课程笔记】IT项目管理","description":"this is meta description","date":"March 2, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"IT项目管理","content":"一、基本概念 1.1 价值 1.1.1 项目的价值 组织通过日常工作来维持基本的运行，通过项目来推进自身的发展和壮大。 项目价值是指项目具有明示和潜在的功能，能满足利益相关方明示和潜在的需要。 项目是实现价值、成就事业的载体，通过项目来实现企业和人生的价值，通过三个层次来体现：管理项目、发现项目、创造项目。\n1.1.2 项目管理的价值 项目管理是管理学的子集，具有管理学在通常意义上的价值。项目管理最主要的价值来源是通过完成业务目标来获得的，而要确保业务目标的实现，需要有效的项目管理，实行项目管理可以为企业创造巨大价值。\n1.2 项目概念 1.2.1 人类活动的特点 目的性、依存性、知识性\n1.2.2 作业与项目 作业：连续不断、周而复始的活动；项目：临时的、一次性的活动\n1.2.3 项目定义 利用有限资源、在一定时间内，完成满足一系列特定目标的多项相关工作\n1.2.4 项目特征 目标独特性、项目一次性、项目整体性、项目临时性、项目不确定性、资源多变性\n1.3 项目管理 现代管理科学是从关键路径法（Critical Path Method，CPM）和计划评审技术（Program Evaluation and Review Technique，PERT）的基础上发展，通过融合后发展起来的工作分解结构（Work Breakdown Structure，WBS）、蒙特卡洛（MonteCarlo Simulation，MCS）统计模拟方法和挣值（Earned Value，EV）分析技术，形成关于项目资金、时间、人力等资源控制的管理科学。\n1.3.1 管理的概念 管理是管理者为了有效地实现组织目标、个人发展和社会责任，运用管理智能进行协调的过程。 内涵P9\n1.3.2 项目管理定义 美国项目管理协会PMI给出定义：项目管理就是将知识、技能、工具与技术应用于项目活动，以满足项目的需要。项目管理通过合理运用和整合项目管理过程得以实现。 五大过程组：启动、规划、执行、监控、收尾\n1.3.3 项目管理特点 五项基本任务：项目计划、项目组织、质量管理、费用控制、进度控制 项目管理必须通过不完全确定的过程，在确定的期限内生产出不完全确定的产品或完成不完全确定的任务。 P11\n1.3.4 项目管理知识体系 PMI和PMBOK\nPMI：美国项目管理协会\nPMBOK：项目管理知识系统\n4大核心知识领域：项目范围管理、项目时间管理、项目成本管理、项目质量管理\n5大辅助知识领域：项目人力资源管理、项目沟通管理、项目风险管理、采购管理和项目于系人管理\nIPMA与ICB\nIPMA：国际项目管理协会\nICB：国际项目管理知识体系\n划分为42个要素：28个核心要素、14个附加要素；个人素质的8大特征、总体印象的10个方面\n1.4 IT项目 信息技术IT：包括传感器技术、通信技术、计算机技术、控制技术等\n1.4.1 定义 信息化的实现以IT项目为载体，以信息技术为基础。 用IT信息化来综合描述信息技术与信息化，与此对应的项目称之为IT信息化项目；有时将以计算机为主体的各种项目称为IT项目。 利用有限资源、在一定时间内，完成满足一系列特定的IT信息化目标和多项相关工作叫做IT项目。\n1.4.2 IT项目特征 目标不确定性、需求不稳定性、费用不可控性、项目时限性、对智力的依赖性、项目评价的主观性、项目创新性\n1.4.3 IT项目管理 定义：是指在一定期限内，根据一定的IT信息化项目需求，依托一定的资源，为达成一定的IT信息化目标而进行的一系列活动 特点：P24\n1.5 软件与软件项目 软件定义、软件分类、软件特点、软件项目特点、软件项目管理意义与重点\n课后题与思考 "},{"section":"Blog","slug":"/en/blog/security/","title":"【课程笔记】信息安全技术","description":"this is meta description","date":"March 2, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"信息安全技术","content":"《信息安全技术》 1. 信息与网络安全概念 3. 传统加密技术 3.1 对称密码模型 包含：明文M、加密算法E、密钥K、密文C、解密算法D\nE总是公开的，保密依靠密钥K\n满足要求：1. 加密算法必须足够强，至少在敌手获取一个或者多个密文时无法破译密文或算出密钥。 2. 发送方和接收方必须在某种安全的形式下获得密钥并且必须保证密钥安全（密钥需要通过安全信道）。\n3.1.1 密码编码学 密码编码学系统将具有以下三个独立的特征。\n将明文转换为密文的运算类型：基于代替和置换 密钥数目：分为对称加密和非对称加密 处理明文的方法：分为分组密码和流密码 [分组密码每次处理输入的一组元素，相应地输出一组元素，流密码连续地处理输入元素，每次输出一个元素] 3.1.2 密码分析学和穷举攻击 攻击密码系统的典型目标是恢复使用的密钥，而不是只恢复单个密文对应的明文。通用方法包括密码分析学和穷举攻击。\n密码分析学：依赖算法的性质、明文的一般特性或者某些明密文对。\n穷举攻击：尝试所有可能的密钥。\n加密算法应当满足的标准：\n破译密码的代价超过密文信息的价值； 破译密码的时间超过密文信息的有效生命期。 3.2 代替技术 3.2.1 Caesar密码 密钥k，明文C，每个明文字母k：C=E(k,p)=(p+k) mod 26\n解密：p=D(k,C) = (C-k) mod 26\n缺陷：需要测试的密钥只有25个，容易被进行穷举攻击分析。\n3.2.2 单表替代密码 置换：有限集合中交换位置，有n个元素的集合则有n!个置换。\n缺陷：虽然密钥空间很大没法穷举攻击，但是它带有原始字母使用频率的一些统计学特征。\n思考：如果对每个明文元素分配的密文元素的个数与此明文元素的使用频率成一定的比例关系，那么使用频率信息就会被完全破坏。解决方案：多个字母一起加密或者多表替代。\n3.2.3 PlayFair密码 密钥词构造出一个密钥矩阵：去除重复元素，从上到下从左到右填入矩阵单元，剩余的元素按顺序进行填写，IJ当作一个字母。\n加密方法：\n将明文进行字母对划分，若两个字母是相同的，就在中间添加一个填充字母x； 落在矩阵同一行的字母对，由右边的字母替代； 落在矩阵同一列的字母对，由下面的字母替代； 该字母所在行为密文所在行，另一个字母所在列为密文所在列（先看行再看列）。 3.2.4 Hill密码 带模数的矩阵乘法加密，乘矩阵的逆进行解密\n3.2.5 多表替代加密 Vigenere密码：在Caesar的基础上增加密钥词，密钥是一个密钥词的重复。 $$ C_i=(p_i+k_{i\\ mod \\ m})\\ mod \\ 26 $$ 缺陷：密文依旧存在循环的统计特征，有一个”密钥自动生成系统“的方案：将密钥词和明文自身连接起来以便生成不重复的密钥词。\n3.2.6 一次一密 使用与消息一样长且无重复的随机密钥来加密消息，密钥只加密一条消息，之后丢弃不用。\n3.3 置换技术 一种复杂的方案为：将消息一行一行地写成矩阵，然后按列读出，但是要把列的次序进行打乱，打乱的方法根据密钥产出。多次置换密码相对来说要安全地多。\n"},{"section":"Blog","slug":"/en/blog/compiler/","title":"【课程笔记】编译原理","description":"this is meta description","date":"March 2, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"编译原理","content":"《编译原理》 一、引论 1.1 编译程序 翻译程序：将某一种语言程序（称为源语言程序）转换成另一种语言程序（称为目标语言程序）。\n解释程序：以该语言写的源程序为输入，但不产生目标程序，边解释边执行源程序本身。\n分类：\n诊断编译程序Diagnostic Compiler：帮助程序开发和调试 优化编译程序Optimizing Compiler：提高目标代码效率 交叉编译程序Cross Compiler：产生不同于其宿主机的机器代码的编译程序 可变目标编译程序Retargetable Compiler：不需要重写编译程序中与机器无关的部分就能改变目标机。 1.2 编译过程 五个阶段：词法分析、语法分析、语义分析与中间代码生成、优化、目标代码生成。\n词法分析：基于构词规则，输入源程序将其中的字符串进行扫描和分解得到一个个单词。工具为正规式和有限自动机 语法分析：基于语法规则，将单词符号串分解为各类语法单位，如“短语”、“子句”等。工具为：上下文无关文法，这是一种层次结构分析。 语义分析与中间代码生成：对语法分析所识别出的各类语法范畴进行含义分析，并进行初步翻译。首先进行静态语义检查（变量是否定义等），语义正确则进行中间代码翻译。依照语义规则（使用属性文法描述）。中间代码：一种含义明确、便于处理的记号系统，通常独立于具体的硬件。例如四元式（算符-左操作数-右操作数-结果） 优化：对中间代码进行加工变换，使得在最后阶段能产生出更高效的目标代码。主要方面：公共子表达式的提取、循环优化、删除无用代码、并行化处理等。原则：程序的等价变换规则。 目标代码生成：把中间代码变化成特定机器上的低级语言代码。依赖于硬件系统结构和机器指令含义。目标代码的形式可以是绝对指令代码（可以立即执行）或可重定位的指令代码或汇编指令代码（需要汇编器汇编后才能执行）。大多数编译程序产生的目标代码都是一种可重定位的指令代码，还需要连接装配程序把各个目标模块连接在一起，并确定程序变量在主存中的位置、装入内存中指定的起始地址。 1.3 编译程序的结构 源程序-\u0026gt;词法分析器-\u0026gt;单词符号。词法分析器，又称为扫描器。 单词符号-\u0026gt;语法分析器-\u0026gt;语法单位。语法分析器，简称分析器。 语法单位-\u0026gt;语义分析与中间代码生成器-\u0026gt;中间代码。 中间代码-\u0026gt;优化器-\u0026gt;优化后的中间代码。 优化后的中间代码-\u0026gt;目标代码生成器-\u0026gt;目标代码。 表格与表格管理\n需要保持一系列表格以登记源程序的各类信息和编译各阶段的进展状况。最重要的是符号表，用来登记源程序中出现的每个名字以及名字的各种属性。（编译程序处理到名字的定义性问题时，要把各种属性填入到符号表，处理到使用性问题时，要对名字的属性进行查证。词法分析填名字，语义分析填类型，目标代码生成填地址）\n出错程序\n发现错误，报告错误，指出错误的性质和错误发生地点，并且将错误的影响限制在尽可能小的范围内。错误通常分为语法错误（在词法分析或语法分析检测出来，例如出现非法字符，括号不匹配等）和语义错误（有些只能在运行时检测出来，通常包括类型不一致、作用域错误等）两大类。\n遍\n对源程序或源程序的中间结果的一次从头到尾的扫描。当一遍中包含若干阶段时，各阶段的工作是穿插进行的，如词法分析、语法分析、语义分析和中间代码生成这三个阶段可以被安排成一遍。\n编译前端与后端\n前端：与源语言有关但与目标机无关的组成部分。（词法分析、语法分析、语义分析与中间代码生成）\n后端：与目标机有关的部分。（代码优化和目标代码生成）\n通常以中间代码为界。\n1.4 编译程序与程序设计环境 开发工具：编辑程序、连接程序、调试工具等。\n程序设计环境：编译程序+开发工具\n目前倾向于构造集成化的程序设计环境。类似于IDE？\n1.5 编译程序的生成 早期的编译程序大都是机器语言或汇编语言用作工具，但现在使用高级语言作工具来编译程序。\n现在有利用已有的高级语言开发新的高级语言，即采用一种“移植”方法，现在已有多种编制部分或张晶晶个编译程序的工具，例如编译程序-编译程序、编译程序产生器、翻译程序书写系统。\n二、高级语言及语法描述 2.1 程序语言定义 主要从语法和语义两个方面进行定义。\n语法 通过词法规则和语法规则（产生规则）来形成合式程序。\n词法规则：单词符号的形成规则；使用正规式和有限自动机描述。\n语法规则：语法单位（表达式、语句、分程序、函数、过程、程序等）的形成；使用上下文无关文法描述。\n语义 通过语义规则翻译。基于属性文法的语法制导翻译方法（不是一种形式化系统）。\n2.2 高级语言特性 分类 强制性语言：命令驱动的、面向语句的\n应用式语言：通过已有函数构造更复杂的函数\n基于规则的语言：检查一定的条件，满足值则执行适当动作\n面向对象：封装、继承、多态\n数据类型 三要素：属性（类型、作用域）、值、操作\n初等数据类型：数值数据、逻辑数据、字符数据、指针类型；数据结构；抽象数据类型\n语句与控制结构 表达式：一个表达式是由运算量（操作数，即数据引用或函数调用）和算符组成。\n语句：赋值句、控制句、说明句、简单句和复合句。\n2.3 程序语言的语法描述 基本概念 定义$\\Sigma$为有穷子目标，元素为符号，$\\Sigma$上的符号串是指有$\\Sigma$中的符号构成的又穷序列。$\\varepsilon$为空字，不含符号。\n$\\Sigma^*$为所有符号串全体。\n定义连接为： 对于$U,V \\in \\Sigma^{*}，UV=\\{\\alpha\\beta,\\alpha \\in U \\\u0026amp; \\beta \\in V \\}$。则有：\n$$ V^0=\\{\\varepsilon\\} \\\\ V^*=V^0 \\cup V^1 \\cup V^2 \\cup \u0026hellip; \\\\ V^+=V^1 \\cup V^2 \\cup V^3 \\cup\u0026hellip; $$\n$V^*$为$V$的闭包（有限次连接），$V^+$为$V$的正则闭包，无空字$\\varepsilon$。\n上下文无关文法 文法：描述语言的语法结构和形成规则（语法规则），符号$G$。\n$G$：一组终结符号$V_T$，一组非终结符$V_N$，开始符号$S$，产生式$P$。\n终结符：不可分的基本符号；非终结符：语法范畴，如算术表达式，是集合；\n产生式：产生规则，如$A\\rightarrow\\alpha$，如果用 $::=$代替$\\rightarrow$则为巴科斯范式。\n$\\alpha A \\beta$直接推出$\\alpha \\gamma \\beta$：$\\alpha A\\beta \\Rightarrow \\alpha \\gamma \\beta$。\n存在$\\alpha_1$至$\\alpha_n$的推导：$\\require{extpfeil}\\Newextarrow{\\xRightarrow}{5,5}{0x21D2} \\alpha_1 \\xRightarrow{+} \\alpha_n$（一步或若干步，多步推导）；$\\require{extpfeil}\\Newextarrow{\\xRightarrow}{5,5}{0x21D2} \\alpha_1 \\xRightarrow{*} \\alpha_n$（零步或若干步，广义推导）。\n对于文法$G$和开始符号$S$，若$\\require{extpfeil}\\Newextarrow{\\xRightarrow}{5,5}{0x21D2} S \\xRightarrow{*} \\alpha$则$\\alpha$为一个句型，仅包含终结符的话则为句子，$G$产生的句子的全体称为语言，记为$L(G)$。\n$$ \\require{extpfeil}\\Newextarrow{\\xRightarrow}{5,5}{0x21D2} LG=\\{\\alpha | S \\xRightarrow{+} \\alpha \\\u0026amp; \\alpha \\in V_T^* \\} $$\n例如：\n考虑如下一个文法$G_1$所定义的语言。 $$ S \\rightarrow bA \\\\ A \\rightarrow aA|a $$ 从开始符号$S$开始，进行以下句子推导。 $$ S \\Rightarrow bA \\Rightarrow ba \\\\ S \\Rightarrow bA \\Rightarrow baA \\Rightarrow baa \\\\ \u0026hellip; \\\\ S \\Rightarrow bA \\Rightarrow baA \\Rightarrow \u0026hellip; \\Rightarrow ba \u0026hellip;a $$ 综上，$L(G_1)=\\{ba^n|n \\ge 1\\}$。\n推导不唯一，但为了进行结构的确定性分析，通常有最左推导和最右推导。\n语法分析树 文法能够唯一确定语言，但语言不能对应唯一一个文法。\n如果一个文法存在某个句子对应两颗不同的语法树，则称该文法是二义的，左右推导对语法树的形态影响相同，非二义性的情况下画出来的语法树是一样的。\n2.4 文法类别 0型文法 $ \\forall \\alpha \\rightarrow \\beta,\\alpha \\in (V_N \\cup V_T)^* $ 且至少存在一个非终结符，同时$\\beta \\in (V_N \\cup V_T)^* $。\n1型文法 即上下文有关文法，$\\alpha \\rightarrow \\beta$满足$|\\alpha|\\le|\\beta|$，其中$S \\rightarrow \\varepsilon$例外。\n2型文法 上下文无关文法，对于非终结符的替换无需考虑上下文。$A \\rightarrow \\beta, A \\in V_N, \\beta \\in (V_N \\cup V_T)^*$。\n3型文法 左右线性文法（正规文法）\n对于右线性文法，有:$A \\rightarrow \\alpha B | \\alpha, \\alpha \\in V_T^*, A,B \\in V_N^* $\n对于左线性文法，有:$A \\rightarrow B\\alpha | \\alpha, \\alpha \\in V_T^*, A,B \\in V_N^* $\n三、词法分析 3.1 概念 源程序通过词法分析得到单词符号串。\n单词符号：关键字、标识符、常数、运算符、界符。用 二元式（单词种别，单词符号的属性值） 表示。其中单词种别用整数编码。\n3.2 设计 输入预处理 去除编辑性字符（有些语言将空白符用作界符）\n输入预处理程序被调用时处理一串定长字符进入扫描缓冲区。然后分析器从中逐一识别单词符号。\n分析器扫描缓冲区时一般用：起点指示器、搜索指示器。\n扫描缓冲区被一分为二：如扫描指示器从单词起点处罚搜索到半区边缘但尚未到达单词终点，就调用预处理程序吧后续的一串字符装入另一半区。\n单词符号识别：超前搜索 关键字识别 考虑：DO66K=1,10和DO66K=1.10，前者为DO语句，后者为赋值语句，需要超前扫描许多字符直到能够确定词性。\n标识符识别 大多由字母开头的”字母/数字“串。\n常数识别 有些也需要进行超前搜索。\n算符与界符 有些需要进行复合，如++合成一个单词符号，需要进行超前搜索、。\n状态转换图 一张状态转换图包含有限个状态，一个为初态，至少一个终态\n单词符号有其种别编码和内码值，但不利于记忆，故使用一些特殊符号来表示种别编码，用$开头。\n状态转换图的实现 每个状态节点对应一小段程序即可。P44-P45。\n为了方便实现需要进行几点限制（可以不用超前搜素）：\n所有的关键字都是保留字，不得将其作为自定义的标识符； 当转换图识别到一个标识符时，就进行保留字表的查询，确定当前标识符是否为关键字； 关键字、标识符、常熟之间至少需要一个空白符作为间隔。 3.3 正规表达式和有限自动机 正规式和正规集 对于字母表$\\Sigma$，存在一个正规集，同时也使用正规式来表示正规集。递归定义如下：\n$\\varepsilon$和$\\phi$都是$\\Sigma$上的正规式，对应表示的正规集为$\\{\\varepsilon\\}$和$\\phi$。 任何$a \\in \\Sigma$都是$\\Sigma$上的正规式，对应表示的正规集为$\\{a\\}$。 假设$U$和$V$都是$\\Sigma$上的正规式，表示的正规集分别为$L(U)$和$L(V)$，那么以下都是正规式：$(U|V),(U·V),(U)^*$，对应的正规集为$L(U)\\cup L(V)、L(U)L(V)、(L(V))^*$。 只有经过有限次以上步骤得到的表达式才是$\\Sigma$上的正规式，仅由这些正规式所表示的字集才是$\\Sigma$上的正规集。\n若两个正规式表示的正规集相同，则认为二者等价，等价的正规式$U$和$V$记为$U=V$。如$b(ab)^*=(ba)^*b$。\n确定有限自动机(DFA) 一个确定有限自动机（DFA）M是一个五元式$M=(S,\\Sigma,\\delta,s_0,F)$。\n其中：\n$S$是一个有限集，每一个元素是一个状态。 $\\Sigma$是一个有穷子目标，每个元素是一个输入字符。 $\\delta$是一个映射。$\\delta(s,a)=s\u0026rsquo;$表示：当前状态为$s$，输入字符为$a$时，转换到下一个状态$s\u0026rsquo;$，称为$s$的一个后继状态。 $s_0 \\in S$是唯一的初态。 $F \\subseteq S$是一个可空的终态集。 DFA可以用一个矩阵来表示，称为状态转换矩阵，也对应一张确定的状态转换图。\n对于$\\Sigma^*$中的任何字$\\alpha$，若存在一条从初态节点到某一终态节点的通路，且这条通路上的所有弧的标记符连接成的字等于$\\alpha$，则称$\\alpha$可为DFA $M$所识别（或者读出、接受）。若$M$的初态节点同时又是终态节点，则空字$\\varepsilon$可为$M$所接受。DFA $M$所能识别的字的全体记为$L(M)$。\n如果一个DFA M的输入字母表为$\\Sigma$，我们也称$M$也是$\\Sigma$上的一个DFA。$\\Sigma$上的一个字集$V \\subseteq \\Sigma^*$是正规的，当且仅当存在$\\Sigma$上的DFA M，使得$V=L(M)$ 。\n该有限自动机的确定性体现在：对于任何状态和输入符号，都有唯一确定的下一个状态。\n非确定有限自动机（NFA） 一个非确定有限自动机（NFA）M是一个五元式$M=(S,\\Sigma,\\delta,S_0,F)$。\n其中：\n$S$是一个有限集，每一个元素是一个状态。 $\\Sigma$是一个有穷子目标，每个元素是一个输入字符。 $\\delta$是一个从$S\\times \\Sigma^*$到$S$的子集的映射。即$\\delta:S\\times \\Sigma^* \\rightarrow 2^S$。同一个字母可以出现在同状态射出的多条弧上（由某个状态，可由正规式、字符、字符串、空字转移到下一个状态）。 $S_0 \\in S$是不唯一的非空初态集。 $F \\subseteq S$是一个可空的终态集。 DFA是NFA的特例。但对于每一个NFA $M$存在一个DFA $M^n$，使得$L(M)=L(M^n)$ 。（感性理解：对于NFA，一个状态可以根据一个字符或者字符串来导出到其它状态，而DFA只能通过一个字符进行状态转移，那么进行多遍的DFA可以达到使用字符串导出其它状态的效果，即与NFA相同。）\n具体证明过程如下：\n假定$NFA\\ M = \u0026lt;S,\\Sigma,\\delta,S_0,F\u0026gt;$，进行以下状态图的修改：a）引入新的初态节点$X$和终态节点$Y$，$X,Y \\notin S$，从$X$到$S_0$ 中任意状态节点连一条$\\varepsilon$，从$F$中任意状态节点连一条$\\epsilon$到$Y$。b）分裂状态图直至每条弧上都是$\\varepsilon$或者$\\Sigma$中的单个字母。最终得到的NFA记为$M\u0026rsquo;$，很显然有$L(M\u0026rsquo;)=L(M)$。 将$M\u0026rsquo;$转换为DFA。a）定义$\\varepsilon$闭包为：假定$I$为$M\u0026rsquo;$的状态集的子集，则$I$的$\\varepsilon$闭包$\\varepsilon\\_ CLOSURE(I)$为从$I$中状态出发经过任意条$\\varepsilon$弧能够到达的状态节点的全体（可以是0步）。b）在以上定义的基础上，定义$I_a$为从$I$中状态出发，经过一条$a$弧以及任意条$\\varepsilon$弧所能到达的状态节点的全体。c）假定$\\Sigma = \\{ a_1,a_2,\u0026hellip;,a_k\\}$，构造一张表满足：首行首列为$\\varepsilon\\_ CLOSURE(X)$，其中$X$为初态节点，如某一行的第一列已经确定，将其记为$I$，则对于接下来的$i+1$列，依次求$I_{ai}$，检查其在表的第一列是否已经出现，如果未出现则将其填入第一列，循环往复，由于$M\u0026rsquo;$的状态子集的个数是有限的，以上过程会在有限步骤内停止。这张表就可与刻画出一个DFA，记为$M\u0026rsquo;\u0026rsquo;$，初态为首行首列的状态，且$L(M\u0026rsquo;\u0026rsquo;)=L(M\u0026rsquo;)=L(M)$。 P50 正规文法和有限自动机的等价性 对于正规文法$G$和有限自动机$M$，如果$L(G)=L(M)$，即$G$的语言和$M$所能识别的字的全体相等，则称$G$和$M$是等价的。相关结论：\n对于每一个右线性正规文法$G$或左线性正规文法$G$，都存在一个有限自动机$M$，使得$L(M)=L(G)$。FA的构造 对于每一个有限自动机$M$，都存在一个右线性正规文法$G_R$和左线性正规文法$G_L$，使得$L(M)=L(G_R)=L(G_L)$。正规文法的构造 证明（正规文法-\u0026gt;有限自动机）：\n设存在一个右线性正规文法$G=\u0026lt;V_T,V_N,S,P\u0026gt;$，将$V_N$中的每一个非终结符视作一个状态符号，并增加一个新的终结符号$f,f\\notin V_N$。可以构造有限自动机$M=\u0026lt;V_N \\cup \\{f\\},V_T,\\delta,S,\\{f\\}\u0026gt;$，其中$\\delta$进行以下构造：（a）若对某个$A\\in V_N$且$a\\in V_T \\cup \\{\\varepsilon\\}$，有产生式$A \\rightarrow a$，则$\\delta(A,a)=f$。（b）对任意的$A\\in V_N$且$a\\in V_T \\cup \\{\\epsilon\\}$，产生式左端为$A$，右端包含$A$，即$A\\rightarrow aA_1|\u0026hellip;|aA_k$，则$\\delta(A,a)=\\{A_1,\u0026hellip;A_k\\}$。【理解：在右线性的正规文法$G$中，对于推导$S \\xRightarrow{+} w$的最左推导中，每次利用$A\\rightarrow aB$进行一次推导就相当于从$A$经过标记为$a$的弧达到$B$，最左推导情况下左边的一系列终结符不会再进行划分了，$A\\rightarrow a$则表示状态$A$经过标记$a$得到最终状态。】 设存在一个左线性正规文法$G=\u0026lt;V_T,V_N,S,P\u0026gt;$，将$V_N$中的每一个非终结符视作一个状态符号，并增加一个新的初始状态符号$q_0,q_0 \\notin V_N$。可以构造有限自动机$M=\u0026lt;V_N\\cup\\{q_0\\},V_T,\\delta,q_0,\\{S\\}\u0026gt;$，其中$\\delta$进行以下构造：（a）对某个$A\\in V_N$且$a\\in V_T \\cup \\{\\varepsilon\\}$，有产生式$A\\rightarrow a$，则$\\delta(q_0,a)=A$。（b）对任意的$A\\in V_N$且$a\\in V_T \\cup \\{\\epsilon\\}$，产生式形式为：$A_1\\rightarrow Aa,\u0026hellip;,A_k \\rightarrow Aa$，则$\\delta(A,a)={A_1,\u0026hellip;A_k}$。【理解：NFA的推导从左往右，但左线性文法需要进行最右推导？观察表达式可知每次取左推导会导致非终结符仍然存在左侧，无法进行状态的描述，将整个过程反过来，尝试将开始符号作为NFA的终止状态，并添加起始状态，将整个推导过程反过来】 证明（有限自动机-\u0026gt;正规文法）：\n假设一个非确定自动机DFA $M=\u0026lt;S,\\Sigma,\\delta,s_0,F\u0026gt;$ 。（a）若$s_0 \\notin F$，令$G_R=\u0026lt;\\Sigma,S,s_0,p\u0026gt;$，其中$p$为：对任意$a\\in \\Sigma$以及$A,B \\in S$，若有$\\delta(A,a)=B$，则令$A\\rightarrow aB$（当$B\\notin F$时），$A\\rightarrow a|aB$（若$B \\in F$）。【理解：对于任意两个状态，将其放到右线性文法的最左推导中考虑】（b）若$s_0 \\in F$，则可以确定的是：因为$\\delta(s_0,\\varepsilon)=s_0$，则$\\varepsilon$为FA $M$所能识别的字，即$\\varepsilon \\in L(M)$，但显然$\\varepsilon$不属于$G_R$的语言，即$\\varepsilon \\notin L(G_R)$，但可以发现：$L(G_R)=L(M)-\\{\\varepsilon\\}$。故考虑添加一个语言，操作为：在上述的$G_R$中添加一个非终结符$s_0\u0026rsquo;（s_0\u0026rsquo; \\notin S）$和产生式$s_0\u0026rsquo; \\rightarrow s_0|\\varepsilon$，并使用$s_0\u0026rsquo;$作为开始符号。【理解：加一个看似无用的推导过程$s_0\u0026rsquo; \\rightarrow s_0|\\varepsilon$，使其在形式上满足DFA】 概括：\n有限自动机变正规文法：字母表$\\Sigma$设为终结符$V_T$，状态集$S$设为非终结符$V_N$，初态直接对应开始符号，对于产生式$P$，则：观察所有$\\delta$的边，若指向终态，则直接由起点状态产生弧上的字符，或者由起点状态产生（弧字符+终点状态），即右线性正规文法的写法（非终结符在右）；若指向非终态，则只有起点状态产生（弧字符+终点状态）。如果在自动机中，初态也在终态集中，那么设一个新的开始符号$s_0\u0026rsquo;$，并加一个产生式$s_0\u0026rsquo;\\rightarrow s_0|\\varepsilon$。 正规文法变有限自动机：加一个终态$f$，状态集则为文法中所有非终结符加上$f$，所有终结符作为字母表，开始符号作为初态，$\\{f}$为终态集，对于状态转移图$\\delta$，则：对于每一个产生式，若右侧没有非终结符了，直接左侧指向$f$，弧上字符为产生式的右侧字符，反之指向右侧的非终结符对应的状态。 正规式和有限自动机的等价性 对任何FA $M$，都存在一个正规式$r$，使得$L(r)=L(M)$，即$r$的正规集和$M$所能识别的字的全体相等。 对任何正规式$r$，都存在一个FA $M$，使得$L(M)=L(r)$。 证明（有限自动机-\u0026gt;正规式）\n在自动机$M$的转换图上加点$X$和$Y$，$X$通过$\\varepsilon$弧连接所有初态节点，$Y$通过$\\varepsilon$连接所有终态节点，新的NFA只有一个初态和一个终态，显然与原NFA是等价的。逐步消去新NFA的节点，依照以下过程。 证明（正规式-\u0026gt;有限自动机）\n对于正规式r，如果r中没有运算符，即满足：$r=\\varepsilon$或$r=\\phi$或$r=a,a\\in \\Sigma$。显然可以直接用FA来描述，如下图。 若r中含有k个运算符，则作以下操作。 确定有限自动机DFA的化简 定义状态$s$和$t$等价：从$s$出发能读出某个字$w$而停在终态，同样$t$出发也能读出同样的字$w$而停在终态，反之亦然。\n不等价则称两个状态是可区别的。\n对于DFA的化简，即将DFA的状态集划分为一系列不相交的子集，使得任意两个子集中的状态是可区别的，同一个子集内任两个状态都是等价的。最后选每个子集中的一个代表并消去其它。\n划分步骤：\n将状态集$S$的终态和非终态分开，分成两个子集以形成基本划分$\\Pi$。 设某个时刻$\\Pi = \\{I^{(1)},I^{(2)},\u0026hellip;I^{(m)}\\}$，且不同子集的状态是可区别的（但同一子集的状态可能等价，也可能不等价）。检查每个$I^{(i)}$能否再次进行划分，对于某个$I^{(i)}=\\{q_1,q_2,\u0026hellip;q_k\\}$，若存在一个字符$a\\in \\Sigma$，使得$I_a^{(i)}$不全包含在现在$\\Pi$中的某个子集中（也就是说走一步后的状态在不同子集中，即是可区别的，显然原集合的状态也是可区别的，因为走了一步$a$后可区别，加上这一步a也是可区别的状态），则根据走一步后的集合进行$I^{(i)}$的划分。 重复上述步骤，直到不存在可划分的状态集合。 举例：P57\n四、自上而下语法分析 4.1 存在问题 文法具有左递归性，则分析会进入无限循环； 回溯过程太多； 匹配成功可能是虚假的； 难以知道错误发生的位置 因此需要消除左递归、没有回溯、候选指派是正确的分析方法。即LL(1)分析法。\n4.2 LL(1)分析法 左递归的消除 假设关于非终结符$P$有以下规则： $$ P \\rightarrow P\\alpha|\\beta $$ 需要保证$\\beta$不以$P$开头，那么可以将$P$改写为以下形式： $$ P\\rightarrow \\beta P\u0026rsquo; \\\\ P\u0026rsquo;\\rightarrow \\alpha P\u0026rsquo; | \\varepsilon $$ 一般来说假定$P$的所有产生式有以下形式，且每个$\\alpha$都不等于$\\varepsilon$，每个$\\beta$都不以$P$开头。 $$ P\\rightarrow P\\alpha_1|P\\alpha_2|P\\alpha_3|\u0026hellip;|P\\alpha_m|\\beta_1|\\beta_2|\u0026hellip;|\\beta_n $$ 可以改写为： $$ P\\rightarrow \\beta_1 P\u0026rsquo; | \\beta_2 P\u0026rsquo; |\u0026hellip;|\\beta_n P\u0026rsquo; \\\\ P\u0026rsquo; \\rightarrow \\alpha_1 P\u0026rsquo; | \\alpha_2 P\u0026rsquo; |\u0026hellip;|\\alpha_m P\u0026rsquo; | \\varepsilon $$ 但仍然存在循环左递归的可能性，如以下文法 $$ S\\rightarrow Qc|c \\\\ Q\\rightarrow Rb|b \\\\ R\\rightarrow Sa|a $$ 存在$S\\Rightarrow Qc \\Rightarrow Rbc \\Rightarrow Sabc$，依然有左递归结构。\n有以下算法，需要保证文法不含回路，即从$P$推到$P$，也不含以$\\varepsilon$为右部的产生式：\n将文法中所有非终结符按照一种顺序进行排列，如$P_1,P_2,\u0026hellip;,P_n$ 对于任意一个$P_i$，如果有$P_i\\rightarrow P_j \\gamma$的形式，其中$P_j$是在$P_i$前面的非终结符，将其改写为：$P_i \\rightarrow \\delta_1 \\gamma|\\delta_2 \\gamma|\u0026hellip;|\\delta_k \\gamma$，其中$P_j\\rightarrow \\delta_1|\\delta_2|\u0026hellip;|\\delta_k$。 重复上述步骤 消除回溯 思想：对任意一个非终结符，当要其取匹配输入串时，可以根据当前符号准确地指派它的一个候选取执行任务，即如果当前非终结符为$A$，且$A\\rightarrow \\alpha_1|\\alpha_2|\u0026hellip;|\\alpha_n$，面临输入符号$a$时，能够指派一个$\\alpha_i$作为全权代表去执行任务，无需回溯。\n引入FIRST集，定义每个候选$\\alpha$的终结首符集$FIRST(\\alpha)$为： $$ FIRST(\\alpha)=\\{a|\\alpha \\Rightarrow a\u0026hellip;,a\\in V_T\\} $$ 其中可能包含$\\varepsilon$，即$FIRST(\\alpha)$是所有可能推导的开头终结符或者可能的$\\varepsilon$。\n如果非终结符$A$的所有候选首符集两两不相交，则就可以准确地指派某个候选去执行任务，该候选的FIRST集中包含当前的输入符号。\n提取公共左因子 考虑到所有候选的FIRST集并非两两不相交，可以经过反复提取左因子，但这可能引入大量的新的非终结符和$\\varepsilon$。\n例如以下产生式，其中每个$\\gamma$不以$\\delta$开头。 $$ A\\rightarrow \\delta \\beta_1 |\\delta \\beta_2|\u0026hellip;|\\delta \\beta_n|\\gamma_1|\\gamma_2|\u0026hellip;|\\gamma_m $$ 则可以改写为以下形式，即把公共的$\\delta$提出来。 $$ A\\rightarrow \\delta A\u0026rsquo;|\\gamma_1|\\gamma_2|\u0026hellip;|\\gamma_m \\\\ A\u0026rsquo; \\rightarrow \\beta_1 | \\beta_2 |\u0026hellip; | \\beta_n $$\n自动匹配 非终结符$A$面临输入符号$a$时，当$a$不属于任意候选的FIRST集的时候，但某个候选的FIRST集包含$\\varepsilon$时，当且仅当$a\\in FOLLOW(A)$时，A才能够自动匹配。 $$ FOLLOW(A)=\\{a|S\\Rightarrow \u0026hellip;Aa\u0026hellip;,a\\in V_T\\} $$ 即$FOLLOW$集代表从开始符号进行推导，所有句型中紧接在$A$后面的终结符或者#（符号串的结尾）。\nLL(1)分析条件 文法不含左递归 对于每一个非终结符$A$的各个产生式的候选FIRST集两两不相交。 对于每一个非终结符$A$，若存在某个候选的FIRST集包含$\\varepsilon$，则$FIRST(A)\\cap FOLLOW(A)=\\phi$。 以上为LL(1)文法。\n4.3 预测分析程序 程序执行步骤 使用一张分析表和一个栈进行联合控制。\n栈存放文法符号，开始的时候在栈底先放一个#，然后放进文法开始符号。假定输入串最后也有一个#。 在任何时候，取出栈顶符号$X$和当前的输入符号$a$。进行以下三种可能的动作。 若$X=a=\u0026rsquo;\\#\u0026rsquo;$，则宣布分析成功，停止分析； 若$X=a\\ne \u0026lsquo;\\#\u0026rsquo;$，把$X$从栈顶取出，$a$指向下一个输入符号； 若$X$为一个非终结符，查看分析表$M$，若$M[A,a]$中存放关于$X$的一个产生式，则将$X$弹出栈，将产生式右边的符号按反序进行压栈；若为$\\varepsilon$则不进行压栈；若有出错标志则调用ERROR。 预测分析表M的构造需要构造与文法有关的FIRST集和FOLLOW集。\nFIRST集的构造 首先对所有文法符号$X\\in V_T \\cup V_N$构造$FIRST(X)$。\n若$X\\in V_T$，则$FIRST(X)=\\{X\\}$； 若$X\\in V_S$，且有产生式$X\\rightarrow a\u0026hellip;$，则把$a$加入到$FIRST(X)$，若$X\\rightarrow \\varepsilon$也是一条产生式，把$\\varepsilon$也加入到FIRST集中； 若$X\\rightarrow Y$是一个产生式且$Y\\in V_N$，则把$FIRST(Y)$中的所有非$\\varepsilon$元素加到$FIRST(X)$中； 若$X\\rightarrow Y_1Y_2\u0026hellip;Y_k$是一个产生式，且$Y_1,\u0026hellip;,Y_{i-1}$都是非终结符，对于任何$1\\le j\\le i-1$，$FIRST(Y_j)$都含有$\\varepsilon$，即$Y_1\u0026hellip;Y_{i-1}\\Rightarrow \\varepsilon$，则把$FIRST(Y_i)$中的所有非$\\varepsilon$加入到$FIRST(X)$中，若所有的$FIRST(Y)$都含有$\\varepsilon$，则把$\\varepsilon$加入到$FIRST(X)$中。 对任意符号串$\\alpha=X_1X_2\u0026hellip;X_n$构造$FIRST(\\alpha)$。首先令$FIRST(\\alpha)=FIRST(X_1) \\setminus \\{\\varepsilon\\}$；如果对于任何$1\\le j \\le i-1,\\varepsilon \\in FIRST(X_j)$，则把$FIRST(X_i)$加入$FIRST(\\alpha)$，但不包括 $\\varepsilon$，如果所有$FIRST(X_i)$都含有$\\varepsilon$，则将其也加入到$FIRST(\\alpha)$中。 FOLLOW集的构造 对于开始符号$S$，将#置于$FOLLOW(S)$中； 若$A\\rightarrow \\alpha B \\beta$是一个产生式，则把$FIRST(\\beta) \\setminus \\{\\varepsilon\\}$加入到$FOLLOW(B)$中； 若$A\\rightarrow \\alpha B$是一个产生式，或$A\\rightarrow \\alpha B \\beta$是一个产生式且$\\beta \\Rightarrow \\varepsilon$，即$\\varepsilon \\in FIRST(\\beta)$，则把$FOLLOW(A)$加入到$FOLLOW(B)$中。 预测分析表M的构造 对于每一个产生式$A\\rightarrow \\alpha$，进行操作：对于每个终结符$a\\in FIRST(\\alpha)$，把$A\\rightarrow \\alpha$添加到$M[A,a]$中；若$\\varepsilon \\in FIRST(\\alpha)$，则对任何$b\\in FOLLOW(A)$，将$A\\rightarrow \\alpha$添加到$M[A,b]$中； 将无定义的$M[A,a]$标记上出错。 4.4 出错处理 出错情况 栈顶的终结符和输入的符号不匹配； 非终结符$A$处于栈顶，当前输入符号为$a$，但分析表中$M[A,a]$为空。 处理方法 常用的处理方法为，跳过输入串中的符号直至遇到“同步符号”。对于同步符号的选择：\n对于非终结符$A$，$FOLLOW(A)$作为同步符号集；跳过一些输入符号直到出现$FOLLOW(A)$中的符号；但也不够，例如缺少分号的情况，这会导致下一个语句的开头不在前一句的最后字符的$FOLLOW$集中，使得下一语句的开头也会被跳过。 把$FIRST(A)$作为同步符号，则遇到$FIRST(A)$中的元素则可以根据$A$恢复语法分析。 五、自下而上语法分析 5.1 基本问题 归约 对于“可归约串”的刻画，再算符优先分析中，使用“最素左短语”来刻画，再“规范规约”分析中，使用“句柄”。\n中心问题：怎么判断符号栈顶的符号串的可归约性，以及如何规归约。\n规范归约 短语：令$G$是一个文法，$S$是文法的开始符号，假定$\\alpha \\beta \\delta$是文法$G$的一个句型，如果$S$能够经过广义推导到$\\alpha A \\delta$，同时$A$可以通过大于等于1步的推导得到$\\beta$，则称$\\beta$是句型$\\alpha \\beta \\delta$相对于非终结符$A$的短语。\n直接短语：如果$A$仅仅通过一步推导就能得到$\\beta$，则该$\\beta$则为直接短语。\n句柄：最左直接短语。\n【对于一个句型的语法树，以任意非叶子为根的子树，其叶子节点则为短语，直接短语则子树深度为1】\n规范归约：从$\\alpha$开始，到开始符$S$结束，每次都是把句柄替换为产生式的左部符号。也就是最左归约。是最右推导的逆过程，最右推导常被称为规范推导，得到的句型叫做规范句型。\n如果文法无二义性，则最右推导的逆过程必定是最左归约。（或者说规范推导和规范归约）\n相关特性 句柄具有”最左“特性，对于规范句型来说，句柄的后面不会出现非终结符。\n使用符号栈和语法树的分析过程 从左至右把输入串$w$的符号移到符号栈里，一旦发现栈顶形成一个可归约串，就进行替换，这种替换可能持续多次。\n对符号栈的四类操作：移进、归约、接收、出错处理。\n移进是将输入串的一个符号移入栈，接收指宣布最终分析成功。\n5.2 算符优先分析 算符优先分析法不是一种规范归约法（不一定是严格的最左归约）\n定义终结符之间的某种优先关系，以寻找”可归约串“。\n算符优先文法 一个文法如果它的任一产生式的右部都不含两个并列的非终结符，则称为算符文法。\n假定$G$是一个不含$\\varepsilon$产生式的算符文法，对于任何一对终结符$a,b$，有以下定义\n$a=b$，当且仅当有$P\\rightarrow \u0026hellip;ab\u0026hellip;$或者$P\\rightarrow \u0026hellip;aQb\u0026hellip;$的产生式； $a \u0026lt; b$，当且仅当有形如$P\\rightarrow \u0026hellip;aR\u0026hellip;$的产生式，且$R$能够通过大于等于1步推导得到$b\u0026hellip;$或者$Qb\u0026hellip;$ $a\u0026gt;b$，当且仅当有形如$P\\rightarrow \u0026hellip;Rb\u0026hellip;$的产生式，且$R$能够通过大于等于1步推导得到$\u0026hellip;b$或者$\u0026hellip;Qb$ 则称$G$是一个算符优先文法。\n终结符对的优先关系表则是对任意两个终结符之间的关系描述。\n由于需要找到所有终结符对的关系，考虑对每个非终结符$P$构造两个集合$FIRSTVT(P)$和$LASTVT(P)$。 $$ FIRSTVT(P) = \\{a|P\\xRightarrow{+}a\u0026hellip;或P\\xRightarrow{+}Qa\u0026hellip;,a\\in V_T,Q\\in V_N\\} \\\\ LASTVT(P) = \\{a|P\\xRightarrow{+}\u0026hellip;a或P\\xRightarrow{+}\u0026hellip;aQ,a\\in V_T,Q\\in V_N\\} $$ 有$\u0026hellip;aP\u0026hellip;$的候选，则对于任意$b\\in FIRSTVT(P)$，都有$a\u0026lt;b$。\n有$\u0026hellip;Pb\u0026hellip;$的候选，则对于任意$a\\in LASTVT(P)$，都有$a\u0026gt;b$。\n两个集合的构造方法 对于$FIRSTVT(P)$，规则如下：\n如果有产生式$P\\rightarrow a\u0026hellip;$或者$P\\rightarrow Qa\u0026hellip;$，则$a\\in FIRSTVT(P)$ 。 若$a\\in FIRSTVT(Q)$，且有产生式$P\\rightarrow Q\u0026hellip;$，则$a\\in FIRSTVT(P)$。 对于$LASTVT(P)$，规则如下：\n如果有产生式$P\\rightarrow \u0026hellip;a$或者$P\\rightarrow \u0026hellip;Qa$，则$a\\in LASTVT(P)$ 。 若$a\\in LAST VT(Q)$，且有产生式$P\\rightarrow \u0026hellip;Q$，则$a\\in LASTVT(P)$。 算符优先分析算法 最素左短语：一个短语，它至少含有一个终结符，除它自身之外没有更小的素短语。\n一个算符优先文法$G$的任何句型的最左素短语是满足如下条件的最左子串$N_ja_j\u0026hellip;N_ia_iN_{i+1}$，满足$a_{j-1}\u0026lt;a_{j},a_{j}=a_{j+1},\u0026hellip;,a_{i-1}=a_{i},a_{j}\u0026gt;a_{i+1}$。\n算法伪代码P93。【在\u0026lt;或者=的时候输入，在\u0026gt;的时候归约】\n优先函数 若$\\theta_1 \u0026lt; \\theta_2$，则$f(\\theta_1) \u0026lt; g(\\theta_2)$，其余符号同理。\n构造一个优先函数可以进行以下操作：\n对于每个终结符（包括#）画一张以所有符号$f_a$和$g_a$为节点的方向图，如果$a\u0026gt;=b$，那么就从$f_a$画一条箭弧到$g_b$，如果$a\u0026lt;=b$，那么就从$g_b$画一条到$f_a$的箭弧 对每个节点进行赋值，数值大小为从该节点出发能够到达的节点个数（包括自身） 检查矛盾。 5.3 LR分析法 LR分析器 规范归约（最左归约-最右推导的逆过程）的关键问题在于寻找句柄。\n一个LR分析器实质上是一个带有符号栈的DFA，每一步的工作都是由栈顶状态和现行输入符号所唯一决定的。\n栈的每一项内容包含状态$s$和文法符号$X$两部分。\nLR分析器的核心部分是一张分析表，一是ACTION表，另一是GOTO表。$ACTION[s,a]$规定了状态$s$在面临输入符号$a$时应该采取的动作，$GOTO[s,X]$规定了在状态$s$下面对文法符号$X$时的下一状态是什么。\nLR分析器的工作过程可以看成是栈里的状态序列、已归约串和输入串所构成的三元式的变化过程。分析开始时初始的三元式为$(s_0, \\#,a_1a_2\u0026hellip;a_n\\#)$。\n分析过程每步的结果可以表示为$(s_0s_1\u0026hellip;s_m, \\#X_1X_2\u0026hellip;X_m, a_ia_{i+1}\u0026hellip;a_{n}\\#)$，分析器的下一步动作是由栈顶状态$s_m$和现行输入符号$a_i$所唯一决定的，即执行$ACTION[s_m,a_i]$所规定的动作。三元式的变化情形是：\n若$ACTION[s_m,a_i]$ 为移进(s)，且$s=ACTION[s_m,a_i]$ ,三元式变为$(s_0s_1\u0026hellip;s_ms, \\#X_1X_2\u0026hellip;X_ma_i, a_{i+1}\u0026hellip;a_{n}\\#)$ 若$ACTION[s_m,a_i]={A\\rightarrow \\beta}$，则按照$A\\rightarrow \\beta$进行归约，此时三元式变为$(s_0s_1\u0026hellip;s_{m-r}s, \\#X_1X_2\u0026hellip;X_{m-r}A, a_ia_{i+1}\u0026hellip;a_{n}\\#)$，此时的$s=GOTO[s_{m-r},A]$，$r$为$\\beta$ 的长度，$\\beta = X_{m-r+1}\u0026hellip;X_m$ 。 若$ACTION[s_m,a_i]=acc$，分析成功。 LR文法 对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则我们将把这个文法称为LR文法，当分析器对输入串进行从左至右扫描时，一旦句柄呈现在栈顶，就能够及时对它进行归约。\n一个LR分析器有时候需要”展望“和实际检查未来的k个输入符号才能确定采取什么样的策略，如果检查k个输入符号，则称为$LR(k)$文法。大多数小于等于1。LR文法是无二义的。\nLR(0)项目集族和LR(0)分析表的构造 前缀：字的任意首部。\n活前缀：这个前缀不含句柄之后的任何符号。在LR分析工作过程中，应该保证栈里的文法符号构成活前缀。只要将已扫描的部分保持可归约成一个活前缀，那么意味着扫描没有错误。\n因此可以考虑对于一个文法$G$构造一个能识别所有活前缀的DFA，并在此基础上将DFA转化为LR分析表。\n对于FA的状态，将其定义成”项目“。文法$G$的每一个产生式右部添加一个圆点称为$G$的一个$LR(0)$项目。例如$A\\rightarrow XY$对应的项目有：$A\\rightarrow·XY,A\\rightarrow X·Y,A\\rightarrow XY·$。产生式$A\\rightarrow \\varepsilon$对应一个项目$A\\rightarrow ·$。\n常规方法下的FA构造 为每个项目进行标号，规定项目1是NFA的唯一初态。\n如果状态i和状态j出自同一产生式，且状态j的圆点只落后于状态i的圆点一个位置，则从状态i画一条到j的弧，标志则为圆点跨过的符号。如果该符号是非终结符，则从状态i画一条$\\varepsilon$弧到所有$A\\rightarrow ·\\gamma$状态（圆点在最左侧的项目）\n然后对上述NFA进行确定化即可得到DFA。\n构成识别一个文法或前缀的DFA的项目集的全体称为这个文法的$LR(0)$项目集规范族。\n归约项目：$A\\rightarrow \\alpha·$ ，对于开始符号$S\u0026rsquo;$ 的规约项目，称为接收项目\n移进项目：$A\\rightarrow \\alpha ·a\\beta$，其中a为终结符，如果a为非终结符，则为”待约“项目。\nLR(0)项目集规范族的构造 这种方法直接能够产出DFA。\n拓广文法：添加一个新的产生式，右侧为开始符号$S$：$S\u0026rsquo;\\rightarrow S$，这样就只有一个唯一的”接受态“，包含项目$S\u0026rsquo;\\rightarrow S·$。\nCLOSURE(I)闭包 对于项目集$I$，构造其闭包过程如下：\n$I$的任何项目都属于$CLOSURE(I)$； 若$A\\rightarrow \\alpha ·B \\beta$输入$CLOSURE(I)$，那么对于任何关于$B$的产生式$B\\rightarrow \\gamma$，项目$B\\rightarrow ·\\gamma $也属于闭包。 【保证项目集$I$中的各个项目是”等价“的，不用再进行化简】\n函数GO 定义$GO(I,X)$为$CLOSURE(J)$，其中$J$则为从$I$中的某个项目出发经过一次$X$能够到达的项目集。\n【从$I$出发，经过$X$，能够到达$J$的闭包，如果$I$是对于某个活前缀$\\gamma$有效的项目集，那么$GO(I,X)$就是对$\\gamma X$有效的项目集】\n有效项目 项目$A\\rightarrow \\beta_1·\\beta_2$对于活前缀$\\alpha \\beta_1$是有效的，其条件是存在规范推导$S\u0026rsquo;\\xRightarrow{*}\\alpha A \\omega \\Rightarrow \\alpha \\beta_1 \\beta_2 \\omega$。\n总结 就是通过一个文法推导出对应的$DFA$，每个状态为一个项目集$I_m$，步骤如下：\n修改为拓广文法； 从$I_0$开始，即包含$S\u0026rsquo; \\rightarrow ·S$的项目集，同时包含所有的$S\\rightarrow ·\\gamma$，即$I_0$需要处理为闭包。 对于各个符号，通过箭弧指向另外的项目集，同步移进圆点，如果存在圆点后存在非终结符的都需要进行闭包的处理。 重复上述步骤得到DFA。 LR(0)分析表的构造 一个文法$G$为$LR(0)$文法的条件为，对于其拓广文法的活前缀自动机中的每个项目集（状态），都不存在以下情况：1. 既含有移进项目又含有归约项目（移进-归约矛盾）；2. 含有多个归约项目（归约-归约矛盾）\n（下面使用$GO(I_k,X)=I_j$来描述从$k$到$j$有一条连边，且标志为$X$）\n步骤如下：\n若项目$A\\rightarrow \\alpha ·a\\beta$属于$I_k$，且$GO(I_k,a)=I_j$，$a$为终结符，则$ACTION[k,a]$为\u0026quot;把(j,a)移进栈，即为$s_j$\u0026quot; 若项目$A\\rightarrow \\alpha ·$属于$I_k$，对于任意终结符或者结束符，置$ACTION[k,a]$为”用产生式$A\\rightarrow \\alpha$进行归约，即为$r_j$，其中$j$为第$j$个产生式“（由于不存在归约-归约矛盾，故满足此条件的项目集中只会有一个项目） 若项目$S\u0026rsquo;\\rightarrow S·$属于$I_k$，则$ACTION[k,\\#]=acc$ 若$GO(I_k,A)=I_j$且$A$为非终结符，则置$GOTO[k,A]=j$。 简述 对于DFA中的连边，如果弧上标志为终结符，则设置ACTION表移进，从$i$到$j$，则记$s_j$；如果是非终结符，则设置GOTO表；如果只有一个归约项目，则把那一行(对应的状态)全部填为$r_j$；如果是接受项目，则直接在$\\#$ 除填入acc。\nSLR分析表的构造 概念 对于LR(0)每个项目集中无冲突，但如果存在冲突，即有多个归约项目，或者归约项目和移进项目同时出现，可以通过$SLR(1)$解决方法进行解决。\nSLR(1)解决方法 例如以下项目集$I={X\\rightarrow \\alpha·b\\beta, A\\rightarrow \\alpha·,B\\rightarrow \\alpha·}$，第一个是移进项目，希望将$b$进行移进，第二、三个为归约项目，希望将栈顶的$\\alpha$归约为$A$或$B$，因此存在冲突。\n有以下决策，当面临输入符号$a$时：\n若$a$和某一移进项目期待的非终结符$b$相同时，则进行移进；\n若$a\\in FOLLOW(A)$，则使用产生式$A\\rightarrow \\alpha$进行归约，即寻找$FOLLOW$即存在当前输入符号的进行归约；\n有其他情况就报错；\n这就要求$a$接下来的匹配项不能存在多种可能，即期待的非终结符$b$是不重复的，包括$FOLLOW$集是不重复的，形式化的表达即为：\n！如果有$m$个移进项目：$A_1\\rightarrow \\alpha·a_1\\beta_1,A_2\\rightarrow \\alpha·a_2\\beta_2,\u0026hellip;,A_m\\rightarrow \\alpha·a_m\\beta_m$，同时有$n$个归约项目：$B_1\\rightarrow \\alpha·,B_2\\rightarrow \\alpha·,\u0026hellip;,B_n\\rightarrow \\alpha·$，集合$\\{a_1,a_2,\u0026hellip;a_m\\},FOLLOW(B_1),\u0026hellip;,FOLLOW(B_n)$两两不相交，就可以实现在冲突存在的情况下，输入符号$a$根据上述的某一选择进行后续操作。\n满足上述条件的则为$SLR(1)$文法。\nSLR(1)表的构造 其余保持不变，对于所有归约项目$A\\rightarrow \\alpha ·$，检查$FOLLOW(A)$中的所有元素$a$，置$ACTION[k,a]$为用产生式$A\\rightarrow \\alpha$进行归约，即为$r_j$。\n规范LR分析表的构造 概念 重新定义项目，使得每个项目带有$k$个终结符，称为$LR(k)$项目，形如$[A\\rightarrow \\alpha ·\\beta, a_1a_2\u0026hellip;a_k]$，其中$a_1a_2\u0026hellip;a_k$称为向前搜索符串。向前搜索符串仅对规约项目$[A\\rightarrow \\alpha ·,a_1a_2\u0026hellip;a_k]$有意义，即：当所属状态呈现于栈顶并且后续的$k$个输入符号为$a_1a_2..a_k$时，才考虑将$\\alpha$归约为$A$。\nLR(1)的项目集闭包 若项目$[A\\rightarrow · B\\beta,a]$属于$CLOSURE(I)$，且$B\\rightarrow \\xi$是一个产生式，对于$FIRST(\\beta a)$中的每个终结符$b$，如果$[B\\rightarrow ·\\xi,b]$不在$CLOSURE(I)$中，就加入。\n【即如果项目为$[A\\rightarrow ·B,a]$，则$[B\\rightarrow ·\\gamma,a]$属于该项目集，如果$[A\\rightarrow ·B\\beta,a]$，$\\beta \\ne \\varepsilon$，则$[B\\rightarrow ·\\gamma,FIRST(\\beta)]$属于该项目集】\nLR(1)的分析表构造 其余保持不变，对于归约项目，根据前向搜索字符进行填写，如项目$[A\\rightarrow\\alpha ·,a]$属于$I_k$，则置$ACTION[k,a]$为“使用产生式$A\\rightarrow \\alpha$归约”，记为$r_j$。\n"},{"section":"Blog","slug":"/en/blog/labrecordtextclassification/","title":"【实验记录】Tianchi-新闻文本多分类任务","description":"this is meta description","date":"February 13, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/bert/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/bert\\/image-2_hu87100aa94ecaa21de31e7ce641853097_114162_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 实验记录","tags":"自然语言处理, 文本分类","content":"【实验记录】Tianchi-新闻文本分类 赛题内容 简介 文本分类\n数据 text-label，训练集共20w条样本。\n其中text经过字符级别的匿名处理，label从0到13。\n评价指标 使用F1_Score，调用sklearn.metrics中的f1_score可以完成计算。 $$ F1 = 2 \\times \\frac{(precision * recall) }{(precision + recall)} $$\n简要分析 文本长度 计算每一个样本的文本长度length。\ndf = train_df df[\u0026#39;length\u0026#39;] = df[\u0026#39;text\u0026#39;].apply(lambda s : len(s.split(\u0026#39; \u0026#39;))) df[\u0026#39;length\u0026#39;].describe() 结果如下，平均长度907个字符。\ncount,200000.000000 mean,907.207110 std,996.029036 min,2.000000 25%,374.000000 50%,676.000000 75%,1131.000000 max,57921.000000 词频分析 取所有出现的词统计其次数（Counter实现）。\nall_lines = \u0026#39; \u0026#39;.join(list(df[\u0026#39;text\u0026#39;])) word_cnt = Counter(all_lines.split(\u0026#39; \u0026#39;)) word_cnt = sorted(word_cnt.items(), key = lambda x: x[1], reverse=True) print(\u0026#39;total word num:{}\u0026#39;.format(len(word_cnt))) print(\u0026#39;max word:{}, times:{}\u0026#39;.format(word_cnt[0][0], word_cnt[0][1])) print(\u0026#39;min word:{}, times:{}\u0026#39;.format(word_cnt[-1][0], word_cnt[-1][1])) 取10000个样本进行计算，结果如下，出现次数最多的词为3750，猜测为空格？\ntotal word num:5340 max word:3750, times:373091 min word:6577, times:1 标签类别 取所有标签的数量，分析占比。\nlabel_record = dict() labels = df[\u0026#39;label\u0026#39;] for label in labels: if label not in label_record: label_record.setdefault(label, 1) else: label_record[label] += 1 df_length = len(labels) print(\u0026#39;num:{}\u0026#39;.format(df_length)) for node in label_record.keys(): print(\u0026#39;label:{}, rate:{}\u0026#39;.format(node, label_record.get(node)/df_length)) 取10000个样本，结果如下，分类目标分布不均匀。\nnum:10000 label:2, rate:0.1561 label:11, rate:0.0164 label:3, rate:0.1078 label:9, rate:0.031 label:10, rate:0.0242 label:12, rate:0.0088 label:0, rate:0.1885 label:7, rate:0.0426 label:4, rate:0.0788 label:1, rate:0.1866 label:6, rate:0.0505 label:5, rate:0.0619 label:8, rate:0.0415 label:13, rate:0.0053 解决方法 特征提取+ML分类 WordVec取词向量+DL分类 FastText BERT词向量 Method1：TF-IDF+RidgeClassifier TF-IDF TF为词频，等于：某个词在文章中出现的次数/文章中词的总数\nIDF为逆文档频率，等于：log(语料库文档总数/包含该词的文档数目+1)\nTF-IDF：$TF\\times IDF$\n一个词在文档中出现的次数越多，TF-IDF越大，该词在整个语料库中出现越多，TF-IDF越小，相当于某个词能够代表某一个文章的能力（在文章中的重要程度）。\n代码 TF-IDF的提取使用TfidfVectorizer实现。将每个样本使用2000个特征进行描述。\ntfidf = TfidfVectorizer(max_features=2000).fit(train_df[\u0026#39;text\u0026#39;].values) train_tfidf = tfidf.transform(train_df[\u0026#39;text\u0026#39;].values) #(200000,2000) 对测试集也进行转换操作。\ntest_tfidf=tfidf.transform(test_df[\u0026#39;text\u0026#39;].values) 设置岭回归分类器并进行分类器的训练。\nclf=RidgeClassifier() clf.fit(train_tfidf,train_df[\u0026#39;label\u0026#39;].values) 在训练集上测试得分。结果为：\npred = clf.predict(train_tfidf) print(f1_score(train_df[\u0026#39;label\u0026#39;].values, pred, average=\u0026#39;macro\u0026#39;)) 计算答案并导出。\nresult = pd.DataFrame() result[\u0026#39;label\u0026#39;]=clf.predict(test_tfidf) result.to_csv(\u0026#39;submit.csv\u0026#39;,index=None) 结果 score: 0.8784\nMethod2：FastText Word2Vec 找到词汇与该词相邻词向量的关系，对出现在上下文环境里的词进行预测。对于每一条输入文本，选取一个上下文窗口和一个中心词，并基于这个中心词去预测窗口里其他词出现的概率。有两种方式：CBOW和Skip-Gram。\nSkip-Gram模型：\n考虑通过中心词生成上下文词的条件概率，有一个上下文窗口。表达式如下，其中$u$和$v$都代表各词所对应的词向量。\n$$ P(w_o|w_c)=\\frac{exp(u_o^T v_c)}{\\sum_{i\\in V} exp(u_i^T v_c)} $$\n那么对于上下文窗口为$m$的情况，似然函数就可以写成在给定任意中心词的情况下生成所有上下文词的概率，表达式为：\n$$ \\prod_{i=1}^{T} \\prod_{-m\\le j \\le m, j\\ne 0} P(w^{(t+j)}|w^{(t)}) $$\nCBOW模型：\n考虑通过上下文词生成中心词的条件概率。似然函数如下：\n$$ \\prod_{i=1}^{T} P(w^{(t)}|w^{(t-m)},\u0026hellip;,w^{(t-1)},w^{(t+1)},\u0026hellip;,w^{(t+m)}) $$\nFastText 通过Embedding层将单词映射到稠密空间，然后将句子中所有的单词在Embedding空间中进行平均，进而完成分类操作。\nMethod3：基于BERT的文本分类 思路 微调BERT，取CLS的Token向量作为句子表征，过全连接层得到分类结果。由于文字都已经进行了匿名处理，无法用一些已经预训练的模型参数，可以使用官方提供的Bert_mini\n训练细节 结果 "},{"section":"Blog","slug":"/en/blog/lossfunction/","title":"【泛学内容】损失函数相关","description":"this is meta description","date":"January 14, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/lossfunction/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"247\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/lossfunction\\/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/lossfunction/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/lossfunction\\/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 泛学内容","tags":"损失函数, 实验记录, 图像分割","content":"损失函数Loss Function 一、回归任务常用Loss 1. L1 Loss 原理 即为平均绝对值误差MAE，主要用于简单的回归问题，指模型预测值与真实值之间的绝对差值的平均值。\n表达式 $$ MAE=\\frac{1}{n}\\sum_{i=1}^{n}|f(x_i)-y_i| $$\n代码 criterion = nn.L1Loss() loss = criterion(target, pred) 2. MSE Loss 原理 均方误差损失函数MSE，指模型预测值与真实值之间的差的平方的平均值。\n表达式 $$ MSE=\\frac{1}{n}\\sum_{i=1}^{n}(f(x_i)-y_i)^2 $$\n代码 criterion = nn.MSELoss() loss = criterion(target, pred) 备注 reduce参数取值：\nnone：维度不缩减，返回相同shape的结果，每个位置均为对应元素差值的平方\nmean：默认值，所有位置的损失取平均\nsum：所有位置的损失求和但不取平均\n与L2Loss的关系：\n在大多数情况下是同一个概念，但严格来说L2Loss对平方和求得结果后会进一步求平方根。\n二、分类任务常用Loss 1. NLLLoss 原理 即为负对数似然函数，常用于多分类。取对应位置的数值进行相加即可，最后取负值。\n表达式 $$ Loss=-\\sum_iy_if(x_i) $$\n代码 criterion = nn.NLLLoss() loss = criterion(target, pred) 备注 这里的target可以传入索引，Pytorch实现的函数内进行了one-hot\n对于pred的内容需要进行softmax+log操作\n2. BCELoss 原理 即为二值交叉熵损失，适用于0/1的二值分类，模型输出一个概率值，即为预测为正例的概率。\n表达式 $$ BCE = -\\frac{1}{n}\\sum_i(y_i.log(f(x_i))+(1-y_i).log(1-f(x_i))) $$\n代码 criterion = nn.BCELoss() loss = criterion(target, pred) 3. CrossEntropyLoss 原理 即为交叉熵损失，适用于多分类问题\n表达式 $$ Loss=-\\sum_iy_ilog(f(x_i)) $$\n代码 criterion = nn.CrossEntropyLoss() loss = criterion(target, pred) 备注 nn.CrossEntropyLoss()结合了nn.LogSoftmax()和nn.NLLLoss()函数，前者经过softmax后取对数。\n其中target是真实标签，每个元素的值是样本所属类别的索引值\n形式上与负对数似然损失类似，但负对数似然函数是基于极大似然估计的概率方法，但交叉熵是信息论种将两个概率分布进行差异性分析的方式，本质有所差别。\n4. Dice 原理 Dice Loss由Dice系数而来，Dice系数是用来描述两个样本相似性的函数，值越大则越相似，那么对应的Loss就可以是1-Dice系数。\n表达式 $$ DiceLoss=1-\\frac{2|X \\cap Y}{|X|+|Y|} $$\n代码 class DiceLoss(nn.Module): def __init__(self): super().__init__() self.epsilon = 1e-5 def forward(self, output, target): assert output.size() == target.size() output = F.softmax(output, dim=1) output = flatten(output) target = flatten(target) intersect = (output * target).sum(-1) denominator = (output + target).sum(-1) dice = intersect / denominator dice = torch.mean(dice) return 1 - dice 5. Focal Loss 原理 Focal Loss是由交叉熵演变而来，对于一些样本分布及其不均匀的分割任务，例如血管分割，使用BCELoss容易产生初始状态下Loss就已经很小的情况。\n因此引入来控制正负样本的loss权重，例如引入一个$\\alpha_t$，当真实为正样例时，取值为$\\alpha$，反之为$1-\\alpha$，并将其架在原有的交叉熵损失上，记当为真实为正例时$p_t=p$，反之$p_t=1-p$，相当于模型输出的p为预测为正例的概率。\n因此交叉熵损失更改为$-\\alpha_tlog(p_t)$，若$\\alpha$取值较小，当遇到正例时对损失函数带来的Loss影响更大（因为有负号的存在），反之负例则Loss影响较小。\n但这并不能使得模型聚焦于hard样例的学习，引入调制因子$(1-p_t)^\\gamma$，对于正例，若模型输出的结果较小，认定其具有学习难度，结果$p_t$越小，难度越大，调制因子带来的Loss就越大。\n表达式 最终表达式如下：\n$$ Focal=\\left\\{ \\begin{aligned} -(1-\\alpha)f(x)^\\gamma log(1-f(x)), \\ y=0 \\\\ -\\alpha (1-f(x))^\\gamma log(f(x)),\\ y=1 \\end{aligned} \\right. $$\n代码 class WeightedFocalLoss(nn.Module): def __init__(self, alpha=.25, gamma=2): super(WeightedFocalLoss, self).__init__() self.gamma = gamma self.alpha = alpha def forward(self, inputs, targets): BCE_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction=\u0026#39;none\u0026#39;) pt = torch.exp(-BCE_loss) F_loss = self.alpha * (1 - pt) ** self.gamma * BCE_loss return F_loss.mean() 备注 对于$\\alpha$和$\\gamma$的取值，通常为0.25和2。\n实验效果不佳？对于非小比例正例的训练情况\n三、其它Loss 1. KL散度 原理 信息熵的定义：\n一个事件信息量的期望，形式上：设事件$X$有$n$种可能，发生$x_i$的概率为$p(x_i)$，则该事件的熵$H(X)$则为： $$ H(x)=-\\sum_{i=1}^{n}p(x_i)log(p(x_i)) $$ 相对熵的定义：\n对于同一个随机变量$x$有两个单独的概率分布$P(x)$和$Q(x)$，使用KL散度描述差异，其中$P$往往是真实分布，$Q$为模型所预测的分布。\n表达式 $$ D_{KL}(p||q)=\\sum_{i=1}^{n}[p(x_i)log(p(x_i))-p(x_i)log(q(x_i))]=\\sum_{i=1}^{n}p(x_i)log(\\frac{p(x_i)}{q(x_i)}) $$\n备注 KL散度可以理解为从A角度来看，B事件和A事件的差异性。\n2. Hinge损失 原理 常用于SVM中，二分类问题，对于标签值$y \\in { 1,-1 }$，预测值$\\hat{y} \\in R$，当预测值在$(-1,1)$之外时，分类结果确定，反之分类结果不确定，loss不为0，当预测值为0时，显然loss是最大的。Loss向零线性增长。\n表达式 $$ Hinge=max(0,1-yf(x)) $$\n"},{"section":"Blog","slug":"/en/blog/cims/","title":"【项目笔记】基于Vue+Springboot的班级信息管理系统","description":"this is meta description","date":"January 5, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/lossfunction/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"247\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/lossfunction\\/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/lossfunction/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/lossfunction\\/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"项目笔记","tags":"系统开发, 管理系统","content":"1. 项目背景 随着教育信息化的发展，班级管理面临着更高效、便捷的需求。为了提升班级管理的效率，我们决定设计并开发《班级信息管理系统》。该系统旨在为班级助理提供一个集成化的平台，使其能够更有效地管理班级同学的信息、成绩和学习状况，从而提高班级管理的质量和效率。\n系统的主要目标是为班级助理提供一个全面的工具，以便他们可以轻松地记录、查看和管理学生的成绩信息和课程进度。通过系统，班级助理可以快速地更新学生成绩、发布课程通知，以及及时了解班级整体学习状况。此外，系统还为学生提供了便捷的渠道，使他们能够随时随地查看自己的成绩、课程信息，并浏览班级助理发布的通知。\n除了基本的管理功能外，系统还致力于提升学生的学习体验。学生可以通过系统参与学习论坛，与同学分享学习心得、提问问题，并互相交流经验。此外，系统还为学生提供了TodoList等实用功能，帮助他们更好地管理自己的学习计划和任务，提高学习效率。\n通过《班级信息管理系统》的设计与实现，我们希望能够促进学校班级管理的现代化和智能化，提高班级管理的效率，同时为学生提供更好的学习体验，帮助他们更好地管理自己的学业。\n2. 功能需求分析 根据项目背景与该系统的实际应用场景，考虑对系统进行需求分析，并确定一系列系统功能，在该系统中，存在两个角色：管理员与学生，对这两类角色进行以下权限和功能确认。\n2.1 管理员角色的功能分析 管理员拥有以下权限和功能：\n学生管理：管理员可以添加、编辑和删除学生信息，查看学生的基本信息，如姓名、学号、班级等。管理员可以查询学生的课程安排和成绩情况。\n课程管理：管理员可以创建新的课程或班级，编辑和删除课程信息。管理员可以安排课程的上课时间、地点和教师，并查看课程的学生名单和选课情况。\n成绩管理：管理员可以输入和更新学生的成绩，生成成绩单和统计数据，并分析学生的学习进展和表现。\n通知和消息：管理员可以向学生发送通知和重要消息，接收和处理学生的反馈和问题，并给学生发送课程更新和提醒。\n系统设置：管理员可以修改系统配置，如学期设置、考试规则等。管理员可以创建和管理管理员账号，进行数据备份与恢复，查看系统日志和用户活动记录等操作。\n2.2 学生角色的功能分析 学生拥有以下权限和功能：\n课程信息：学生可以查看当前所选课程的详细信息，包括课程名称、教师、上课时间和地点等。\n课程表：学生可以查看日历视图，方便了解整个学期或特定日期的课程安排。\n成绩查询：学生可以查看自己在各门课程中的成绩和评价，并提供成绩统计和图表分析，帮助学生了解自己的学业进展。\n作业和任务：学生可以显示当前课程的作业和任务列表，同时给出TodoList代办模块，用于个人近期代办的记录与提示。\n学习论坛：学生可以使用学习论坛，其中包括答疑区和讨论区等板块，提供课程相关的学习资源，如教材、幻灯片、录像等。\n通知消息：学生可以接收学校和教师发送的通知和消息，包括课程更新、考试通知、请假批准等信息。\n个人信息：学生可以查看和编辑个人信息，如姓名、学号、联系方式等。学生还可以修改账户密码和安全设置。\n根据以上的功能分析，可以辅助于后续的前端界面设计与数据库设计。\n3. 设计思路 该系统计划以Web应用的形式进行开发，具体采用前后端分离的开发方式，在模块化设计的前提下将开发工作划分给不同的小组成员。以下为前后端的大致设计思路，具体的设计过程与细节见4-6节。\n对于页面前端部分，采用Vue.js+ElementUI进行页面组件的开发，首先需要进行用户角色的划分，不同的用户用一组用户名与密码进行标识，并提供注册功能。系统能够通过用户名与密码来确定其角色类型，以在登录系统展现不同的前端界面，并给出相应的功能模块界面，具体的页面布局与内容将根据需求分析结果进行设计。对于前端的数据，考虑采用axios进行向后端发送异步请求。\n对于后端应用部分，采用springboot框架实现，首先需要进行数据库的连接，并通过标准的三层架构（Controller层、Service层、Mapper层）对外提供请求接口，每一个接口的实现部分将通过集成的mybatis工具获取或修改数据库内容，并进行必要的数据整合以供前端直接使用。在前后端分离的背景下，前后端开发同步进行，因此在前端开发时考虑使用mock工具进行请求拦截并生成随机数据，在后端依次实现接口后即可逐一替换原有的mock数据，以实现最终的前后端连接。\n4. 前端设计 4.1 界面设计 本系统的前端界面采用vue-admin-template框架，并集合Element-UI组件库进行界面的二次开发设计。\n登陆注册界面是不需要具体用户登录信息就能访问的界面，因此我们需要将这两个界面的路由添加的路由守卫白名单中，并为他们配置静态路由，如图4.1和图4.2所示。\n【图4.1 路由守卫白名单】\n【图4.2 静态路由】\n本系统的登录界面和注册界面如下图4.3与4.4所示。\n【图4.3 登陆界面】\n【图4.4 注册界面】\n我们为本系统设计了两种不同的角色，分别是’admin’和’editor’。以管理员角色’admin’登录后可以看到管理员的界面内容，分别是管理员个人信息，学生管理，成绩管理，课程管理、通知管理和系统设置界面。以学生角色’editor’登录后可以看到学生的界面内容，分别是学生个人信息，课程查询，成绩查询，作业与任务，通知中心，学习论坛界面。管理员的界面概览和学生的界面概览如图4.5和图4.6所示。\n【图4.5 管理员界面概览】\n【图4.6 学生界面概览】\n为了实现如上效果，我们添加了角色分类和判断，并且为这些页面配置了动态路由来渲染相关数据。其中角色分类与判断跳转相关的配置和路由守卫函数如图4.7和图4.8所示，与侧边栏标签渲染和各个页面之间跳转有关的路由配置部分代码如图4.9所示，其余相似代码不再过多展示。\n【图4.7 根据角色过滤路由】\n【图4.8 获取过滤的路由】\n【图4.9 动态路由】\n4.2 功能设计 4.2.1 管理员端功能 管理员端能够对学生、成绩、课程、通知进行管理，基础功能为增删改查，额外增加的功能为文件批量导入和数据批量导出为文件。管理员端四个功能界面布局如下图4.10至图4.13所示。\n【图4.10 学生管理界面】\n【图4.11 课程管理界面】\n【图4.12 成绩管理界面】\n【图4.13 通知管理界面】\n接下来我们以学生管理界面为例分别介绍一下各个功能的实现过程。\n首先是查询学生功能，如图4.14所示。我们设置了一个原始数组origndata用来获取从后端返回的数据。但考虑到查询功能，我们又添加了一个计算属性的数组tableData，它用于根据过滤条件，从origndata中筛选符合要求的数据并显示。\n【图4.14 查询学生信息】\n其次是添加学生功能，如图4.15所示。点击添加学生按钮，会从左边弹出一个嵌套了表单的抽屉，该表单绑定对象form。管理员填写完相关学生信息后点击确认提交，会调用OnSubmit函数生成学生账号和初始密码（为学号后4位），并调用post请求，将表单数据form作为post的参数传输给后端，并且将form数据压入当前原始数据组进行渲染。\n【图4.15 添加学生信息】\n接着是删除学生功能，如图4.16所示。点击具体的某条学生信息后的删除按钮，会触发deleteStudent(scope.$index)函数，其中scope.$index代表的是行数，也就是该行在tableData中的索引，把tableData中该行的值赋给form并在origndata中寻找与form数据相同的数组索引。找到后向后端发起delete请求并带上找到的数组索引。同时把origndata中的该数据也删除重新渲染。\n【图4.16 删除学生信息】\n最后是编辑学生信息功能，如图4.17所示。编辑学生功能与添加学生功能的动态页面效果是一样的。点击编辑按钮，会调用editStudent(scope.$index)函数，然后从左侧跳出嵌入了表单的抽屉。不同的是表单的初值form被设置为了从tableData中的scope.$index行取出的数据，可以在此基础上修改学生信息并将其提交。提交即向后端发出put请求，需要带上origndata中的原始数据id和form对象。具体取id和传递数据方法与前两个请求类似，不再过多赘述。\n【图4.17 编辑学生信息】\n除了以上功能之外，本系统还支持文件的导入导出，如图4.18所示。在学生管理界面可以点击文件导入按钮，从本地选择学生信息文件导入，导入后的解析结果会显示在表格中，点击确认导入后，会逐条调用post请求函数将数据上传至后端，同时也会将这些数据压入现有的原始数据数组重新渲染。导出功能以成绩管理界面为例，可以将当前页面显示的数据导出成excel表格本地保存，如图4.19所示。\n【图4.18 文件批量导入】\n【图4.19 成绩导出】\n4.2.2 学生端功能 学生端能够对成绩、课程、通知、作业任务进行查看，同时可以手动添加修改删除作业任务等。此外，学生界面还有一个学生论坛可以发布论坛帖。学生端五个功能界面布局如下图4.20至图4.24所示。\n【图4.20 课程信息界面】\n【图4.21 成绩查询界面】\n【图4.22 作业与任务界面】\n【图4.23 学习论坛界面】\n【图4.24 通知中心界面】\n成绩查询页面的查询功能与管理员页面的查询功能实现方式类似，学习论坛页面的发布新帖功能与管理员页面的添加学生信息课程信息等功能实现方式类似，不再过多赘述。学生端独有的功能为作业与任务页面的待办表，它可以新增待办事项，点击勾选将待办事项的状态标记为已完成，编辑修改待办列表中的待办事项，还可以一键清除已完成事项等，如图4.25所示。具体实现逻辑也类似增删改查相关功能，不再过多赘述。\n【图4.25 作业与任务界面功能展示】\n4.3 接口设计 接口设计主要用于当前端页面发出数据增删改查请求时，向后端及数库调用数据。本系统涉及四种请求类型，分别是get、put、post和delete。共25个接口，部分接口如图4.26所示，其余相似接口代码不再重复描述。\n【图4.26 部分前端所需接口内容】\n5. 数据库设计 5.1 概念模型设计 为描述系统中各实体的属性与各实体之间的关联，首先进行概念模型的设计，这里采用UML数据库表示法进行ERD图的呈现，如图5.1所示，从中可以确定系统中各实体的详细信息以及各实体之间存在的关联，例如外键依赖等。\n【图5.1 系统的ERD图(基于UML数据库表示法)】\n5.2 关系模型确定 完成数据库的概念结构解释后，将其转换为与数据库服务所相符的逻辑结构，由于使用的是关系型数据库，因此只需要将以上的ERD图转换为关系模型即可，并确定关系模型的属性与码。但其实图5.1也能够清晰地体现该关系模型。共包含教师、课程、作业、成绩、选课记录、学生、待办、管理员、班级、通知、论坛发帖、论坛评论、论坛回复等关系模型，其属性与码如图5.1所标注。\n5.3 数据库的创建 在数据库中使用SQL语句进行数据表的创建，以成绩表为例，建表的SQL语句如图5.2所示。可以看到SQL语句中标识了主键为学生ID与课程ID，并且都外键依赖于学生表Student的主键与课程表Courses的主键，符合完整性约束。\n【图5.2 成绩表scores的建表SQL语句】\n同理建立剩余的十余个数据表，并存放于数据库mysql_software中，该数据库归属于根用户root，存放于云服务器中，可以通过公网IP和服务端口对数据库进行连接，使用数据库管理应用连接该数据库，可以查看到建表结果，如下图5.3所示。\n【图5.3 数据库的创建结果】\n6. 后端程序编写 为连接数据库并向前端应用提供合适的数据接口，需要进行后端程序的编写，该系统采用springboot框架进行后端应用的开发。\n6.1 相关配置 对于springboot项目，首先需要进行相关依赖的配置，在加载Maven依赖时选用了MySQL Driver，用于数据库的连接，以及lombok，便于后续的开发编码过程。\n对于数据库配置，需要进行配置文件中的参数说明，如图6.1所示。其中指定了数据库驱动器、待连接的数据库位置（云服务器上装载的数据库）及其服务端口3306，可以通过该IP与端口进行数据库的连接，并指定了连接用户为root用户。同时配置后端服务开放的端口为9090，故前端需要访问后端时，只需要访问后端服务所在IP，配合该9090服务端口即可（这些内容需要在前端vue项目中axios的二次封装的代码处进行设置）。\n【图6.1 相关基础配置】\n6.2 三层架构说明 后端采用Controller、Service、Mapper的分层架构模式进行代码编写。\n6.2.1 控制类Controller层 其中Controller充当控制器角色，负责处理来自用户发送的数据请求，并返回相应的结果，在其接收到数据请求后，需要调用下一层Service中的业务处理函数，再进行一定程度的结果封装后返回前端。一个Controller类需要通过注解@Recontroled进行标识，同时可以包含多个方法，每个方法对应一个不同的请求，也需要通过注解进行标注，例如@GetMapping注解标注该方法需要处理GET请求，其中注解的参数即为具体的请求路径。本系统包含了两个Controller类，分别为AdminController和StudentController，分别用于接收和处理用户和管理员发送的数据请求。\n以AdminController为例，部分代码内容如下图6.2所示。可以看到类的开头使用了@RequestMapping注解指定了请求路径的根，故该类只接受包含该路径的请求，随后类中使用@Autowired注解自动绑定了许多服务层的类，对于这些类的具体内容将在6.2.2节中阐述，每个服务类均向控制类提供了不同数据对象的业务处理服务。最后在类的主要部分，包含了许多共有方法，每个方法均由注解进行说明请求路径，用来接收前端发送的各类请求、调用服务、封装数据、返回数据，该部分内容为后端代码编写的主要内容。\n【图6.2 AdminController类的部分代码内容】\n6.2.2 服务类Service层 负责处理业务逻辑和协调不同的组件，该部分可以理解为向下调用不同的数据访问层并对之进行协调，获取数据库中的数据结果，向上提供服务接口，将指定的数据按照业务逻辑返回给调用处。对应的服务类需要通过@Service注解进行说明。\n该系统中为所有常见的实体都配置的服务类，用于提供基于不同实体的服务，项目列表如图6.3所示。\n【图6.3 Service层中的所有服务类】\n以对于代办事项这一实体提供的服务类TodoListService为例，其代码内容如图6.4所示。可以看到该类通过@Service注解进行说明，同时自动绑定了下一Mapper层的一个抽象实现，具体的成员方法中，提供了许多共有方法，每个方法对应着一个特定的业务逻辑，例如getEditorTodoListBySid方法对上层（Controller层）提供了根据学生ID获取对应的代办列表这一服务，具体的数据获取则交给下一层数据访问层进行。该TodoListService服务类就提供了基本的对数据表TodoList的增删改查功能。\n【图6.4 TodoList服务类的代码内容】\n6.2.3 数据访问Mapper层 对于数据访问层，则需要进行数据库的访问操作，并向上层提供访问结果，对应的类要以抽象接口的形式进行声明，因为该层不需要进行任何的数据处理，故不需要方法体的声明，只需要将数据库的结果交付给上层即可。该层需要使用@Mapper注解进行说明。同时对应的增删改查操作（INSERT、DELETE、UPDATE、SELECT）也需要通过相应地注解配合SQL语句将其绑定到指定的抽象方法上即可。\n继续以代表事项这一实体对应的数据访问层为例，代码内容如图6.5所示。可以看到该层是以接口的形式进行定义的，且包含一系列抽象方法，无需对方法进行具体的实现，只需要接收上层传参，执行SQL语句，返回数据即可，具体的处理逻辑交付给服务层执行。以getEditorTodoListBySid这一方法为例，上层传入参数为学生ID，在该抽象方法上绑定了@Select注解，其中包含了具体的SELECT语句，从TodoList数据表中进行数据的筛选，并保证记录的Sid为传入的学生ID，从而实现了筛选指定学生的代办记录的功能。\n【图6.5 TodoList数据访问层的代码内容】\n可以看到数据以List的形式返回，包含的类为TodoList类，该实体类与数据表中的记录一一对应，如图6.6所示，springboot框架可以自动识别其中属性名相同的部分并将数据合理地包装，以更方便的将数据返回上层处理。\n【图6.6 TodoList实体类内容】\n6.3 请求接口编写 根据三层架构编写方法，在两个Controller类中进行接口编写，编写内容基于前端所需的请求接口和数据格式进行，并依次替换原mock的拦截。\n以登录请求为例，该请求的路径为\u0026rsquo;/admin/user/login\u0026rsquo;，并要求传入用户名和密码，并判断是否可以登录，存在密码错误或者用户不存在的现象则返回错误代码，反之则继续判断用户类型，并返回指定的Token，用于不同界面内容的跳转。\n首先需要进行返回数据的统一封装，考虑到返回的数据均包含状态码、数据载荷、消息载荷等内容，考虑将这些内容封装成统一的类进行返回，如图6.7所示，定义了一个登录结果的返回类LoginResult，包含了两个静态成员函数，一个为error，返回一个标识错误的结果对象，另一个为success，返回一个带有数据载荷的结果对象。前端可以获取到指定的状态码以检验是否顺利登录。\n【图6.7 返回结果的统一封装】\n而具体的请求处理函数部分如图6.8所示。可以看到首先调用了管理员服务层获取密码与唯一的用户标识ID，若密码不存在或者真实密码与传入密码不匹配则继续下一步的判断，反之根据唯一的用户标识生成Token，包含在数据载荷中返回前端。在判断不为管理员后进一步判断是否为学生，处理逻辑相似，通过学生服务层获取真实密码进行比对，若成功则根据唯一的学号进行Token的返回。\n【图6.8 处理前端登录请求的代码内容】\n以此为例，进行前端所需的所有25个接口的编写，由于代码量较大，在此不进行赘述，详见源代码，如图4.26中所示的几个管理学生信息的接口函数的实现如下图6.9所示。其中需要说明的是HttpSevletRequest对象中包含了所有的请求头内容，在前端的代码编写中已将Token内容置于请求头中，因此后端能够直接在该对象中获取请求者的Token，从而唯一地确定请求来源。\n【图6.9 部分接口的实现（与图4.26相匹配）】\n6.4 跨域问题的解决 因为浏览器的同源策略，在开发过程中会遇到各种跨域问题，即当前后端项目运行在同一个IP的主机上时，会发生同源限制，从而阻碍开发的进行，对此的解决方法较为容易，在后端的Controller中只需要加上@CrossOrigin注解即可解决跨域问题。\n7. 系统功能展示 当完成前端与后端的编写后，系统整体完成，前端渲染的数据均来自于服务器存储，系统下运行效果即如第4节前端设计中所展示，由于功能模块较多，在这一节中不进行一一陈述，仅进行前后端联通的相关举例说明。\n以学生界面的“作业与任务”功能为例，数据库中TodoList存储的内容如图7.1所示。登录216001912用户，相应的组件内容如图7.2所示。可以看到显示的数据内容与后端一致。\n【图7.1 TodoList数据表中内容】\n【图7.2 指定用户的前端界面】\n点击某两项任务将其完成，前端界面如图7.3所示。同步查看数据库中的内容，如图7.4所示，可以看到对影响的代办状态被标记为1，即为“已完成”状态的记录。由此可以看出前后端成功通信且能够实现数据的永久性存储。\n【图7.3 完成某两项代办】\n【图7.4 数据库中内容查看(代办状态改变)】\n清除已完成的任务，并添加一条新的任务，前端界面如图7.5所示，数据被成功修改与添加，同步查看数据库内容，如图7.6所示，可以看到相关内容已同步保存到数据库之中。\n【图7.5 删除完成任务并添加新任务】\n【图7.6 数据库中内容查看(数据增删)】\n至此演示了有关TodoList的部分功能，以体现前后端成功连接的特点，本次课程设计成功实现了一个基本的前后端分离且通过异步请求通信的管理系统。\n8. 结语与感悟 在《班级信息管理系统》的设计与开发中，我们致力于构建一个功能全面的平台，旨在为学生信息管理、课程管理、成绩记录和通知传达等方面提供便捷而高效的解决方案。这一系统的设计不仅有望提高学校管理的效率，更着眼于优化学生的学习体验，为整个学校教育信息化迈出坚实的一步。\n在系统功能方面，我们精心设计了管理员可以轻松管理学生信息和课程安排的功能，使其能够高效地处理日常事务。同时，学生通过系统可以方便地查询个人成绩和课程信息，同时获得及时的通知，为学习提供更有序的环境。系统还提供了学习论坛等功能，为学生提供了一个良好的交流平台，促进彼此之间的学术合作与互助。\n在开发方面，我们采用了前后端分离开发方式，搭建了vue+springboot+MySQL的架构。这一选择不仅反映了我们对最新技术的关注，同时也锻炼了我们在实际项目中的技术应用能力以及发现问题与解决问题的能力。团队成员在项目中各司其职，相互协作的默契配合，为项目的顺利完成奠定了坚实的基础。\n作为学生开发团队，我们从这个项目中学到了很多。我们不仅学到了如何合理规划和分配项目任务，更锻炼了在面对技术难题时的解决能力。团队成员之间的紧密合作，无论是在沟通还是协同开发中，都让我们更好地理解了团队合作的重要性。此外，通过与老师和同学们的反馈，我们也得以了解用户需求与体验，对于未来的项目开发有了更深刻的认识。\n总的来说，通过《班级信息管理系统》的设计与开发，我们不仅为学校提供了一套现代、高效的管理工具，同时也在学术和团队协作方面获得了丰富的经验。这个项目不仅仅是一个技术实践，更是一个团队成长的过程。我们相信，这种学到的经验将对我们未来的学习和职业生涯产生深远的影响。\n"},{"section":"Blog","slug":"/en/blog/thds/","title":"【项目笔记】基于MQTT和ESP的温湿度监测系统","description":"this is meta description","date":"January 5, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/lossfunction/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"247\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/lossfunction\\/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/lossfunction/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/lossfunction\\/focalloss_hu32ecab99632a1940dcc8620954844b12_118544_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"项目笔记","tags":"系统开发, 物联网","content":"摘要 环境温湿度监测在许多行业中具有重要意义，包括农业、物流、仓储、医疗等众多重要领域，因此本次课程设计选定的主题是基于NB-IoT的无线温湿度监测系统设计与实现。在项目中，我们团队着眼于无线监测节点的设计，通过整合ESP8266、SIM7020模块和DHT22模块，成功实现了NB-IoT联网和温湿度数据的获取。此外，前后端的协同工作也是项目中不可或缺的一部分，我们实现了从硬件到前后端的全面开发，包括数据的存储与渲染，并实现了一系列功能需求，体现了系统功能的复杂性与可用性。\n在硬件设计方面，ESP8266的编程为监测节点提供了智能控制和数据处理功能。而SIM7020模块的选择使得监测节点能够实现NBIoT联网，为远程通信提供了高效且可靠的手段。结合DHT22模块，成功实现了环境温湿度信息的高精度采集，为系统提供了全面感知环境变化的能力。这一节点设计不仅是系统的核心，也为整个监测系统的稳定运行提供了可靠保障。\n在软件平台的选择上，我们采用了Visual Studio Code、ArduinoIDE和IDEA等工具，分别用于前端代码的编写与测试，硬件代码的编写与烧录，以及后端代码的编写。这些工具的灵活运用使得我们能够高效地实现系统的各个模块，体现了团队在物联网开发技巧上的熟练掌握。与此同时，我们成功配置了云服务器，安装了数据库，并搭建了MQTT服务器用于消息汇总与传递。这一系列操作使得我们更深刻地理解了云计算和物联网的结合，为系统的可扩展性和数据处理提供了强大支持。\n最后，通过对整个设计过程的总结，我们团队获得了丰富的物联网开发经验。从硬件到前后端，我们不仅掌握了各类开发技巧，还培养了解决实际问题的能力。项目的成功实施不仅是对所学知识的应用，更是对团队整体实际能力的全面提升。\nEnvironmental temperature and humidity monitoring holds significant importance in various industries, including agriculture, logistics, warehousing, healthcare, and many other critical sectors. Therefore, the chosen theme for this course project is the design and implementation of a wireless temperature and humidity monitoring system based on NB-IoT (Narrowband Internet of Things). In this project, our team focused on the design of wireless monitoring nodes, successfully integrating the ESP8266, SIM7020 module, and DHT22 module to achieve NB-IoT connectivity and temperature-humidity data acquisition. Additionally, the collaboration between the frontend and backend was an integral part of the project. We accomplished comprehensive development from hardware to frontend and backend, including data storage and rendering, implementing a series of functional requirements that showcase the complexity and usability of the system.\nIn terms of hardware design, the programming of the ESP8266 provides intelligent control and data processing capabilities for the monitoring nodes. The selection of the SIM7020 module enables NB-IoT connectivity, offering an efficient and reliable means for remote communication. Combining the DHT22 module, we successfully achieved high-precision collection of environmental temperature and humidity information, providing the system with the ability to comprehensively perceive changes in the environment. This node design is not only the core of the system but also ensures the stable operation of the entire monitoring system.\nFor the software platform selection, we used tools such as Visual Studio Code, Arduino IDE, and IDEA for frontend code writing and testing, hardware code writing and burning, and backend code writing, respectively. The flexible use of these tools allowed us to efficiently implement various modules of the system, demonstrating the team\u0026rsquo;s proficiency in IoT development skills. At the same time, we successfully configured a cloud server, installed a database, and set up an MQTT server for message aggregation and transmission. This series of operations deepened our understanding of the integration of cloud computing and IoT, providing robust support for the system\u0026rsquo;s scalability and data processing.\nIn conclusion, through summarizing the entire design process, our team gained rich experience in IoT development. From hardware to frontend and backend, we not only mastered various development skills but also cultivated the ability to solve practical problems. The successful implementation of the project is not only an application of acquired knowledge but also a comprehensive enhancement of the overall capabilities of the team.\n1. 设计背景与目标 1.1 设计背景 环境温湿度监测在许多行业中具有重要意义，包括农业、物流、仓储、医疗等众多重要领域。通过实时监测环境的温度和湿度，可以提前预警并及时采取措施，保证设备的正常运行，提高生产效率，防止质量问题的发生。除此之外，全球气候变化和环境问题引起了广泛关注，气温升高、极端天气和自然灾害频发成为不容忽视的现实。\n在当下，许多企业和机构依然采用传统的手工监测模式，投入数量有限的监测点，并投入一定量的人力，导致监测数据出现获取不及时、准确性低等状况。这类方式存在一定的弊端，包括高昂的成本、效率低下、难以实现全面覆盖等问题。但随着对环境温湿度的要求不断提高，许多行业迫切需要一种可靠且智能化的环境温湿度监测报警系统。\n这种系统将基于物联网技术，通过部署一定数量的传感器设备，在关键位置实时监测环境的温度和湿度，通过数据采集和处理，不仅可以实时监测环境参数，还可以根据预设条件自动触发报警机制，实现对温湿度的全面监测和分析，为用户提供实时的环境状态信息、报警提示和环境状态预测，帮助用户尽早发现异常情况并采取相应的措施。\n1.2 设计目标 本次课程设计题目为《基于NB-IoT的无线温湿度监测系统设计与实现》，包含以下若干需要实现的设计目标。\n基于NB-IoT技术进行应用开发，实现一个完善的智能温湿度监测系统； 掌握基本的物联网开发技术，包括无线节点的代码设计与写入、通过无线信道进行信息传输； 熟悉NB-IoT的基本原理与常见硬件模块的使用方式； 熟悉各类常见传感器的电气特性与使用方法，例如DHT系列传感器、蜂鸣器等； 掌握基础全栈开发技术，学习常用前后端框架，以完成应用平台的开发； 2. 课程设计器材 选择合适的硬件平台和软件平台可以为本次课程设计提供极大的设计便利，利于最终的智能温湿度监测系统的实现。\n2.1 硬件平台 硬件平台的选用将综合考虑性能、稳定性、成本、使用门槛、平台拓展性等方面。节点的开发板方面，本次实验选用ESP8266模块，NB-IoT联网方面选用SIM7020模块，温湿度监测方面选用DHT22模块。这些器件的主要特点如下。\nESP8266：ESP8266是一款低成本、低功耗的开发模组，具有高性能的Wi-Fi模块，内部集成MCU以实现串口通信。选用该模块的原因包括：成本较低，试验代价较小；具有Wi-Fi模块，联网方便，便于开发过程中的信息传输调试。 SIM7020：SIM7020模块是一种低功耗、小型化的NB-IoT模块，专为物联网应用设计，可以用于远程设备的低功耗、长距离通信。具有低功耗、广覆盖、高连接性的特点。选用SIM7020模块可以实现设备与云端的可靠、高效的通信，使得温湿度监测系统可以在不同地点进行数据传输。 DHT22：DHT22是一种数字温湿度传感器，能够测量环境中的温度和湿度，并通过数字信号输出这些数据，是一种成本效益高且易于使用的温湿度传感器。它提供了对环境条件的准确监测，是制作低成本、高效率温湿度监测系统的理想选择。 2.2 软件平台 Arduino IDE：Arduino是一种开源电子原型平台，包括硬件和软件，它使用简单的C/C++语言编写，为物联网和嵌入式系统提供了一种易于使用的开发环境。使用其集成开发环境（IDE）能够非常快速地开发并测试物联网设备的硬件代码，故本次课程设计主要使用Arduino作为硬件的开发平台。 IDEA：IntelliJ IDEA是一款由JetBrains开发的Java集成开发环境，适用于后端的代码编写、测试、打包，有助于后端的开发效率。 Visual Studio Code：VSCode是一款轻量级的开源代码编辑器，支持多种编程语言，本次课程设计主要使用其进行前端代码的开发，它提供了丰富的前端插件，简化了开发流程。 EMQX：EMQX是一个开源的分布式物联网消息中间件，支持MQTT协议，适用于大规模物联网应用。EMQX作为消息队列服务器，为各节点提供了可靠的消息传递机制，且可以自主进行EMQX服务器的搭建，因而本次实验也选用了EMQX服务器作为消息传输的载体。 3. 设计方案 3.1 思路分析 对于无线智能温湿度监测系统，需要考虑以下若干方面：不同位置的温湿度信息获取、温湿度信息的汇总与存储、数据的合理处理与呈现。\n对于温湿度信息的获取，需要使用相关的温湿度信息监测模块，并连接到某一节点上，节点需要通过温湿度传感器获取温湿度信息，并对信息进行合理的处理，包括异常值的筛选、监测时间的记录。且每个节点之间是独立且可分辨的，可以互不干扰地进行温湿度信息的获取，通过多节点实现不同空间位置上的监测。\n对于温湿度信息的汇总，需要考虑节点之间的信息共享，因此需要网络的建立，本次课程设计需要使用窄带物联网进行通信，因此各节点需要配备NB-IoT的通信模块。除此之外，各传感节点中获取的信息各不相同，且具有异步特性，故考虑使用消息队列服务器进行信息的汇总处理，本次设计采用EMQX服务器作为消息汇总的中心，各节点共同订阅某一主题，并在获取到温湿度数据后将数据进行打包（添加节点编号、时间戳等信息），并统一通过NB-IoT发送至EMQX服务器的特定主题，以实现信息的共同发布与汇总。\n对于数据的存储，考虑使用后端程序（本次课程设计选用springboot框架）实现，与各传感节点类似，后端程序也应作为用户订阅EMQX服务器中的指定主题，但应作为信息的接收者，在接收到传感器的信息发布后进行消息的接收，并连接数据库（选用MySQL）进行数据的存储。\n对于数据的处理与呈现，考虑使用前端Web应用进行报表的呈现，同时提供给用户操作数据的接口，包括阈值设定，动态报表呈现，数据的导出等，前端代码需向后端进行数据的请求，后端程序也应当根据前端的需求提供合理可用的接口。\n3.2 系统架构 根据3.1节中所述的设计思路，可以进行系统整体的架构图的呈现，大致结构如图3.1所示。\n【图3.1 系统整体逻辑结构】\n为更好地说明系统整体的运行方式，考虑对以下过程进行流程分析：从某一节点采集数据开始直至数据呈现于用户。流程图如图3.2所示。\n【图3.2 系统运行流程图】\n可以确定，硬件端与软件端之间的运行相对独立，即前文所提及的硬件端的信息发布具有异步性，因此软件段需要在运行后持续等待硬件层面的数据传输。\n3.3 功能设计 在正式进行课程设计的开发前，我们进行了系统的系列需求分析，确定了一系列面向用户的功能。\n该系统的核心功能包括：实时监测、数据分析与渲染呈现、异常报警设置与通知、历史数据查询、日志报告导出等部分。具体的功能描述如下表3.1所示。\n功能概述 描述 实时监测 系统具备实时监测环境温湿度的功能，具有时效性。 数据分析与渲染呈现 系统能够对采集到的温湿度数据进行分析，提供直观的趋势展示，例如二维折线、三维热力图等。 异常报警设置与通知 系统支持自定义的报警规则设置。温湿度数据超出设定的阈值将触发报警机制，并以短信、电子邮件等形式通知相关人员。 历史数据查询 系统将保存一定时间范围内的历史数据，可以通过用户界面查询历史温湿度数据 日志报告导出 系统根据指定的时间间隔进行报告的生成，并提供导出服务器，包括数据分析表、异常情况统计 设备管理 系统提供对所有监测设备的统一管理服务平台，供管理员进行设备管理、系统设置 3.4 技术栈选型 本次课程设计选用的技术栈列举如下。\n服务器端\nSpring boot、MyBatis、Spring Security、Mysql、Redis、EMQX\nWeb端\nES6、Vue、Vuex、Vue-router、Vue-cli、Axios、Element-ui\n硬件端\nESP、Arduino、SIM、DHT\n4. 设计过程 设计实现包括以下若干步骤：服务器搭建、硬件端设计实现、前端页面设计、后端接口提供。\n4.1 服务器搭建 4.1.1 服务器选用 考虑到数据库的配置、MQTT服务器的搭建需要对外提供便捷的接口，同时方便对其进行维护，本次课设考虑将上述内容部署于云服务器中。选用的云服务器来自于华为云ECS，配置4核CPU与8G内存，预装操作系统为CentOS7.6 64位。如图4.1所示。\n【图4.1 云服务器选用规格信息】\n4.1.2 数据库搭建 考虑到无线节点获取的温湿度数据需要在数据库中进行存储，因此需要在ECS上进行数据库的配置与安装，本次设计选用的数据库版本为MySQL8.0.35 for Linux on aarch64。在云服务器上进行数据库的安装，并保证数据库服务启动并能够通过3306端口进行访问，如图4.2所示，数据库服务启动。\n【图4.2 MySQL安装与服务启动】\n由于给定的云服务器具有公网IP，因此可以远程对该数据库进行访问连接，本次实验采用HeidiSQL作为数据设计的管理工具，使用HeidiSQL连接至云端数据库，首先通过root用户创建了一个名为mysql_mqtt的数据库，以存储后续的数据表，并作为后端连接的主数据库，进行数据表的设计，考虑到这类应用场景数据类型单一，只考虑设置两张数据表，分别为记录record与硬件信息表hardware。\n对于硬件信息表，其中包含字段为：硬件ID（主键）、温度阈值上下限、湿度阈值上下限、硬件类型、硬件状态、收集数据总数、硬件描述，如图4.3所示。\n【图4.3 硬件信息表hardware内容】\n对于记录表，其中包含字段为：记录ID（主键）、来源设备（依赖于硬件信息表）、时间戳信息、温度信息、湿度信息，如图4.4所示。\n【图4.4 记录表record内容】\n4.1.3 MQTT服务器搭建 本次课设选用MQTT服务器作为消息队列服务器，考虑到维护和测试的方便，故自主进行MQTT服务器的搭建，与数据库服务器类似对外提供EMQX服务，接受各用户的订阅与消息共享。选用的EMQX服务的版本为5.1.6，在云服务器上完成EMQX服务的安装后，确认EMQX服务运行，如图4.5所示。\n【图4.5 EMQX服务运行】\n使用EMQX服务提供的18083端口可以访问MQTT服务器的管理后台，便于对集群信息进行查看，例如连接数目、连接状况、数据传输量等，便于后续的设计。后台内容概览如图4.6所示。为方便对具体的消息内容进行查看与确认，我们选用了MQTTX客户端进行服务器的连接与主题的监测，从而能够更好地确定消息发布状态。\n【图4.6 EMQX服务的管理后台】\n4.2 硬件端搭建 4.2.1 NB-IoT联网 使用SIM7020模块进行，选用合适的NB-IoT的SIM卡，插入SIM7020模块中，按照图4.7的形式将SIM7020模块与ESP8266开发板进行连接。\n【图4.7 ESP8266模块与SIM7020连接】\n通过AT指令集对SIM7020模块进行控制，通过ESP8266模块进行AT指令集的发送，相关代码内容如图4.8所示。\n【图4.8 通过AT指令集进行NB-IoT联网并连接至MQTT服务器】\n4.2.2 DHT22模块安装 DHT22模块仅包含VCC、GND和一个单线的数据IO口，将其连接到ESP8266上（引脚4，对应的代码编号为2）。代码层面，加载DHT相关的库，并定义一个DHT对象，设置DHT类型与DHT的IO端口号。完成连接后可以通过DHT对象的readHumidity()和readTemperature()函数获取温湿度信息，若温湿度信息异常，则返回NaN，需要对其异常值进行处理。代码内容如图4.9所示。通过getTH函数可以获取环境的温湿度，并存储于全局变量中，以供其余功能函数进行数据的获取。\n【图4.9 DHT22的连接与温湿度获取】\n4.2.3 MQTT消息发布 通过代码设置模块对某个主题进行订阅，这里选用的主题名称为“eps8266-1912”，将messageBuff中的内容通过窄带物联网发送至MQTT服务器的指定主题中，其中messageBuff数组中的内容为getJson函数生成的，该函数用于将一系列硬件与温湿度信息封装成Json格式存储到messageBuff之中。代码内容如图4.10所示。\n【图4.10 通过NB-IoT进行信息订阅与发布】\n4.2.4 WiFi版本编写 在设计过程中，发现NB-IoT相关组件的连接不良，考虑编写一份使用WiFi联网的硬件代码，仅与NB-IoT版本在联网部分的部分代码有所差异。因此在测试过程中，也使用了基于WiFi联网的硬件获取方式。该部分内容主要进行了联网函数connectWiFi()函数的编写，其中设置了WiFi信息以供ESP8266进行循环连接。主函数内容如图4.11所示。由于篇幅受限，不对每一个函数的细节进行展示，以注释的形式说明其功能。\n【图4.11 WiFi版本的主函数】\n4.2.5 子功能测试 以上的内容实现了无线节点的温湿度信息获取，并能够通过窄带物联网进行MQTT服务器的连接，从而进行数据的发布，为测试该子功能的正确性，考虑使用MQTTX客户端进行同一主题的订阅，并观察获取的数据准确性。如图4.12所示，可以看到成功实现了节点环境温度的监测，并以Json格式将其发布到了MQTT服务器中，且其余订阅该主题的模块或软件均能够获取该信息。\n【图4.12 数据发布功能的测试】\n4.3 前端设计 4.3.1 页面布局 基于表3.1中所列的各项功能模块，使用VSCode与Vue.js前端框架进行前端界面的代码编写，并使用了ElementUI辅助进行页面的美化与设计。\n网页界面的前端布局大体如图4.13所示。包含侧边导航栏，其中包含了系统主页、设备管理、数据分析、历史数据等子组件。\n【图4.13 前端网页布局】\n对于页面的跳转，采用vue-router实现，路由信息如下图4.14所示，通过导航栏的点击，跳转到不同的路径，从而显示不同的组件内容。\n【图4.14 使用vue-router实现页面跳转】\n4.3.2 数据请求 如图4.13所示，数据尚未进行显示，需要前端向后端发送数据请求，并在前端使用vue的双向绑定功能进行数据渲染，数据请求层面，使用axios进行异步请求。具体地，首先进行axios的二次封装，设置请求的地址与端口（后端服务的地址与端口），再进行api接口的设置，需要定义请求方式（get、put、post、delete）与请求路径，如图4.15所示，为部分数据请求函数。\n在各组件中，只需引入相应的数据请求函数，即可通过axios向指定的后端发送数据请求，并能够在request中获取数据的内容。后续需要在后端中依次提供这类数据的请求接口。\n【图4.15 前端部分数据请求】\n4.3.3 设备管理 在设备管理界面，进行了所有导入系统的无线节点信息的显示，包括唯一标识的设备ID、设备型号、设备状态、发送数据流、温度阈值上下限、湿度阈值上下限、设备描述等，如图4.16所示。同时对每一个设备信息可以进行编辑、删除操作，在此界面中进行设备的添加操作，需注意设备ID需要非重复，系统将会自动监测是否存在该ID的设备发送的信息，若有则进行存储与整合，并实施渲染到前端以提示用户。\n对于该部分的实现，主要采用ElementUI组件进行，数据主要来自于hardware表，其中发送数据量的值筛选自record表。\n【图4.16 设备管理界面设计】\n4.3.4 数据分析 在数据分析界面，以动态报表的形式呈现所有正在工作的监测节点处的温湿度信息，并在图线中给出阈值范围，使得用户能够清晰地观察到温湿度所处的范围，如图4.17所示。具体地，该部分采用echarts组件进行报表的呈现，前端每个一段时间（1s）向后端发送数据请求，查询数据库中新增的数据条目，并添加到显示队列即可实现报表的动态更新，且请求到数据后需要进行数据的筛选，以实现多个设备之间的工作独立性。\n【图4.17 数据分析界面设计】\n4.3.5 历史数据 在该界面中实现的内容较为简单，即将所有records表中的数据以表格的形式在前端进行呈现，并提供排序和筛选操作，使用户可以按照时间或者设备ID等信息查询指定时间段的数据信息，此外提供了报表导出与异常数据导出的功能，能够实现所有数据或异常数据的excel表格导出，方便后续的数据处理。该部分界面设计效果如图4.18所示。\n【图4.18 历史数据界面设计】\n4.4 后端开发 前端的待渲染数据通过axios向后端请求，因此后端程序需要提供合理的数据请求接口，具体地，后端程序需要实现数据库的连接，以在获取温湿度信息后进行数据的转存，同时也需要进行MQTT服务器的连接与主题订阅，以消费者的形式进行消息的获取。\n4.4.1 数据库的连接 由于后端框架采用springboot实现，需要在资源文件中进行相关配置的设置（application.yml），包括对数据库的信息配置，在springboot项目的初始化时已经选用添加了MySQL Driver依赖。由于数据库来自于云服务器，根据4.1.2节中的数据库配置，在此需要设置IP为云服务器的公网IP，并设置数据库名为mysql_mqtt，连接到root用户，并给定密码，如图4.19所示。\n在完成配置后springboot程序将在运行时连接至该数据库，且后续Mapper层中的SQL语句将被发送到该数据库中执行，以实现数据的存储与查询。\n【图4.19 后端程序连接数据库】\n4.4.2 MQTT服务器的配置 若想要springboot能够连接MQTT服务器，首先需要导入Maven依赖，具体的依赖名为：spring-integration-mqtt，重新加载Maven依赖后即可实现相关资源的加载。\n与数据库连接类似，MQTT服务器的连接也需要在application.yml文件中进行相关配置的设置，包括服务器所在的IP与服务提供端口，对于MQTT服务端口，在TCP协议下均默认为1883，此外还需要设定连接的id信息，该id需要保证在所有连接到目标服务器的客户端中非重复，最后需要设置订阅的主题。具体配置如下图4.20所示。\n需注意的是，本次课程设计过程中搭建的MQTT服务器并未进行节点的认证操作，因此这里的用户名和密码随机指定即可，服务器端并未对此进行认证。\n【图4.20 后端程序连接MQTT服务器的相关配置】\n4.4.3 服务器连接与数据获取 完成MQTT服务器的基本配置后，需要编写相关函数实现服务器的连接、主题订阅、消息监听与获取等操作，考虑设置一个MQTT消费者的控制类MqttConsumerComfig，提供一些基本的连接、重连函数。\n在加载spring-integration-mqtt依赖后，可以导入MqttClient类，该类的对象实现了一个虚拟的MQTT客户，在实例化对象时，需要设置目标MQTT服务器的IP与端口信息，同时给定唯一标识的客户id，这类信息可以在图4.20中的配置信息中获取，可以通过springboot的@Configuration与@Value注解将配置信息加载到类中的私有变量中，以供类中函数的调用。\n对于连接MQTT服务器的具体配置，可以通过MqttConnectOptions对象进行设置，包括用户名、密码、超时时长、保活时间、断开连接后的处理，最后通过MqttClient对象的connect函数进行配置的设置与连接操作执行即可完成连接。连接成功后再通过subscribe函数进行主题的订阅。\n除此之外，最为重要的操作即为对MqttClient对象进行回调函数的设置，该依赖提供了完整的回调函数的设置格式，抽象于MqttCallback接口中，只需要实现其中的三个抽象函数即可，分别为connectionLost（用于连接丢失后的处理操作设置）、messageArrived（获取信息后的处理）、deliveryComplete（完成发送后的后续处理）。对于deliveryComplete函数，本次课程设置无需进行实现；对于connectionLost函数，通过MqttClient对象的isConnected函数获取连接状态，并调用reconnect函数进行重连，或者直接重新执行connect函数。\n对于messageArrived函数，在主题中有新消息时，会以MqttMessage对象的形式将数据传入该回调函数，MqttMessage对象提供了getPayload函数来获取其中加载的信息内容字符串，随后通过一系列Java操作将其转换为Json格式并获取图4.12中所示的所有信息。\n在获取到所需的所有的数据后，考虑将数据进行封装并存入数据库，这里使用了springboot的三层架构，首先设置了实体类Record，成员变量与数据表record中的字段一一对应，以用于数据的封装，后续定义Service层与Mapper层，在Service层中对外提供插入数据的服务，以insertRecord函数的形式呈现，具体在Mapper层中通过SQL语句进行数据的插入。SQL语句即为：insert into record (froms ,timestamp,temperature,humidty) values (froms ,timestamp,temperature,humidty)，其中values中的数据来自于封装好的Record对象。\n综上完成了MQTT服务器的连接、主题的订阅、消息的监听、数据的存储操作。核心代码内容如下：\npublic void connect() { try { //MQTT客户对象 client = new MqttClient(hostUrl,clientId,new MemoryPersistence()); //连接配置信息 MqttConnectOptions options = new MqttConnectOptions(); options.setCleanSession(false); options.setUserName(username); options.setPassword(password.toCharArray()); options.setConnectionTimeout(100); options.setKeepAliveInterval(20); options.setWill(\u0026#34;willTopic\u0026#34;,(clientId + \u0026#34;与服务器断开连接\u0026#34;).getBytes(),0,false); //重写回调函数内容 client.setCallback(new MqttCallback() { @Override //重连的处理方法 public void connectionLost(Throwable throwable) { System.out.println(\u0026#34;MQTT连接断开，发起重连......\u0026#34;); try { if(client!=null \u0026amp;\u0026amp; !client.isConnected()) { client.reconnect(); System.out.println(\u0026#34;尝试重新连接\u0026#34;); } else { client.connect(options); System.out.println(\u0026#34;尝试建立新连接\u0026#34;); } } catch (Exception e) { e.printStackTrace(); } } @Override //消息获取后的处理方法 public void messageArrived(String topic, MqttMessage message) throws Exception { String msg = new String(message.getPayload()); ObjectMapper objectMapper = new ObjectMapper(); Map\u0026lt;String,Object\u0026gt; map = objectMapper.readValue(msg, Map.class); //获取消息中的关键信息 String Timestamp = String.valueOf(map.get(\u0026#34;Timestamp\u0026#34;)); String from = String.valueOf(map.get(\u0026#34;ID\u0026#34;)); String Humidity = String.valueOf(map.get(\u0026#34;Humidity\u0026#34;)); String Temperature = String.valueOf(map.get(\u0026#34;Temperature\u0026#34;)); //信息封装 Record record = new Record(); record.setFroms(from); record.setTimestamp(Timestamp); record.setTemperature(Temperature); record.setHumidity(Humidity); //处理异常数据 if(Long.parseLong(Timestamp)\u0026lt;100) return; //调用服务以插入数据 recordService.insertRecord(record); } @Override public void deliveryComplete(IMqttDeliveryToken iMqttDeliveryToken) {} }); //设置连接配置，随后发送连接 client.connect(options); //订阅主题 client.subscribe(defaultTopic,0); } catch (MqttException e) { e.printStackTrace(); } } 运行springboot程序，同时进入到MQTT服务器的后端（18083端口），可以查看到springboot程序已连接至MQTT服务器，并显示了图4.20中指定的用户名和唯一标识的客户ID，如图4.21所示。至此实现了服务器的连接以及消息主题的订阅。\n【图4.21 springboot连接MQTT】\n4.4.4 接口设计 该部分实现后端对前端提供的各类api接口的代码编写，采用springboot的三层架构，在Controller层提供对外的请求接口。以增添设备操作为例，需要前端发送post请求，后端层面通过@PostMapping注解设置请求路径为\u0026rsquo;/addIot\u0026rsquo;，并在函数参数处通过@RequestBody获取请求数据，即为待插入的IoT信息，随后调用espService中的insertIot服务，将待插入的对象传入，在其中继续调用Mapper层的特定函数，最后在Mapper层使用SQL语句进行数据插入即可。\n需要注意的是，插入操作需要保证完整性依赖，即设备的ID不能重复，否则数据库层面会拒绝插入操作并以Error的形式返回后端，故后端代码需要使用try-catch语句捕获该异常，并向前端返回异常代码，若插入正常则返回成功代码。\n该部分的代码内容如下。以此为例实现了前端所需的所有请求接口，完成了所有的前后端互通操作。\n@PostMapping(\u0026#34;/addIot\u0026#34;) public Result add(@RequestBody EspIoT iot) { try { espService.insertIot(iot); } catch (Exception e) { if(e instanceof DuplicateKeyException) { return Result.error(\u0026#34;Insert Wrong\u0026#34;); } else { return Result.error(\u0026#34;System Wrong\u0026#34;); } } return Result.success(); } 5. 系统测试 5.1 系统部署 代码编写时均在本地进行测试运行，完成了系统的开发后，为方便测试系统功能的完整性与可用性，将前后端项目部署到云服务器中，该云服务器即为MySQL数据库和MQTT服务器所在的ECS，更改前端中axios的默认请求IP为127.0.0.1:9090或者具体的ECS公网IP，若使用localhost则无法被解析。打包前端项目生成dist文件，打包后端项目生成jar文件，将其上传至云服务器之中，配置nginx路径于该dist文件中，并通过nohup命令在后台运行该jar文件，即可实现使用公网IP访问系统。\n后续的功能测试均在该部署完成的温湿度监测系统上进行。\n5.2 功能测试 该部分将对各功能模块进行效果呈现。\n5.2.1 主页视图 主页视图如图5.1所示。其中显示了连接设备数目、数据总条目数、平均温度、平均湿度、异常温度条数、异常湿度条数的概览信息，同时也提供了各设备实时温度的数值与简易视图，便于进行一些简单信息的查阅。\n【图5.1 系统主页视图效果展示】\n5.2.2 动态视图 数据分析模块中进行了动态视图的显示，由于环境室温较为稳定，难以看出视图的动态性，因此考虑变化硬件节点的所处环境，可以看到数据发生了明显变化，但略延迟于实际时间点约1s左右，这部分延迟来自于传感节点的信息发布周期以及信息发布、获取所消耗的时间。视图效果如图5.2所示。\n除此之外可以看到视图中展示了阈值范围与平均温度线，便于进行数据的监测与进一步的分析。\n【图5.2 动态视图效果展示】\n5.2.3 报表导出 对于历史数据模块，呈现了所有存储于数据库中的温湿度信息，并记录了其来源设备、具体时间等信息，同时也告知用户总共的数据条数，该数据与系统主页中呈现的一致。点击”导出报表“按钮，系统会自动下载一个Excel文件，其中包含了所有的温湿度信息，如图5.3所示；点击”导出异常数据“按钮，系统会自动下载一个额外的Excel文件，其中内容如图5.4所示，Excel中包含了具体的时间、来源设备、温湿度信息、实际状态与正常的温湿度范围，以供使用者进行异常分析的参考。\n【图5.3 所有数据信息的报表导出】\n【图5.4 异常数据的导出】\n5.2.4 设备管理 设备管理模块中，由用户自行进行设备的添加，同时也可以进行基本的设备信息修改与删除操作，其中设备的修改界面如图5.5所示，其中设备ID、设备型号、设备状态、数据条数等内容不允许进行修改，用户仅能够进行设备描述的内容修改以及温湿度阈值上下限的修改。\n当完成对上下限修改后，该设备所对应的动态报表中的阈值返回以及异常判断标准也会随着发生改变。需注意设备ID会与实际硬件烧录中的ID信息一一对应。\n【图5.5 设备的信息修改】\n5.3 效果分析 通过一系列的功能测试，效果符合需求分析中的各项功能要求，由于MQTT服务器为自我搭建且与后端代码、数据库等部件位于同一台云服务器中，运行效率较高，且硬件通过NB-IoT进行联网，信息传输稳定且受地域干扰较小。本次课程设计的开发在功能实现层面体现了一定的复杂性与较高的可用性，符合预期。\n6. 心得与体会 在这次的项目设计中，我们团队获得了丰富的物联网开发经验，取得了一系列可喜的成果。首先，通过对ESP8266的编程、ArduinoIDE的灵活运用以及各类传感器模块的巧妙连接，我们深刻理解并掌握了物联网设备的开发技巧。这使得我们能够高效地实现温湿度监测系统的硬件层面，充分发挥了各种传感器的功能，为系统的数据采集提供了可靠的基础。\n无线监测节点的设计为本次课设设计的重点，这一部分工作涉及到ESP8266、SIM7020模块以及DHT22模块的协同工作，为系统的NBIoT联网和MQTT服务器连接提供了可靠的基础。\n首先，通过ESP8266的灵活编程，我们成功实现了监测节点的智能控制和数据处理功能。ESP8266作为微控制器，不仅令我们熟悉了硬件编程的精要，还为监测节点的智能化提供了可靠支持。其次，我们选用SIM7020模块，通过它实现了NBIoT的联网操作。这一步骤是整个监测系统的关键，使得监测节点能够远程连接至云端，实现了数据的远程传输。SIM7020模块的低功耗、高效性能为我们的系统提供了可靠的网络通信能力。同时，我们结合DHT22模块，实现了对环境温湿度信息的高精度采集。DHT22模块通过数字信号输出，为监测系统提供了可靠的环境数据，使得我们的智能监测节点能够更全面地感知环境的变化。最终，通过MQTT服务器的连接，我们成功将监测节点获取的数据整合并发送至云端。这不仅实现了监测功能，也为整个系统提供了远程信息采集的强大功能。通过这一设计，我们深刻体会到了无线监测节点在智能系统中的关键作用，以及其对于物联网应用的不可或缺性。\n在软件方面，我们成功地熟悉和掌握了前后端的开发技巧。通过使用Visual Studio Code和ArduinoIDE，我们能够迅速进行前端代码的编写和硬件代码的烧录，确保系统的复杂功能能够被可靠实现。与此同时，对于后端的开发，我们通过使用IDEA，成功搭建了一个功能强大的系统后台，实现了数据的处理、存储和管理。这为系统的稳健性和可用性提供了有力的支持。\n服务器的搭建是我们团队在这次设计中的一项关键任务。我们成功地配置了云服务器，安装了数据库，并搭建了MQTT服务器进行消息的汇总和传递。这一系列操作不仅加深了我们对服务器架构的理解，也为系统的远程通信提供了坚实的基础。通过这一过程，我们对于云计算和物联网的结合有了更深刻的认识。\n总的来说，这次课程设计不仅让我们掌握了丰富的技术知识，更锻炼了我们解决问题的能力。我们学会了发现并解决各种工程开发中可能遇到的问题，培养了团队协作和沟通的能力。最终，我们能够顺利完成课程设计的要求，这不仅是对我们所学知识的巩固，也是对我们工程开发能力的一次全面提升。这次设计不仅是知识的积累，更是团队协作和实践的宝贵经验。\n"},{"section":"Blog","slug":"/en/blog/diffusion/","title":"【学习笔记】扩散模型的基本原理与训练方法","description":"this is meta description","date":"December 14, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/diffusion/process_hucaeaf4e39aab7718665e67c263b83e8d_100488_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"77\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/diffusion\\/process_hucaeaf4e39aab7718665e67c263b83e8d_100488_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/diffusion/process_hucaeaf4e39aab7718665e67c263b83e8d_100488_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/diffusion\\/process_hucaeaf4e39aab7718665e67c263b83e8d_100488_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 学习笔记","tags":"扩散模型, 图像生成","content":"1. Diffusion前向过程 给定采样自数据集的真实图片$x_0 \\sim q(x)$，并对其添加高斯噪声，共进行$T$步，称该过程为$q$过程，能够得到添加噪声后的图片分布$x_1,x_2,\u0026hellip;,x_T$。\n将加噪的过程看作一个马尔可夫过程，即$t$时刻的状态只与$t-1$时刻有关，设置超参数$\\beta_t \\in (0,1), t\\in(1,T)$ ，本质上该超参数即为每一时刻下添加的高斯分布的方差。至此可以将该前向$q$过程写成以下形式，表示在$x_{t-1}$满足的分布前提下，$x_{t}$的方差为$\\beta_t$，均值则受到了前一个状态的影响。 $$ q(x_t|x_{t-1})=\\mathcal N(x_t;\\sqrt{1-\\beta_t}x_{t-1},\\beta_t \\mathbf{I}) $$ 实际场景中，$\\beta$是随着$t$的增大而递增的，那么当$t$很大时，$\\beta_t$ 趋近于1，则$x_t$满足的分布接近于标准正态分布。【$\\beta_t$这一超参数的存在本质是描述方差，但却在均值上乘上了$\\sqrt{1-\\beta_t}$，这能够使得均值在$t$很大的时候趋向于0，整个分布则为标准正态分布。】\n由于以上过程看作一个马尔可夫过程，因此根据乘法公式可以写出以下表达式： $$ q(x_{1:T}|x_0)=\\prod_{t=1}^{T}q(x_t|x_{t-1}) $$\n重参数技巧（reparameterization trick） 以上前向的$q$过程的表达形式是采样形式的，表示在某个分布中进行随机采样，这回导致过程有随机性，无法反向传播梯度，为了使该采样过程变得可导，使用冲参数技巧，引入一个固定的随机变量$\\epsilon$实现。\n例如需要进行以下采样：$z \\sim \\mathcal N (z;\\mu_\\theta,\\sigma_{\\theta}^{2}\\mathbf{I})$，可以写成：$z=\\mu_{\\theta}+\\sigma_{\\theta}\\odot\\epsilon$，这样的话$z$依旧是一个随机变量，但对于$\\mu_{\\theta}$和$\\sigma_{\\theta}$等含有网络参数的参数，能够通过$z$进行梯度的求取，随机性完全来自于固定不变服从标注正态分布的$\\epsilon $中了。\n那么对于原先的$q$过程，可以使用重参数技巧重写$x_t$，即： $$ x_t=\\sqrt{1-\\beta_t}x_{t-1}+\\sqrt{\\beta_t}z，z \\sim \\mathcal N (0,\\mathbf{I}) $$\n使用统一的方法表示$x_t$ 由于上述扩散过程是一步步进行的，为了能够快速得到$x_t$，考虑使用$x_0$和$\\beta$进行统一表示。\n首先假设$\\alpha_t=1-\\beta_t$，并记$\\overline{\\alpha_t}=\\prod_{i=1}^{T}\\alpha_i$。\n则对$x_t$有以下推导过程：\n$$ \\begin{aligned} %aligned命令对齐，在对齐的地方用\u0026quot;\u0026amp;\u0026quot; x_t \u0026amp;=\\sqrt{\\alpha_t}x_{t-1}+\\sqrt{1-\\alpha_t}z_1 \\\\ \u0026amp;=\\sqrt{\\alpha_t}(\\sqrt{\\alpha_{t-1}}x_{t-2}+\\sqrt{1-\\alpha_{t-1}}z_2)+\\sqrt{1-\\alpha_t}z_1 \\\\ \u0026amp;=\\sqrt{\\alpha_t \\alpha_{t-1}}x_{t-2}+\\sqrt{\\alpha_t(1-\\alpha_{t-1})}z_2+\\sqrt{1-\\alpha_t}z_1 \\\\ \u0026amp;=\\sqrt{\\alpha_t \\alpha_{t-1}}x_{t-2}+\\sqrt{1-\\alpha_t \\alpha_{t-1}}\\overline{z_2} \\\\ \u0026amp; \u0026hellip; \\\\ \u0026amp;=\\sqrt{\\overline{\\alpha_t}}x_0+\\sqrt{1-\\overline{\\alpha_t}}\\ \\overline{z_t} \\end{aligned} $$\n其中对于$\\sqrt{\\alpha_t(1-\\alpha_{t-1})}z_2+\\sqrt{1-\\alpha_t}z_1=\\sqrt{1-\\alpha_t \\alpha_{t-1}}\\overline{z_2}$的推导过程，有以下分析：\n$$ \\sqrt{\\alpha_t(1-\\alpha_{t-1})}z_2 \\sim \\mathcal N(0,\\alpha_t(1-\\alpha_{t-1})\\mathbf{I}) \\\\ \\sqrt{1-\\alpha_t}z_1 \\sim \\mathcal N (0,(1-\\alpha_t)\\mathbf{I}) \\\\ \\sqrt{\\alpha_t(1-\\alpha_{t-1})}z_2+\\sqrt{1-\\alpha_t}z_1 \\sim \\mathcal N(0,(1-\\alpha_t \\alpha_{t-1})\\mathbf{I}) \\\\ $$\n对于得到的混合高斯分布$\\mathcal N(0,(1-\\alpha_t \\alpha_{t-1})\\mathbf{I})$，可以表达为$\\sqrt{1-\\alpha_t \\alpha_{t-1}}\\overline{z_2}$，对于$\\overline{z_2}$依然服从的是标准高斯分布。\n综上，对于$x_t$的表达式形式为$x_t=\\sqrt{\\overline{\\alpha_t}}x_0+\\sqrt{1-\\overline{\\alpha_t}}z$，采样形式为$q(x_t|x_0) \\sim \\mathcal N(x_t;\\sqrt{\\overline{\\alpha_t}}x_0,(1-\\overline{\\alpha_t})\\mathbf{I})$。可以看成原始图片与高斯噪声的加权求和结果。\n2. Diffusion逆向推断 该过程可以看成前向$q$过程的逆过程，即去噪过程。目前在这里我们已知所有的前向过程$q(x_t|x_{t-1})$，想要从标准正态分布中逐步去噪得到最终的原图分布，即从$x_T$得到$x_0$，那么就需要知道$q(x_{t-1}|x_t)$。但这是十分困难的，因此考虑使用深度神经网络来对该分布进行预测，即训练一个模型使其能够做到$p_{\\theta}(x_{t-1}|x_t)$。【即让神经网络去学习去噪的过程】\n对于$p_{\\theta}(x_{t-1}|x_{t})$，写成正态分布的表达形式，即为下式，可以看到我们需要使网络根据$x_t$和$t$学习得到分布的均值与方差。\n$$ p_{\\theta}(x_{t-1}|x_t)=\\mathcal N (x_{t-1};\\mu_{\\theta}(x_t,t),\\Sigma_{\\theta}(x_t,t)) $$\n虽然$q(x_{t-1}|x_t)$难以直接得到，但是可以引入已知的原图像分布$x_0$的先验知识，尝试得到$q(x_{t-1}|x_t,x_0)$，可以进行以下过程推导：\n$$ \\begin{aligned} q(x_{t-1}|x_t,x_0)\u0026amp;=\\frac{q(x_{t-1},x_{t},x_{0})}{q(x_t,x_0)} \\\\ \u0026amp;=\\frac{q(x_{t-1},x_t,x_0)}{q(x_{t-1},x_0)}\\frac{q(x_{t-1},x_0)}{q(x_t,x_0)} \\\\ \u0026amp;=q(x_t|x_{t-1},x_0)\\frac{\\frac{q(x_{t-1},x_0)}{q_{x_0}}}{\\frac{q(x_t,x_0)}{q_{x_0}}}\\\\ \u0026amp;=q(x_t|x_{t-1},x_0)\\frac{q(x_{t-1}|x_0)}{q(x_t|x_0)} \\end{aligned} $$\n由此将加入先验知识的逆向分布转换为正向分布的表达式。\n对于几个前向过程进行表达式说明：\n$$ q(x_{t-1}|x_0)=\\sqrt{\\overline{\\alpha_{t-1}}}x_0+\\sqrt{1-\\overline{\\alpha_{t-1}}}z \\sim \\mathcal N (\\sqrt{\\overline{\\alpha_{t-1}}}x_0,1-\\overline{\\alpha_{t-1}}) \\\\ q(x_{t}|x_0)=\\sqrt{\\overline{\\alpha_{t}}}x_0+\\sqrt{1-\\overline{\\alpha_{t}}}z \\sim \\mathcal N (\\sqrt{\\overline{\\alpha_{t}}}x_0,1-\\overline{\\alpha_{t}}) $$\n由于$q$过程是马尔可夫过程，则有：\n$$ q(x_t|x_{t-1},x_0)=q(x_t|x_{t-1})=\\sqrt{\\alpha_{t}}x_{t-1}+\\sqrt{1-\\alpha_{t}}z \\sim \\mathcal N (\\sqrt{\\alpha_{t}}x_{t-1},1-\\alpha_{t}) $$\n而对于高斯分布，我们能够使用概率密度函数的形式进行表达，即：$\\mathcal N(\\mu,\\sigma^2)\\propto exp(-\\frac{(x-\\mu)^2}{2\\sigma^2})$，则考虑使用概率密度函数描述$q(x_{t-1}|x_0)、q(x_t|x_0)、q(x_t|x_{t-1},x_0)$，如下表达式所示：\n$$ q(x_{t-1}|x_0)\\propto exp(-\\frac{(x_{t-1}-\\sqrt{\\overline{\\alpha_{t-1}}}x_0)^2}{2(1-\\overline{\\alpha_{t-1}})}) \\\\ q(x_{t}|x_0)\\propto exp(-\\frac{(x_{t}-\\sqrt{\\overline{\\alpha_{t}}}x_0)^2}{2(1-\\overline{\\alpha_{t}})}) \\\\ q(x_t|x_{t-1},x_0)\\propto exp(-\\frac{(x_{t}-\\sqrt{\\alpha_{t}}x_{t-1})^2}{2(1-\\alpha_{t})}) $$\n则最终可以表达$q(x_{t-1}|x_t,x_0)$，如下推导所示。由于$q(x_{t-1}|x_t,x_0)$是关于$x_{t-1}$的表达式，则需要进行同类相合并\n$$ \\begin{aligned} q(x_{t-1}|x_t,x_0) \u0026amp;=q(x_t|x_{t-1},x_0)\\frac{q(x_{t-1}|x_0)}{q(x_t|x_0)} \\\\ \u0026amp;\\propto exp(-\\frac{(x_{t-1}-\\sqrt{\\overline{\\alpha_{t-1}}}x_0)^2}{2(1-\\overline{\\alpha_{t-1}})}) + exp(-\\frac{(x_{t}-\\sqrt{\\alpha_{t}}x_{t-1})^2}{2(1-\\alpha_{t})}) - exp(-\\frac{(x_{t}-\\sqrt{\\overline{\\alpha_{t}}}x_0)^2}{2(1-\\overline{\\alpha_{t}})}) \\\\ \u0026amp;=exp(-\\frac{1}{2}(\\frac{(x_{t-1}-\\sqrt{\\overline{\\alpha_{t-1}}}x_0)^2}{1-\\overline{\\alpha_{t-1}}}+\\frac{(x_{t}-\\sqrt{\\alpha_{t}}x_{t-1})^2}{1-\\alpha_{t}}-\\frac{(x_{t}-\\sqrt{\\overline{\\alpha_{t}}}x_0)^2}{1-\\overline{\\alpha_{t}}})) \\\\ \u0026amp;=exp(-\\frac{1}{2}((\\frac{\\alpha_t}{1-\\alpha_t}+\\frac{1}{1-\\overline{\\alpha_{t-1}}})x_{t-1}^2-(\\frac{2\\sqrt{\\alpha_t}}{1-\\alpha_t}x_t+\\frac{2\\sqrt{\\overline{\\alpha_{t-1}}}}{1-\\overline{\\alpha_{t-1}}}x_0)x_{t-1}+C(x_t,x_0))) \\end{aligned} $$\n其中$C(x_t,x_0)$不含$x_{t-1}$。\n考虑到对于概率密度的表达式，可以进行展开操作，即$\\mathcal N(\\mu,\\sigma^2)\\propto exp(-\\frac{(x-\\mu)^2}{2\\sigma^2})=exp(-\\frac{1}{2}(\\frac{1}{\\sigma^2}x^2-\\frac{2\\mu}{\\sigma^2}x+\\frac{\\mu^2}{\\sigma^2}))$，与$q(x_{t-1}|x_t,x_0)$的表达式一一对应可知。\n$$ \\frac{1}{\\sigma^2}=\\frac{\\alpha_t}{1-\\alpha_t}+\\frac{1}{1-\\overline{\\alpha_{t-1}}} \\\\ \\sigma^2 =\\frac{(1-\\alpha_t)(1-\\overline{\\alpha_{t-1}})}{\\alpha_t(1-\\overline{\\alpha_{t-1}})+(1-\\alpha_t)}=\\frac{\\beta_t(1-\\overline{\\alpha_{t-1}})}{\\alpha_t(1-\\overline{\\alpha_{t-1}})+\\beta_t} \\\\ =\\frac{1-\\overline{\\alpha_{t-1}}}{1-\\overline{\\alpha_t}}\\beta_t $$\n对于均值，有求得表达式：\n$$ \\frac{2\\mu}{\\sigma^2}=\\frac{2\\sqrt{\\alpha_t}}{1-\\alpha_t}x_t+\\frac{2\\sqrt{\\overline{\\alpha_{t-1}}}}{-\\overline{\\alpha_{t-1}}}x_0 \\\\ \\mu=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}x_0 $$\n至此，我们在加入$x_0$的先验知识后，能够描述出分布$q(x_{t-1}|x_t,x_0)$的均值和方差的表达式，即\n$$ \\mu=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}x_0 \\\\ \\sigma^2=\\frac{1-\\overline{\\alpha_{t-1}}}{1-\\overline{\\alpha_t}}\\beta_t $$\n但实际上我们需要通过神经网络来训练出一个分布$p_{\\theta}(x_{t-1}|x_t)$，该分布的均值和方差均是含参数的，即上述的$\\mu_{\\theta}(x_t,t)$与$\\Sigma_{\\theta}(x_t,t)$。我们考虑使用$q(x_{t-1}|x_t,x_0)$来近似估计$p_{\\theta}(x_{t-1}|x_t)$，这显然是可行的，因为$x_t$可以由$x_0$来表示，同理也可以使用$x_t$来表示$x_0$。综上可得以下关于均值和方差的表达式：\n$$ \\mu_{\\theta}(x_t,t)=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}x_0 \\\\ \\Sigma_{\\theta}(x_t,t)=\\frac{1-\\overline{\\alpha_{t-1}}}{1-\\overline{\\alpha_t}}\\beta_t $$\n对于其中出现的先验知识$x_0$，考虑使用$x_t$来表达，即有： $$ x_0=\\frac{x_t-\\sqrt{1-\\overline{\\alpha_t}}z}{\\sqrt{\\overline{\\alpha_t}}} $$ 代入均值$\\mu_{\\theta}(x_t,t)$的表达式，有以下推导过程：\n$$ \\begin{aligned} \\mu_{\\theta}(x_t,t)\u0026amp;=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}x_0 \\\\ \u0026amp;=\\frac{\\sqrt{\\alpha_t}(1-\\overline{\\alpha_{t-1}})}{1-\\overline{\\alpha_{t}}}x_t+\\frac{\\sqrt{\\overline{\\alpha_{t-1}}}\\beta_t}{1-\\overline{\\alpha_t}}\\frac{x_t-\\sqrt{1-\\overline{\\alpha_t}}z}{\\sqrt{\\overline{\\alpha_t}}} \\\\ \u0026amp;=\\frac{1}{\\sqrt{\\alpha_t}}(x_t-\\frac{1-\\alpha_t}{\\sqrt{1-\\overline{\\alpha_t}}}z) \\end{aligned} $$\n观察表达式可以发现，$\\alpha_t$、$x_t$、$\\overline{\\alpha_t}$均为已知量，模型需要确定$\\mu_{\\theta}(x_t,t)$，本质上是个噪声预测的过程，即对于上式中的$z$，需要交给神经网络去预测，记为$z_{\\theta}(x_t,t)$。\n综上，反向去噪过程可以概括为：\n根据$x_t$和$t$预测高斯噪声$z_{\\theta}(x_t,t)$，则能够得到模型预测的去噪后的分布均值$\\mu_{\\theta}(x_t,t)$，其实就是去噪后的图像。 得到方差$\\Sigma_{\\theta}(x_t,t)$，在DDPM中方差是untrained的，即$\\Sigma_{\\theta}(x_t,t)=\\frac{1-\\overline{\\alpha_{t-1}}}{1-\\overline{\\alpha_t}}\\beta_t$，但对于方差也可以进行训练估计。 $p_{\\theta}(x_{t-1}|x_t)=\\mathcal N (x_{t-1};\\mu_{\\theta}(x_t,t),\\Sigma_{\\theta}(x_t,t))$进行去噪，获得$x_{t-1}$，通过重参数技巧。 3. 训练方式与策略 常规的训练流程 从数据集中采样得到$x_0$，$x_0 \\sim q(x)$，并在$1\u0026hellip;T$中随机采样一个 $t$。 从标准高斯分布中采样一个噪声$z\\sim \\mathcal N (0,\\mathbf{I})$。 根据重参数技巧得到$x_t=\\sqrt{\\overline{\\alpha_t}}x_0+\\sqrt{1-\\overline{\\alpha_t}}z$。 训练UNet，输入$x_t$和$t$，模型输出$z_{\\theta}(x_t,t)$，将$z_{\\theta}(x_t,t)$和$z$做Loss。 推理流程 从标准高斯分布中采样得到一个噪声$x_t \\sim \\mathcal N(0,\\mathbf{I})$。 从$T$到1遍历变量$t$，如果$t==1$则$z=0$，否则采样噪声$z\\sim\\mathcal N(0,\\mathbf{I})$。 UNet推理得到$z_\\theta(x_t,t)$，进行去噪$x_{t-1}=\\frac{1}{\\sqrt{\\overline{\\alpha_t}}}(x_t-\\frac{1-\\alpha_t}{\\sqrt{1-\\overline{\\alpha_t}}}z_{\\theta}(x_t,t))+\\Sigma_{\\theta}(x_t,t)z$。 得到$x_0$。 4. Diffusion的应用拓展 Diffusion做分割（SegDiff） 要点：将待分割图像作为condition image进行特征的提取，在进入UNet之前进行特征的融合，扩散生成的为mask。\n训练$\\mu_{\\theta}(x_t,t)$时，需要加入图像的特征，即$\\mu_{\\theta}(x_t,t,I)$，推理时同理。\n"},{"section":"Blog","slug":"/en/blog/labrecordsegmentation/","title":"【实验记录】优化3D医学影像分割","description":"this is meta description","date":"December 14, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/labrecord%28seg%29/image-1_huf385e90b7d0bb22ff4ea1358d314e01f_26835_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"243\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/labrecord(seg)\\/image-1_huf385e90b7d0bb22ff4ea1358d314e01f_26835_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/labrecord%28seg%29/image-1_huf385e90b7d0bb22ff4ea1358d314e01f_26835_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/labrecord(seg)\\/image-1_huf385e90b7d0bb22ff4ea1358d314e01f_26835_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 实验记录","tags":"光流估计, 实验记录, 图像分割, 扩散模型","content":"【实验记录】优化三维医学影像分割不连续性问题 整体问题 考虑三维医学影像（如CT影像等），常规分割方法将其分割成多片（后面都称为“帧”）二维影像，并对每一帧进行独立分割，这会导致分割的不连续性；若整体三维影像进行分割，则计算量较大。因此考虑寻找一种方法，能够在保证较小计算量的情况下使分割结果具有连贯性。\n2023年12月：在UNet中的CropAndCat过程中引入Optical Flow 方案思考 考虑以下过程：$(I_1, I_2)\\rightarrow Mask_2$，$I_2$的Decoder过程需要带上$I_1$的Encoder过程中的多尺度的特征，考虑最简单的一个方法，计算$Flow(I_1,I_2)$后，对于$I_1$的Encoder的多尺度特征，使用该Flow进行Warp，并与$I_2$经过Encoder后得到的多尺度特征进行特征融合，最后再进行Decoder得到$I_2$的Mask。\n实验准备 复现几种常用的光流估计网络：FlowNet-C、FlowNet-S、SPY-Net、RAFT、DIP； 数据集准备：外场景视频分割（DAVIS）、心脏分割（Cardiac） 实验记录与问题 要单独使用一些Flow计算网络进行Flow的计算，需要先在特定数据集上进行Flow计算网络的训练，或使用SPY-Net的训练结果。\n（直接计算多尺度的flow对前帧特征进行warp后融合，然后再Decoder），部分单语义分割（0/1）数据集训练效果还行，具体指标还没与传统的UNet相比，多跑几个epoch目测效果较好。对多语义数据集效果差（用传统UNet也不行）\n有些数据集的光流计算效果就很差，一些帧数比较低的图片前后帧关联较小。（这样来看是不是运用在3D医疗图像的切片上会比较合适，前后帧关联性较大）\nCT影像的特征信息远小于外场景的一些视频，光流估计难度挺大的，且将CT影像的每一片图片看作相邻帧是否欠妥？\n依然存在Encoder的计算过程，该部分计算量仍然存在，同时引入了两帧Flow的计算时间，但精度有所提升？\n对特征进行warp操作以减少重复计算，是否类似于对mask直接进行warp？（解码前后差异）\n如果前后帧的差异较大，即帧率较低的情况下，flow的准确度不高（考虑一下此时减少flow来的feature的影响）\n是不是可以引入类似GRU的网络结构，考虑前面所有帧对当前帧mask产出的辅助。\n2024年2月：尝试将Flow估计过程和UNet的推理过程进行融合 方案思考 细化前一个版本的过程，光流计算的过程是否可以与UNet网络进行融合，考虑引入SPY-Net类似的网络结构，在分割的过程中进行光流网络的计算，对于光流网络，也具有UNet的编码过程中的多尺度的特征了，可能会有利于网络训练，但需要进行深监督，或者多尺度的深度监督，使得Flow部分的网络的收敛方向是一个能够使特征在帧间转移的结果。\n实验记录与问题 （多尺度生成Flow的同时去使用Flow来warp特征，需要进行深度监督），V2中的这种使用深度网络训练光流残差的方法，一般都是分层去训练各自的深度网络G，但这样就变成了先去训练光流生成网络再使用这个网络生成多尺度光流来进行对特征的warp，两个模块分开了，便失去了意义。 如果是端到端训练，这个方法训练起来及其麻烦且漫长，也不知道可不可行，更不清楚在哪个数据集下好用（有些数据集拿来直接生成flow都不太行，生成用来监督的flow就比较困难） 尝试去改一些融合方式，想着去把生成光流这件事和Encoder结合起来，目前没有什么idea，缺少一种合适的融合光流生成与Encoder的方法。有待进一步思考。 思考带有循环结构的网络。必要前提：有多尺度的flow，以融合前帧特征的影响；存在问题：flow难以进行多尺度的融合计算（还没想到合适的方法），对feature进行share 使用多尺度下的GRU？ 无法避免特征计算，但这个思路也是在前面的基础上进一步改的，光流的生成还是个问题。 始终似乎只有UNet网络在对分割结果做贡献，发现某些分割结果较差的帧甚至会将差的分割结果带到相邻帧去。 2024年3月：使用Diffuse进行分割并考虑去噪过程中引入相邻帧的信息 方案思考 先考虑一个最常规的思路，将多条独立的去噪线路进行融合，例如有以下过程$(x_t^{i},x_t^{i+1})\\rightarrow x_{t-1}^i$，依然尝试寻找一种机制能够使得相邻帧的特征或者信息带到当前帧来，以对分割结果进行优化，例如光流。。先尝试最简单的去噪过程的融合。\n实验准备 跑通基于improved diffusion的SegDiff代码 实验记录与问题 对于带噪的某一帧进行warp，这本质上是一个非线性变换，相当于会对噪声的实际分布产生变化，更如果两帧不是同一个高斯噪声呢？不再是一个高斯分布，这是不是会影响整个去噪效果？有没有一种机制，能够将邻帧特征带过来并且不会影响这种带噪的特性。 是不是可以理解SegDiff的过程为，对于同一个高斯噪声，给与不同的Conditional Image，就能够得到基于这个Conditional Image的Mask，如果这是正确的话似乎也可以进行下一步工作。 Diffusion的计算量太大了，一次代码要跑十天，考虑重写代码？ 方案似乎没有太大的创新性。 2024年4月：考虑某一帧去噪得到相邻帧的过程-多向Diffusion 方案思考 既然有以下过程$(x_t^{i},x_t^{i+1})\\rightarrow x_{t-1}^i$，那么是否可以考虑简化一下，得到$x_t^{i+1}\\rightarrow x_{t-1}^i$。这样的话，相当于对于任意一帧的某一去噪时刻来说，都能够具有去噪得到相邻帧的能力，那么这样的话扩散的过程可以是多向的（三种方向），那么是不是可以考虑多种方向多种扩散策略得到的多种结果进行vote，最后以优化分割结果。\n考虑引入一个中间态，继续使用光流将特征进行转移，但依旧会存在非线性变换的问题，考虑引入假设？相邻帧的特征变化较小，实际上经过Flow的Warp并不会对含噪图片的噪声分布具有太大的影响。同样的，光流网络可以使用一种别的深度网络来估计两帧之间的差异。\n这样来说训练策略会很多，例如先分别独立进行去噪网络和差异估计网络的训练，在原数据集上进行去噪训练，基于mask进行差异估计网络的训练；或者在得到差异网络后使用中间态去进行去噪网络的训练；端到端训练+深度监督差异网络；纯粹的端到端+知识蒸馏（使用前一个特征融合版本的去噪网络进行蒸馏）\n实验准备 A6000环境配置 Baseline、单纯融合、多种训练模式的代码编写 实验记录与问题 结果似乎并不比Baseline高多少。 对于CT影像来说，一些边缘（或者是单帧图像中正例很少的情况）的分割效果很差，这是对于小目标的分割，甚至F1指数小于20，而对于中间的大范围分割，约为97分，但这也导致了整体的分割分数比较低，约为70。。。 疑问，使用Diffusion进行小目标分割怎么会使得效果更好，类似于Focal Loss的损失函数更换？ 解决方案是不是过于复杂了，如果单帧分割足够精确，还需要再去考虑相邻帧之间的关联性吗？ 2024年5月：使用Auto-Encoder增大UNet中最低尺度的特征图涵盖信息的能力 "},{"section":"Blog","slug":"/en/blog/lagrange-multipiler/","title":"【泛学内容】拉格朗日乘子法求解带约束的优化问题","description":"this is meta description","date":"December 2, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/Lagrange/image-1_huf60a259aeee080a9aa1a0bc3eb400074_34139_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"437\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/Lagrange\\/image-1_huf60a259aeee080a9aa1a0bc3eb400074_34139_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/Lagrange/image-1_huf60a259aeee080a9aa1a0bc3eb400074_34139_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/Lagrange\\/image-1_huf60a259aeee080a9aa1a0bc3eb400074_34139_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"数学相关, 泛学内容","tags":"高等数学, 最优化问题, 拉格朗日乘子法","content":"拉格朗日乘子法 用于求解约束条件下的极值问题，是SVM的理论基础。\n一、简单例子引入 求解以下优化问题： $$ \\begin{aligned} \u0026amp;min \\ f(x_1,x_2)=x_1^2+x_2^2 \\\\ \u0026amp;st.\\ x_1+x_2 = 2 \\end{aligned} $$ 使用函数$g(x_1,x_2)=x_1+x_2-2$来描述约束条件，则$g(x_1,x_2)=0$。\n引入拉格朗日乘子$\\lambda$，构造一个新函数$h(x_1,x_2)=f(x_1,x_2)+\\lambda g(x_1,x_2)$。很显然$h(x_1,x_2)=f(x_1,x_2)$，因此要求$f(x_1,x_2)$的最小值，即求$h(x_1,x_2)$的最小值，则令梯度为0，表达式如下： $$ \\frac{\\partial h(x_1,x_2)}{\\partial x_1}=\\frac{\\partial f(x_1,x_2)}{\\partial x_1}+\\lambda \\frac{\\partial g(x_1,x_2)}{\\partial x_1}=2x_1+\\lambda=0 \\\\ \\frac{\\partial h(x_1,x_2)}{\\partial x_2}=\\frac{\\partial f(x_1,x_2)}{\\partial x_2}+\\lambda \\frac{\\partial g(x_1,x_2)}{\\partial x_2}=2x_2+\\lambda=0 \\\\ \\tag{1} $$ 则有以下等式组: $$ 2x_1+\\lambda =0 \\\\ 2x_2+\\lambda =0 \\\\ x_1+x_2-2=0 \\tag{2} $$ 求解得到结果为$\\lambda=-2，x_1=x_2=1$，则表示$f(x_1,x_2)$在$x_1=x_2=1$时取得最小值，值为2。\n二、几何简介 对于约束函数$g(x_1,x_2)=0$，即可以看作一条直线，最终$x_1,x_2$的取值要满足在这条直线上。对于$f(x_1,x_2)$，其取任意值都有一个圆与之对应（类似于等高线），例如下图中红线代表$f(x_1,x_2)=1$的所有$x_1$和$x_2$的取值点。\n因此在约束条件下$f(x_1,x_2)$若能够取到某个值$d$，则对应的$x_1,x_2$则为圆$f(x_1,x_2)=d$与$g(x_1,x_2)=0$的交点。\n显而易见的是：当圆$f(x_1,x_2)=d$与$g(x_1,x_2)=0$相切时，此时$d$ 为能取到的最小值，同时交点即为对应的自变量值。此时两个函数的梯度方向相同，但是值不一定相当，是成比例的。\n对于$f(x_1,x_2)$在该点的梯度，即为$(\\frac{\\partial f(x_1,x_2)}{\\partial x_1},\\frac{\\partial f(x_1,x_2)}{\\partial x_2})$，对于$g(x_1,x_2)$在该点的梯度，即为$(\\frac{\\partial g(x_1,x_2)}{\\partial x_1},\\frac{\\partial g(x_1,x_2)}{\\partial x_2})$。\n这里引入了乘子$\\lambda$，是一个比例系数，则有（3）式子，该式子显然与（1）一致。 $$ \\frac{\\partial f(x_1,x_2)}{\\partial x_1}=\\lambda \\frac{\\partial g(x_1,x_2)}{\\partial x_1} \\\\ \\frac{\\partial f(x_1,x_2)}{\\partial x_2}=\\lambda \\frac{\\partial g(x_1,x_2)}{\\partial x_2} \\\\ \\tag{3} $$\n三、带等式约束的最优化问题 有多个等式约束的多元函数优化问题，表达如下\n$$ min \\ f(x_1,x_2,\u0026hellip;,x_n) \\\\ s.t. \\left\\{ \\begin{aligned} \u0026amp;g_1(x_1,x_2,\u0026hellip;,x_n) = 0 \\\\ \u0026amp;g_2(x_1,x_2,\u0026hellip;,x_n) = 0 \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;g_m(x_1,x_2,\u0026hellip;,x_n) = 0 \\end{aligned} \\right. \\tag{4} $$\n则令$L(x_1,x_2,\u0026hellip;,x_n;\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n)=f+\\lambda_1 g_1 + \\lambda_2 g_2+\u0026hellip;+\\lambda_n g_n=f+\\sum_{i=1}^{m} \\lambda_i g_i \\ (\\lambda_i\\in \\mathbf{R})$。\n最小化$L$，得到最优解$x^*=(x_1^*,x_2^*,\u0026hellip;,x_n^*)^T$的必要条件(KKT)如下。共$m$个约束加上$n$个梯度分量为0带来的方程。\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla_xL=\\nabla_xf+\\sum_{i=1}^{m}\\lambda_i \\nabla_x g_i = 0 \\\\ \u0026amp;g_i=0 \\end{aligned} \\right. \\tag{5} $$\n三、带不等式约束的最优化问题 约束变成不等式实际上相当于可行域从一条直线变成了一个区域，记为$g(x)\u0026lt;0$，可以分两种情况进行讨论。\n最优点处于约束区域边界 这种情况相当于$g$所对应的区域没有覆盖住$f$的梯度最低点，那么只能退而求其次在$g$的边界处取得最优点。\n这时候$g$和$f$的梯度方向是必然相反的，那么就存在一个缩放因子$\\lambda\u0026gt;0$，使得$\\nabla f+\\lambda \\nabla g=0$，因此最优解条件可以写成以下形式（以二维为例）：\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla L(x_1,x_2,\\lambda)=\\nabla f(x_1,x_2)+\\lambda \\nabla g(x_1,x_2) = 0 \\\\ \u0026amp;\\lambda \u0026gt;0 \\\\ \u0026amp;g(x_1,x_2)=0 \\end{aligned} \\right. \\tag{6} $$\n最优点处于约束区域内部 这种情况相当于$g$所对应的区域完全覆盖住$f$的梯度最低点，最优点显然处于$f$的梯度最低点，相当于$g$没有起任何约束，只需要依靠$\\nabla f = 0$求得最优点。\n为了统一形式可以写成以下条件组。\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla L(x_1,x_2,\\lambda)=\\nabla f(x_1,x_2)+\\lambda \\nabla g(x_1,x_2) = 0 \\\\ \u0026amp;\\lambda =0 \\\\ \u0026amp;g(x_1,x_2)\u0026lt;0 \\end{aligned} \\right. \\tag{7} $$\n合并上述情况 最终的式子都可以写成$\\nabla f(x_1,x_2)+\\lambda \\nabla g(x_1,x_2) = 0$，$\\lambda\\ge0$。\n考虑到：当最优点在$g$的边界上时，$g=0,\\lambda\u0026gt;0$，当最优点在$g$内部时，$g\u0026lt;0,\\lambda=0$，则有$\\lambda g =0$，称为互补松弛条件。\n综上合并情况后可以把在不等式约束下的最优解的必要条件写为：\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla L(x_1,x_2,\\lambda)=\\nabla f(x_1,x_2)+\\lambda \\nabla g(x_1,x_2) = 0 \\\\ \u0026amp;\\lambda \\ge0 \\\\ \u0026amp;\\lambda g(x_1,x_2)=0 \\\\ \u0026amp;g(x_1,x_2)\\le 0 \\end{aligned} \\right. \\tag{8} $$\n推广到多个不等式约束的多元函数优化问题，表达如下\n$$ min \\ f(x_1,x_2,\u0026hellip;,x_n) \\\\ s.t. \\left\\{ \\begin{aligned} \u0026amp;g_1(x_1,x_2,\u0026hellip;,x_n) \\le 0 \\\\ \u0026amp;g_2(x_1,x_2,\u0026hellip;,x_n) \\le 0 \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;g_m(x_1,x_2,\u0026hellip;,x_n) \\le 0 \\end{aligned} \\right. \\tag{9} $$\n则令$L(x_1,x_2,\u0026hellip;,x_n;\\lambda_1,\\lambda_2,\u0026hellip;,\\lambda_n)=f+\\lambda_1 g_1 + \\lambda_2 g_2+\u0026hellip;+\\lambda_n g_n=f+\\sum_{i=1}^{m} \\lambda_i g_i \\ (\\lambda_i\\in \\mathbf{R})$。\n最小化$L$，得到最优解$x^*=(x_1^*,x_2^*,\u0026hellip;,x_n^*)^T$的必要条件（KKT）如下。共$m$个约束、$n$个梯度分量为0带来的方程、m个互补松弛条件。\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla_xL=\\nabla_xf+\\sum_{i=1}^{m}\\lambda_i \\nabla_x g_i = 0 \\\\ \u0026amp;\\lambda_i \\ge 0\\\\ \u0026amp;\\lambda_i g_i =0 \\\\ \u0026amp;g_i\\le0 \\end{aligned} \\right. \\tag{10} $$\n四、混合情形 为简化表示，使用$\\mathbf{x}=(x_1,x_2,\u0026hellip;x_n)^T$。\n$$ min \\ f(\\mathbf{x}) \\\\ s.t. \\left\\{ \\begin{aligned} \u0026amp;g_1(\\mathbf{x}) = 0 \\\\ \u0026amp;g_2(\\mathbf{x}) = 0 \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;g_k(\\mathbf{x}) = 0 \\\\ \u0026amp;h_1(\\mathbf{x}) \\le 0 \\\\ \u0026amp;h_2(\\mathbf{x}) \\le 0 \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;h_l(\\mathbf{x}) \\le 0 \\end{aligned} \\right. \\tag{11} $$\n则令$L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})=f(\\mathbf{x})+\\sum_{i=1}^{k} \\lambda_i g_i(\\mathbf{x}) +\\sum_{i=1}^{l} \\mu_i h_i(\\mathbf{x})$。\n其中$\\mathbf{\\lambda}=(\\lambda_1,\\lambda_2,\u0026hellip;\\lambda_k)$，$\\mathbf{\\mu}=(\\mu_1,\\mu_2,\u0026hellip;\\mu_l)$，前者为等式约束的拉格朗日乘子，后者为不等式约束的拉格朗日乘子。\n最小化$L$，得到最优解$x^*=(x_1^*,x_2^*,\u0026hellip;,x_n^*)^T$的必要条件如下。\n$$ \\left\\{ \\begin{aligned} \u0026amp;\\nabla_xL(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})=\\nabla_xf(\\mathbf{x})+\\sum_{i=1}^{k}\\lambda_i \\nabla_x g_i(\\mathbf{x})+\\sum_{i=1}^{l}\\mu_i \\nabla_x h_i(\\mathbf{x}) = 0 \\\\ \u0026amp;g_i(\\mathbf{x})=0 \\ (i=1,2,\u0026hellip;k)\\\\ \u0026amp;h_i(\\mathbf{x}) \\le 0 \\ (i=1,2,\u0026hellip;l) \\\\ \u0026amp;\\lambda_i \\in \\mathbf{R} \\ (i=1,2,\u0026hellip;k)\\\\ \u0026amp;\\mu_i \\ge 0 \\ (i=1,2,\u0026hellip;l)\\\\ \u0026amp;\\mu_i h_i(\\mathbf{x}) =0 \\ (i=1,2,\u0026hellip;l) \\end{aligned} \\right. \\tag{12} $$\n五、原最优化问题转对偶问题 在满足KKT条件的情况下，原函数$f(\\mathbf{x})$可以与$max \\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})$等价（这里$\\lambda$和$\\mu$为自变量）。则目标原来的目标函数$min\\ f(\\mathbf{x})$就等价为$\\mathop{min}\\limits_{x} \\ \\mathop{max}\\limits_{\\lambda,\\mu} \\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})$。其对偶表达式为$ \\mathop{max}\\limits_{\\lambda,\\mu} \\ \\mathop{min}\\limits_{x}\\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu})$，由于满足KKT条件，其最优值等于原问题的最优值。\n即若在取得最优解$x^*$的情况下，满足以下表达式： $$ f(x^*)=\\mathop{min}\\limits_{x} \\ \\mathop{max}\\limits_{\\lambda,\\mu} \\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu}) = \\mathop{max}\\limits_{\\lambda,\\mu} \\ \\mathop{min}\\limits_{x}\\ L(\\mathbf{x};\\mathbf{\\lambda};\\mathbf{\\mu}) $$\n参考资料 拉格朗日乘子法详解-CSDN博客 形象理解拉格朗日乘子法 - 知乎 (zhihu.com) 《统计学习方法》-李航\n"},{"section":"Blog","slug":"/en/blog/opticalflow/","title":"【学习笔记】Optical Flow的基本原理与常见光流估计方法","description":"this is meta description","date":"November 12, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"219\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"深度学习, 学习笔记","tags":"光流估计, 金字塔特征, GRU迭代更新","content":"CSDN：【学习笔记】光流(Optical Flow)的基本知识与光流估计方法 1. 简介 1.1 光流(Optical Flow)的基本概念 光流（Optical Flow）是指描述在图像序列中物体表面上的像素移动的模式。在计算机视觉和图像处理领域，光流是一种用于估计相邻帧之间像素之间位移的技术。简而言之，光流是描述相邻图像帧之间像素运动的模式，它通过跟踪图像中的特征点或像素来估计运动的速度和方向。 或者说是在像素级别上的位移描述，即每一个像素点从第一帧到第二帧的具体偏移量。\n1.2 补充说明 光流法的基本假设：（1）亮度恒定不变，即同一目标在不同帧间的运动时亮度不会发生改变；（2）相邻帧之间的位移要比较小，即时间上不会引起目标的剧烈位置变化。\n基于假设的形式化表达：形式化表达即如下，其中I代表具体的像素值（光强度），t为具体的时刻，Δt一般即为相邻帧的时间，(u,v)则为像素的具体偏移量，可以理解成前一帧图像中的(i,j)像素在Δt的时间间隔下（下一帧），移动了(u,v)。\n$$ I(i,j,t) = I(i+u,j+v,t+\\Delta t) $$\n光流的方向：图像帧A→B，则flow的方向为B-\u0026gt;A。（不确定，查阅了各种资料后得到的解释，但这部分方向上的定义不影响实际的分析与代码编写）\n光流的warp：若存在两帧frame1和frame2，不考虑batch的情况下，其shape均为[3,H,W]，对应的flow的shape为[2,H,W]，两个通道分别表示水平、竖直方向上的位移，该flow满足以下关系式子。 $$ frame1[:,i,j] = frame2[:,i+u,j+v] \\ u=flow[0,i,j],v=flow[1,i,j] $$ 那么在已知frame1和flow的情况下，可以通过依次查询flow并将像素进行偏移得到frame2，该过程则为warp。在大多数代码场景下，还会涉及到backwarp操作（有些文章不严格区分warp和backwarp），即在已知frame2和flow的情况下，得到frame1，一部分原因还包括backwarp的操作可以通过torch.nn.functional.grid_sample采样函数实现（见后文），这样的话，我们可以在已知frame2到frame1的flow以及frame1的前提下轻松地求得frame2。（Tips：部分文章提及使用frame1到frame2的-flow求frame2，使用的还是基于grid_sample函数的backwarp方法，个人认为并不正确，因为frame2的像素点和具体在frame1的采样点的映射关系需要通过flow得以确定，画个图就可以说明。）\n1.3 常见应用 视频压缩、视频插帧、物体运动分析（车流方向）、特征计算的优化、视频稳像、视觉效果等。\n2. 一些常用操作 2.1 光流文件读取 flow的常见存储文件格式为.flo，网络上已有现成且广泛使用的flo文件读取代码，如下。通过分析代码可以知道该文件大致的存储结构，包括标识符、高宽数据、具体位移数据。通过open函数进行二进制形式打开即可，使用numpy中的fromfile函数进行依次读取。\n# 读取flow文件，返回对应的numpy数组 def load_flow(path): with open(path,\u0026#39;rb\u0026#39;) as fl: flag = np.fromfile(fl,np.float32,count=1) # 先读取第一个数据 assert (202021.25 == flag) # 使用assert语句判定flo文件的合法性 width = np.fromfile(fl, np.int32, count=1)[0] # 读取宽、高信息 height = np.fromfile(fl, np.int32, count=1)[0] data = np.fromfile(fl, np.float32, count=2 * width * height) # 读取剩余的位移数据 return np.resize(data, (height, width, 2)) 2.2 光流可视化 将运动信息进行具体的可视化。其实就是对不同位移方向和大小进行颜色赋值，例如绿色代表往右上角进行移动，绿色越深表示偏移程度越大。\n例如可以达到以下的效果。（实际位移方向与颜色之间的映射关系可能不同，下图中左上角的椅子往右上角移动了，颜色为深紫色。）\n网上常用的可视化代码如下，可以直接当成已知模块使用。\n# 将flow进行可视化 def flow_to_image(flow, max_flow=256): # 确保max_flow的最小值为1 if max_flow is not None: max_flow = max(max_flow, 1.) else: max_flow = np.max(flow) # 定值，含义未深究，可能是用于得到不同的饱和度 n = 8 # 提取水平、垂直运动信息 u, v = flow[:, :, 0], flow[:, :, 1] # 计算每个像素点的光流大小，即为模长（位移大小） mag = np.sqrt(np.square(u) + np.square(v)) # 计算每个像素点的光流方向，即速度的方向角度（得到的弧度） angle = np.arctan2(v, u) # 将角度值映射到0到1的范围内，除以2*pi，加1并余1即可约束范围（色调信息） im_h = np.mod(angle / (2 * np.pi) + 1, 1) # 大概是：计算每个像素点的饱和度，通过光流大小和max_flow的比值进行缩放，并确保饱和度在0到1的范围内 im_s = np.clip(mag * n / max_flow, a_min=0, a_max=1) # 大概是：计算每个像素点的亮度，亮度为n减去饱和度，并确保亮度在0到1的范围内 im_v = np.clip(n - im_s, a_min=0, a_max=1) # 将色调、饱和度和亮度转换为RGB颜色空间的图像 im = hsv_to_rgb(np.stack([im_h, im_s, im_v], 2)) # 在0到255的范围内表示图像的像素值 return (im * 255).astype(np.uint8) 2.3 backwarp操作实现 对于正向warp，其含义比较简单，即将每一个像素点数值放到对应的偏移位置即可，注意非整点的处理。\n这里重点介绍一下使用torch.nn.functional.grid_sample的backwarp操作，由于backwarp操作一般在网络内部执行，这里写的是torch框架下的代码。\n对于grid_sample函数，网上资料较多，不做赘述，简单来说就是输入一个图像和一个网格grid，根据网格grid中的位置信息在图像中找到（采样）对应的像素点进行存储，看后续代码应该更好理解。\n# 这里把它封装成了一个nn模块，将backwarp操作写到了正向传播过程中，输入frame2与flow，得到对应的frame1 class BackWarpFlow(nn.Module): # 类静态变量，其实可以写成全局变量。由于后面的操作有需要处理指定规格的网格，有时候无需重复处理以减少时间开销，这里先做一个存储 Warp_Grid = {} def __init__(self): super(BackWarpFlow, self).__init__() def forward(self, img, flow): # 将运算加载到GPU上，如果传入的张量已在GPU上加载则可以不用操作 img, flow = img.cuda(), flow.cuda() # 若该规格的flow未被处理过（未生成过对应规格的网格）则先处理出一个网格 if str(flow.shape) not in BackWarpFlow.Warp_Grid: # 使用linspace生成一个从-1.0到1.0的等间隔的张量（与flow的宽等长），并调整规格为[1,1,1,W] # 使用repeat函数在shape[2]方向上重复shape[2]次，即H次，得到张量的规格为[1,1,H,W] u = torch.linspace(-1.0, 1.0, flow.shape[3]).view(1, 1, 1, -1).repeat(1, 1, flow.shape[2], 1) # 同理另一层 v = torch.linspace(-1.0, 1.0, flow.shape[2]).view(1, 1, -1, 1).repeat(1, 1, 1, flow.shape[3]) # 在第1个维度上拼接得到的网格规格为[1,2,H,W]，与flow相对应，且每一个像素位置上的值是均匀的，与其位置相对应。存储到字典中 BackWarpFlow.Warp_Grid[str(flow.shape)] = torch.cat([u, v], 1).cuda() # 取出flow中两个方向上的偏移，将其根据规格进行规范化处理，重新拼接 tenFlow = torch.cat([flow[:, 0:1, :, :] * (2.0 / (img.shape[3] - 1.0)), flow[:, 1:2, :, :] * (2.0 / (img.shape[2] - 1.0))], 1) # 调用grid_sample进行采样，前面提到Warp_Grid中的网格值是与位置一一对应的，加上flow后，每个网格上的值就相当于进行了位移，将该网格作为采样网格即可实现frame2还原到frame1。（理解成，(i,j)地方的像素应当去(i+u,j+v)的地方采样，(i,j)即在Warp_Grid中体现，与位置对应，(u,v)即在tenFlow体现） # permute调整维度以适应grid_sample函数，该函数要求通道数这一维在最后 # 可能有非整点的情况出现，采用双线性插值。 return torch.nn.functional.grid_sample(input=img, grid=(BackWarpFlow.Warp_Grid[str(tenFlow.shape)] + tenFlow).permute(0,2,3,1), mode=\u0026#39;bilinear\u0026#39;, padding_mode=\u0026#39;border\u0026#39;, align_corners=True) 2.4 光流的评价(Loss说明) 最主要的评价指标为Endpoint error (EPE) loss，即端点误差损失。EPE损失是通过计算预测的光流场与真实的光流场之间的平均欧氏距离来衡量光流估计的精度。同时也可以作为损失函数进行相关光流估计网络的训练。该部分代码实现方式较多，这里呈现最简单的实现方法。\nclass EPELoss(nn.Module): def __init__(self): super(EPELoss, self).__init__() def forward(self, flow_pred, flow_target): # 平均欧氏距离 dist = (flow_target - flow_pred).pow(2).sum().sqrt() return dist.mean() 3. 光流估计方法 前人有许多基于数理统计、泰勒展开等数学方法，内容较多难以涵盖，主要介绍归纳几种常见有效的基于深度学习的光流估计方法（当然是经过论文阅读和学习的方法，没有学习到的方法若后续有所学习，则会补上笔记）。大部分方法本文只能给出整体的实现思路，具体的开源代码分析耗时较长，后续再进行整理编辑。同时，对于每种方法的创新点和亮点，不同读者可能有不同的理解看法，本文视角可能相对局限。\n3.1 FlowNet-基于CNNs构建的含关联层的端到端训练光流网络 3.1.1 论文及其链接 论文：ICCV2015, FlowNet: Learning Optical Flow with Convolutional Networks\n链接：FlowNet: Learning Optical Flow With Convolutional Networks (thecvf.com) 3.1.2 文章摘要 卷积神经网络（CNNs）最近在各种计算机视觉任务中取得了很大成功，尤其是与识别相关的任务。光流估计并不是CNNs成功的任务之一。在本文中，我们构建了能够将光流估计问题作为监督学习任务解决的CNNs。我们提出并比较了两种架构：一种通用架构和另一种包括在不同图像位置相关特征向量的层。由于现有的地面真实数据集不足以训练CNN，我们生成了一个大型的合成飞行椅子（Flying Chairs）数据集。我们展示了在这种不真实的数据上训练的网络仍然很好地推广到现有数据集，如Sintel和KITTI，在5到10fps的帧速率下达到了竞争性的准确度。\n3.1.3 文章亮点 提出了使用卷积神经网络来进行光流估计的方法，例如一种通用架构，说明了使用CNNs方法进行光流估计的可行性； 提出了像素关联层（correlation layer）的概念，再像素级别描述各像素之间的关联性，使用网络自行学习两张图像（或其特征）之间的关联性，以实现图像在不同位置之间的匹配； 在多个尺度上不断细化光流（Refinement），对低分辨率的粗糙进行上采样并逐步学习细化； 制作了Flying Chairs数据集，提供了一种含噪声背景情况下的物体运动信息（Flow）的数据集。 3.1.4 网络结构 文章中包含了两种网络结构，一种为简单版本的FlowNetSimple，另一种是基于像素关联层的FlowNetCorr，结构分别如下。\nRefinement模块\n两类网络均包含了refinement细化模块，该模块以多尺度的图像特征为输入，得到细化的光流估计（提高光流的输出分辨率），结构如下。（但从效果来说，又比双线性插值好多少呢）\n可以看到，灰色部分即为编码器（特征提取部分）所得到的多尺度特征。该细化模块进行了多个尺度的粗糙光流细化，具体地，相当于将以下三部分内容进行拼接：上一层特征经过卷积与上卷积后的结果（绿色）、上一层输出的粗糙flow的上采样结果（红色）、编码器过程中对应尺度的特征（灰色），作为当前层的特征，送入一个光流预测网络即可获得当前层输出的光流。\nFlowNetSimple\n简单地将两张图像进行拼接(在通道维度上进行拼接)，并使用卷积神经网络进行多尺度的特征提取，最后送入细化模块进行光流的细化。该网络结构是由网络自行决定如何从图像中进行运动信息的提取。对输出Flow进行监督达到光流估计的目的。\nFlowNetCorr\n根据网络结构可知对两帧图像分别进行特征的采集，随后对特征进行关联性计算，得到一个特征相关性矩阵（暂且这么叫吧）。\n首先文章中给出了两个特征图中任意两个像素之间的关联性定义，如下表达式。\n$$ I(i,j,t) = I(i+u,j+v,t+\\Delta t) $$\n$$ c\\left(\\mathbf{x}_{1}, \\mathbf{x}_{2}\\right)=\\sum_{\\mathbf{o} \\in[-k, k] \\times[-k, k]}\\left\\langle\\mathbf{f}_{1}\\left(\\mathbf{x}_{1}+\\mathbf{o}\\right), \\mathbf{f}_{2}\\left(\\mathbf{x}_{2}+\\mathbf{o}\\right)\\right\\rangle $$\n上式含义为：以x1这个点为中心，2k+1为边长的正方形区域，与x2为中心的区域之间的关联性，这里引入一个k作为区域范围，以说明一个个patch块之间的关联性（其实就是考虑到了周边的像素点的特征）。其中x1和x2分别表示来自于两个特征图的像素位置，分别都是二元组；f1表示第一个特征图，f2表示第二个特征图，由于特征图是多通道的（如前面的网络结构图中显示的两个计算相关性的特征图，均有256层特征），因此每一个像素位置都可以取到多通道的特征数值（例如在第一个特征图的(i,j)位置，可以取到一个256维的向量feature[: , : , i , j])，将两个区域块对应位置的特征向量进行内积运算，得到一个相关值c。\n但每个特征图都有h×w个像素，两张特征图中两两求关联性则会产生h×h×w×w个相关值，这个数量太大了，因此文章中提到对于每个位置的像素仅考虑一个限定范围D之内的像素的相关性，即不考虑处理距离太远的像素之间的相关项，这样便将值相关性数据的数理降低为h×w×D×D。即可以理解为：对于第一张图的每一个位置的像素特征，都对应着和第二张图D×D个相关性值。这也是图中441这个数值的来源，这里的D应取为21，即考虑以某一像素为中心，边长为21的范围内的像素的相关性。\n此外，观察网络结构图可以发现，文章还将该相关项矩阵与第一张图的再采样的特征图（以尺寸为1的卷积核获取了32层特征）进行了拼接操作，这一步文章中并未详细说明（可能也是我没读仔细），感性理解上可能是，后续的网络学习需要同时带上第一帧图像的一些特征信息，进行特征融合。\n通过相关性矩阵的处理，网络能够学习到像素级别上的像素相关性信息，从而更好地捕获像素级别的运动信息，在学习到抽象的相关性特征的同时不丢失浅层的图像信息。\n3.2 SPyNet-基于空间金字塔与残差光流训练的光流更新网络 3.2.1 论文及其链接 论文：CVPR2017, Optical Flow Estimation using a Spatial Pyramid Network\n链接：Optical Flow Estimation Using a Spatial Pyramid Network (thecvf.com) 3.2.2 文章摘要 我们通过将经典的空间金字塔形式与深度学习相结合来学习计算光流。这通过在每个金字塔级别将一对图像中的一个图像根据当前的光流估计进行warp，并计算对光流的更新来以粗到细的方式估计大运动。与在每个金字塔级别进行标准目标函数最小化的方法不同，我们针对每个级别训练一个深度网络来计算光流的更新。与最近的FlowNet方法不同，网络不需要处理大运动；这些大运动由金字塔来处理。这有几个优点。首先，我们的空间金字塔网络（SPyNet）在模型参数方面比FlowNet简单得多，小96%。这使得它更高效，更适用于嵌入式应用。其次，由于每个金字塔级别的光流很小（\u0026lt;1像素），因此将卷积方法应用于一对变形图像是合适的。第三，与FlowNet不同，学习到的卷积滤波器与经典的时空滤波器相似，这提供了对方法及其改进方法的见解。我们的结果比大多数标准基准测试上的FlowNet更精确，这表明了将经典的光流方法与深度学习相结合的新方向。\n3.2.3 文章亮点 采用训练光流残差的方式，对光流进行逐步细化； 每一个尺度下均训练了一个深度网络用于光流残差的获取，并有多尺度下的光流细化过程； 将传统的空间金字塔与深度学习方法进行结合，同时参数量较小。 3.2.4 网络结构 SPyNet的网络结构如下，其中仅举例展示了三层金字塔结构，具体的金字塔层数可以根据实际情况进行修改。\n其中可以明显看到每一层的网络结构大致相同，故这里取其中一层的结构进行说明，如红框所示，首先需要有上一层网络产出的预测光流（需要通过u上采样达到目标分辨率，或者双线性插值）。对于深度网络G，输入深度网络的有三部分内容：上一层的预测光流，frame1，经过上一层预测光流backwarp的frame2；而输出深度网络的则为光流残差，需要与上一层的预测光流进行相加以实现这一尺度下的光流细化。\n在最开始的情况下，直接暴力地设置初始光流为0，通过多尺度的空间特征与光流细化后得到目标尺度的光流。对于具体的公式表达，文章说明的比较详细，但最终表达的意思与网络结构图一致。\n模型训练\n根据文章描述，是对每一层的深度网络G进行依次训练，并不是一次性的端到端训练，其中Loss的定义如下图，即在前面的所有层的网络完成训练后，认定可以产出较为精准的光流，该层深度网络训练得到光流残差$v_k$后，与当前尺度下的光流标签$\\hat V_k$和上一层预测光流的差$\\hat v_k$进行Loss计算，使用EPELoss。\n但为什么不能直接对加上光流残差修正后的光流进行监督呢？含义似乎是一样的。\n这样分层训练的方式简化了模型的训练，相比于端到端的训练方法来说更省时间或容易收敛。（不知道能不能对多层光流同时进行监督？）\n3.2.5 代码分析 开源代码中大部分训练代码给的为lua代码，但也给出了使用Pytorch框架编写的网络结构，为更好地理解网络结构，对代码进行分析（lua没学过）。\n去除一些辅助代码，这里只看核心的网络架构。取自开源的Pytorch代码（https://github.com/sniklaus/pytorch-spynet），进行注释编写分析。\nclass Network(torch.nn.Module): def __init__(self): super().__init__() # 为更好地训练模型，编写了一个图像归一化处理的过程代码 class Preprocess(torch.nn.Module): def __init__(self): super().__init__() def forward(self, tenInput): # 翻转通道，为什么呢？ tenInput = tenInput.flip([1]) # 减去数据集的均值并除以标准差以实现图像的归一化 tenInput = tenInput - torch.tensor(data=[0.485, 0.456, 0.406], dtype=tenInput.dtype, device=tenInput.device).view(1, 3, 1, 1) tenInput = tenInput * torch.tensor(data=[1.0 / 0.229, 1.0 / 0.224, 1.0 / 0.225], dtype=tenInput.dtype, device=tenInput.device).view(1, 3, 1, 1) return tenInput # 每层的光流残差训练的深度网络 class Basic(torch.nn.Module): def __init__(self, intLevel): super().__init__() # 与论文实验部分说明一致，采用五个卷积层加ReLU激活函数 self.netBasic = torch.nn.Sequential( # 说明为什么输入通道为8。 # 前面提及送入网络的三部分内容为：上一层的预测光流（2通道），frame1（3通道），经过上一层预测光流backwarp的frame2（3通道） # 直接拼接融合即为8通道 torch.nn.Conv2d(in_channels=8, out_channels=32, kernel_size=7, stride=1, padding=3), torch.nn.ReLU(inplace=False), torch.nn.Conv2d(in_channels=32, out_channels=64, kernel_size=7, stride=1, padding=3), torch.nn.ReLU(inplace=False), torch.nn.Conv2d(in_channels=64, out_channels=32, kernel_size=7, stride=1, padding=3), torch.nn.ReLU(inplace=False), torch.nn.Conv2d(in_channels=32, out_channels=16, kernel_size=7, stride=1, padding=3), torch.nn.ReLU(inplace=False), torch.nn.Conv2d(in_channels=16, out_channels=2, kernel_size=7, stride=1, padding=3) ) def forward(self, tenInput): return self.netBasic(tenInput) self.netPreprocess = Preprocess() # 每一层都有一个深度网络用于训练当前尺度的光流残差 self.netBasic = torch.nn.ModuleList([ Basic(intLevel) for intLevel in range(6) ]) def forward(self, tenOne, tenTwo): tenFlow = [] # 用于存储不同尺度下的图像金字塔 开始就是原尺度 tenOne = [ self.netPreprocess(tenOne) ] tenTwo = [ self.netPreprocess(tenTwo) ] # 额外处理五层 for intLevel in range(5): # 取金字塔顶部（最小的）图像，若宽高大于32则可以继续下采样 if tenOne[0].shape[2] \u0026gt; 32 or tenOne[0].shape[3] \u0026gt; 32: # 使用均值池化获取低分辨率的图像， insert到list的第0位，则金字塔中的尺度是自小向大的 tenOne.insert(0, torch.nn.functional.avg_pool2d(input=tenOne[0], kernel_size=2, stride=2, count_include_pad=False)) tenTwo.insert(0, torch.nn.functional.avg_pool2d(input=tenTwo[0], kernel_size=2, stride=2, count_include_pad=False)) # 开始光流为0，shape除以2是因为每一层的操作都有一个光流上采样过程，为了同步编码，第0层也进行一个上采样，因此设置小一点的初始光流 tenFlow = tenOne[0].new_zeros([ tenOne[0].shape[0], 2, int(math.floor(tenOne[0].shape[2] / 2.0)), int(math.floor(tenOne[0].shape[3] / 2.0)) ]) # 遍历每一层 for intLevel in range(len(tenOne)): # 对光流进行上采样，方式为双线性插值，缩放比为2， tenUpsampled = torch.nn.functional.interpolate(input=tenFlow, scale_factor=2, mode=\u0026#39;bilinear\u0026#39;, align_corners=True) * 2.0 # 对上采样的光流尺寸进行修正，处理可能存在的尺寸不匹配问题，需要与金字塔图片的尺度进行匹配。 if tenUpsampled.shape[2] != tenOne[intLevel].shape[2]: tenUpsampled = torch.nn.functional.pad(input=tenUpsampled, pad=[ 0, 0, 0, 1 ], mode=\u0026#39;replicate\u0026#39;) if tenUpsampled.shape[3] != tenOne[intLevel].shape[3]: tenUpsampled = torch.nn.functional.pad(input=tenUpsampled, pad=[ 0, 1, 0, 0 ], mode=\u0026#39;replicate\u0026#39;) # 将前面提及的三部分送入深度网络训练，得到光流残差最后加上上采样后的前一层的预测光流 # tenOne[intLevel] 第一帧 # backwarp(tenInput=tenTwo[intLevel], tenFlow=tenUpsampled) 通过当前光流backwarp后的第二帧 # tenUpsampled 当前预测光流 tenFlow = self.netBasic[intLevel](torch.cat([ tenOne[intLevel], backwarp(tenInput=tenTwo[intLevel], tenFlow=tenUpsampled), tenUpsampled ], 1)) + tenUpsampled return tenFlow 3.3 RAFT-基于多尺度4D相关体查找与GRU的迭代光流更新网络 3.3.1 论文及其链接 论文：ECCV2020, Recurrent All-Pairs Field Transforms for Optical Flow\n链接：ecva.net/papers/eccv_2020/papers_ECCV/papers/123470392.pdf 3.3.2 文章摘要 我们介绍了循环全对场变换（RAFT），这是一种用于光流的新型深度网络架构。RAFT提取每个像素的特征，为所有像素对构建多尺度4D相关性体，并通过一个循环单元迭代地更新流场，该单元在相关性体上执行查找操作。RAFT实现了最先进的性能。在KITTI数据集上，RAFT实现了5.10%的F1-all误差，比最佳发布结果（6.10%）减少了16%的误差。在Sintel（最终通行证）上，RAFT的端点误差为2.855像素，比最佳发布结果（4.098像素）减少了30%的误差。此外，RAFT在推理时间、训练速度和参数数量方面具有高效率，具有强大的跨数据集泛化能力。\n3.3.3 文章亮点 采用多尺度的4D相关体，即相关体金字塔，通过预处理该金字塔结合后续的查表操作，可以描述一个flow所带来的映射像素的多尺度相关性 采用GRU对光流进行不断的修正与更新。 3.3.4 网络结构 RAFT的整体结构如下，后文进行分模块分析。\n特征提取网络\n即上图中的Feature Encoder和Context Encoder，分别进行图像特征和语义特征的提取。其中Feature Encoder导出低分辨率的密集特征图。（对于特征提取无非是卷积操作，这里也不深究特征提取到什么程度了，到后面看看对特征图进行怎样的处理）\n4D相关体（4D Correlation Volumes）计算\n看结构图可以看到一个点积的符号，联想到对特征向量的点积操作，这里和FlowNet中的关联矩阵计算很类似，只是这里只考虑两个像素之间的特征相关性，并没有选定某一个范围进行区域相关性计算。公式如下，本质上就是将两个像素（比如第一张图的(i,j)和第二张图的(k,l)）对应的特征进行点积得到一个特征值，那么像素两两进行相关性计算即可得到一个4维（H×W×H×W）的相关矩阵，通称为4D相关体，表示$I_1$每一个像素点与每一个$I_2$像素点的相关度。\n$$ C_{ijkl}=\\sum_{h}g_{\\theta}(\\mathbf{I_{1}})_{ijh}·g_{\\theta}(\\mathbf{I_2})_{klh} $$\n相关性金字塔（Correlation Pyramid）\n但实际上，frame1（前文说是$I_1$）的像素不可能与frame2的每一个像素都有关联（可能还有其它更深层的考虑），作者再4D相关体的后两个维度上进行下采样，得到了4层的相关体，其中尺寸从大到小分别为H×W×H×W、H×W×H/2×W/2、H×W×H/4×W/4、H×W×H/8×W/8，这里也在一定程度上隐含了像素和某一个区域的相关性。如下图所示。\n查表Lookup\n这一部分论文写的相对难以理解，不过可以去读源码辅助理解。\n由于RAFT主要进行的是光流的迭代更新，对于每一次产出的光流，可以表示为（$\\mathbf{f}^{1},\\mathbf{f}^{2}$），对于frame1中的一个像素点$\\mathbf{x}(u,v)$，通过光流找到frame2中的对应点$\\mathbf{x\u0026rsquo;}(u+\\mathbf{f}^{1}(u),v+\\mathbf{f}^{2}(v))$，在$\\mathbf{x\u0026rsquo;}$的基础上，作者定义了一个领域网格$N_r(\\mathbf{x\u0026rsquo;})$，表达式如下： $$ \\mathbf{N_r(x\u0026rsquo;)} = { \\mathbf{x\u0026rsquo;}+\\mathbf{dx}\\ |\\ \\mathbf{dx}\\in \\mathbb{Z}^2, ||\\mathbf{dx}||_1 \\le r } $$ 相当于这个领域网格就是以当前预测光流的映射关系下，找到对应像素点的一个领域范围内，并在这个领域范围内去查找相关性金字塔，将查询得到的值进行组合得到一个新的向量，该向量就是Lookup的输出结果。（不太标准地概括这种思路：对于任意一个flow，在4D相关体上查询frame1的像素在该flow的作用下的映射像素之间的多尺度关联性，关联性越高那么显然这个flow的映射更贴近真实情况，这样便给与网络一种描述flow准确度的手段）\n举个例子，比如r为9，那么对于每一个frame1的像素点，都可以在4D相关性金字塔的每一层中查询到81个相关性值，即为与邻域范围内所有像素点的相关性，而4层相关体则可以查询到4×81个相关性值（对于低像素的相关体，使用双线性采样器找到对应的位置即可），那么对于所有H×W个像素点，最终可以查询到规格[H,W,324]的向量。\n对于上式，r如果较大，那么能够获取到的关联性数据就多，能够获取较大运动范围内的关联信息，反之则运动更为精细。\n光流迭代更新（GRU）\nGRU的大体结构和式子不作赘述，直接看以下网络结构，用于修正光流的产生。\n对于每一次迭代，GRU单元的输入（图中红色）包含：经过Lookup查表后的关联向量、隐状态、语义特征context feature；输出（图中蓝色）包含：更新后的隐状态，修正光流Δf，用于对上一次迭代的粗糙光流进行修正。\n特别的是，训练过程中，作者并非直接取最后一次迭代的光流与实际光流计算Loss，而是对每一次迭代的光流都进行了Loss计算以监督。\n这个思路与SPyNet略有点相似（也只是一点，在于使用深度网络训练残差光流，对光流进行细化），只是RAFT在全分辨率下不断进行光流的修正，能够实现每次迭代的监督，而SPyNet则是在多尺度下进行光流的细化。\n以下的内容等待进一步深入学习与笔记的细化。\n3.4 GMA-基于全局运动信息 3.4.1 论文及其链接 论文：ICCV2021, Learning to Estimate Hidden Motions with Global Motion Aggregation\n链接：Learning To Estimate Hidden Motions With Global Motion Aggregation (thecvf.com) 3.5 KPA-基于局部注意力 3.5.1 论文及其链接 论文：CVPR2022，Learning Optical Flow with Kernel Patch Attention\n链接：Learning Optical Flow With Kernel Patch Attention (thecvf.com) 3.6 DIP-基于patchmatch降低4D相关体的计算 3.6.1 论文及其链接 论文：CVPR2022, DIP: Deep Inverse Patchmatch for High-Resolution Optical Flow\n链接：DIP: Deep Inverse Patchmatch for High-Resolution Optical Flow (thecvf.com) 4. 光流的应用研究 4.1 ICCV2017：Semantic Video CNNs through Representation Warping 使用offline的flow计算方法对前一帧的feature进行warp，但warp的是CNN过程中的层特征。提高精度。\n4.2 CVPR2018：Semantic Video Segmentation by Gated Recurrent Flow Propagation 将前一帧的mask进行warp，与当前帧直接计算的mask共同送入GRU，以实现前一帧mask对当前帧mask的弥补。提高精度。\n4.3 CVPR2017：Deep Feature Flow for Video Recognition 将前一帧（key frame）的feature通过flow作为当前帧的feature，减少重复的特征计算。\n参考资料 optical flow光流方向问题 - 知乎 (zhihu.com) 光流、warp和grid_sample()_pytorch warp-CSDN博客 提取光流文件(.flo)为u，v二通道图像(作为网络输入)_光流flo 文件-CSDN博客 端点误差损失Endpoint error (EPE) loss - 知乎 (zhihu.com) 【光流评估】《Optical Flow Estimation using a Spatial Pyramid Network》2016 Tubingen, Germany-CSDN博客 全面回顾 | 基于深度学习的光流估计算法汇总-CSDN博客 RAFT光流估计 - CuriosityWang - 博客园 (cnblogs.com) https://github.com/sniklaus/pytorch-spynet "},{"section":"Blog","slug":"/en/blog/32bitcpu/","title":"【项目笔记】基于Quartus与FGPA的32位单周期硬布线CPU设计","description":"this is meta description","date":"November 5, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"219\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"项目笔记","tags":"计算机组成原理, 硬件设计","content":"本次课程设计要求使用硬布线的方法设计并实现一个32位的单周期CPU，并设计一系列机器指令，从而实现CPU的基本运算处理能力。以此掌握CPU的工作原理、各组成部件的设计方法、数据通路的设计、指令集的设计、基于硬布线的控制信号生成方法等内容。\n整个课程设计大致分为软件仿真与硬件运行两部分。软件仿真方面，本文采用Quartus II设计+ModelSim波形仿真的方法，使用基于原理图的方式进行CPU部件的设计，并通过波形图进行仿真运行与部件功能的检验；硬件运行方面，本文选用FPGA DE0开发板，在完成软件编写后将工程烧录至开发板中运行，以显式地检验CPU与指令设计的正确性。\n具体地，本次课设完成了寄存器堆、存储器、程序计数器、算术逻辑单元、数据选择器、位拓展单元、控制单元、LED显示单元等模块的设计，并在此基础上进行了数据通路的设计，并设计了一系列控制信号，用于协调各模块之间的协作，控制信号由控制单元接收指令生成，采用硬布线的方法实现；指令层面，共设计了Clear、Set、ADD、SUB、JMP、LW、SW、BEQ、Mov等九条基本功能指令，以实现常见的数据输入、运算、转移、循环等功能。\n完成基本的设计后，本文还基于设计的九条功能指令进行了测试程序的编写，以验证CPU功能与指令功能的正确性，包括加减法测试、数据转移测试、条件循环测试等，最终以波形图与开发板LED显示的方式进行正确性检验，结果均符合预期。\n通过本次课程设计，对于计算机组成原理有了进一步的理解，尤其是CPU的内部构造与工作模式，并锻炼了问题分析与硬件设计的能力，对后续课程有较大的帮助。\nThis course design requires the use of a hardwired method to design and implement a 32-bit single-cycle CPU, and design a series of machine instructions, to achieve the basic computing processing capacity of the CPU. In this way, we can master the working principle of the CPU, the design method of each component, the design of the data path, the design of the instruction set, and the generation method of the control signal based on hard wiring. The whole course design is roughly divided into software simulation and hardware operation two parts. In terms of software simulation, this paper adopts the Quartus II design +ModelSim waveform simulation method to design CPU components based on a schematic diagram and conducts simulation operation and component function inspection through a waveform diagram. In terms of hardware operation, this paper selects the FPGA DE0 development board and burns the project to the development board to run after software writing, to explicitly check the correctness of CPU and instruction design. Specifically, this course has completed the design of the register pile, memory, program counter, arithmetic logic unit, data selector, bit expansion unit, control unit, LED display unit, and other modules. On this basis, the data path is designed, and a series of control signals are designed to coordinate the cooperation between the modules. The control signal is generated by the command received by the control unit, which is realized by hard wiring. At the instruction level, a total of nine basic function instructions such as Clear, Set, ADD, SUB, JMP, LW, SW, BEQ, and Mov are designed to achieve common data input, operation, transfer, circulation, and other functions. After the completion of the basic design, this paper is also based on the design of nine functional instructions for the test program, to verify the correctness of CPU functions and instruction functions, including addition and subtraction test, data transfer test, conditional loop test, etc., the final waveform diagram and the development board LED display way for correctness test, the results are in line with expectations. Through this course design, I have a further understanding of the principle of computer composition, especially the internal structure and working mode of CPU, and exercised the ability of problem analysis and hardware design, which will be of great help to the subsequent courses.\n一、设计目的与目标 1.1 设计目的 通过设计一个简易的32位单周期CPU，加深对计算机体系结构的理解，理解并掌握基本的数据通路设计、指令集设计以及硬布线控制器设计方法。 学习使用Quartus II软件进行硬件的描述与波形仿真，并基于FPGA开发板进行测试，验证CPU设计实现的功能与性能。 设计并实现简易的指令集，熟悉指令格式、流程控制、寻址与跳转、数据流向等基本概念。 培养在实践中发现问题与解决问题的能力。 1.2 设计目标 设计一个简易的32位单周期的CPU架构，包括寄存器堆、算数逻辑单元、数据单元、硬布线控制器、存储器、数据拓展单元、程序计数单元。 自行设计几条简易的指令，组成最基本的指令集，包括加减法指令、存取数指令、程序跳转指令、条件判断指令、数据转移指令等。 基于自己已设计的指令，使用硬布线设计方法，进行程序控制信号、控制器的设计。 使用Quartus II+FPGA的方法，分别从软件和硬件层面进行CPU的基本设计与功能验证。 二、课程设计器材 硬件平台和软件平台的选择能够为本实验提供丰富而强大的资源和工具支持，有利于进行单周期32位CPU的设计、实现和测试。\n2.1 硬件平台 本实验使用的FPGA开发板是Cyclone III 系列的DE0 FPGA开发板。该开发板具有丰富的硬件资源，适合进行基于FPGA的数字电路设计和计算机组成原理实验。\n硬件平台的主要特性如下：\nFPGA芯片：该开发板搭载了一颗Cyclone III 系列的FPGA芯片，该芯片提供了大量可编程逻辑单元（LEs）和内存单元（M9K），能够满足CPU设计的资源需求。 外设接口：DE0 FPGA开发板提供了多个外设接口，包括扩展插槽、GPIO口、七段数码管、开关和按键等，可以方便地进行与外部设备的交互，并进行输入输出的测试和验证。 连接接口：该开发板还提供了多种连接接口，如USB接口、VGA接口、音频接口、以太网接口等，可以适应不同的外部设备和通信需求。 2.2 软件平台 本实验使用的软件平台是Quartus II 13.1。Quartus II 是一款由Intel (Altera) 公司开发的集成电路设计软件，支持硬件描述语言（HDL）的编写、逻辑仿真、综合、布局和布线等功能。\n软件平台的主要特性如下：\n集成开发环境：Quartus II 提供了完整的集成开发环境，包括工程管理、代码编辑、设计模拟、逻辑综合和布局布线等功能模块。用户可以在同一个软件平台中完成整个设计流程，方便快捷。 硬件描述语言支持：Quartus II 可以支持多种硬件描述语言，如VHDL和Verilog，用户可以根据自己的偏好选择合适的语言进行设计。 仿真功能：Quartus II 内置了仿真工具，可以对设计的硬件描述文件进行功能仿真和时序仿真，在仿真环境中测试和验证设计的正确性。 综合和布局布线工具：Quartus II 提供了综合工具，可以将设计的硬件描述文件综合成目标设备的门级网表，然后通过布局布线工具将逻辑网表映射到实际的硬件资源上，生成可下载到FPGA开发板的配置文件。 三、CPU逻辑设计总体方案 CPU由多个模块构成并相互协作，通过程序控制器读取指令并发出不同的控制信号，从而控制不同的模块进行数据的传输、存储、处理。\n因此本次实验对于CPU的设计思路大致为：先进行大致的CPU架构梳理，对CPU的模块结构进行分析；进行指令集的设计，规划各指令的功能；进行数据通路的设计，从指令入手，规划需要进行操作的模块，并进行控制信号的设计；最后设计程序控制器，进行指令的解析与控制信号的产生。\n完成以上部分的设计后，并将各模块之间进行通路连接，理论上即可完成CPU的基本功能实现。\n3.1 CPU组成模块 本次课程设计计划实现的CPU包含控制单元、算术逻辑单元、寄存器堆、存储器、数位拓展单元、数据通路等基本模块，除此之外也包含如LED显示单元、数据选择器等功能部件。\n3.1.1 控制单元 控制单元（Control Unit）负责解释和执行指令，并协调其他模块的操作。它包含指令寄存器（用于存储当前执行的指令）、指令解码器（将指令转化为控制信号）和时钟（用于同步指令执行）等。控制单元基于指令解码器中的控制信号，控制其他模块的工作。\n3.1.2 算术逻辑单元 算术逻辑单元是执行计算机算术和逻辑运算的核心。它包括多个电子电路和逻辑门，可用于执行加法、减法、乘法和逻辑操作（如与、或、非、异或）。ALU接收来自寄存器的操作数，并根据控制信号执行相应的运算。本次实验中只考虑设计简单的加法器，作为ALU。\n3.1.3 寄存器堆 寄存器堆是一组用于存储临时数据的寄存器。这些寄存器用于存储ALU操作数、中间结果和其他重要数据。寄存器堆通常包含通用寄存器，可以存储多个位的数据，并允许对数据进行读写操作。\n3.1.4 存储器 存储器是用于存储程序和数据的部件。计算机系统通常包括主存储器（如RAM）和辅助存储器（如硬盘或固态硬盘）。CPU与存储器之间通过地址总线和数据总线进行通信，以传输指令和数据。本次实验中将存储器划分为存储指令的ROM，其中计划存放设计好的指令程序，以及RAM，用于存放计算数据。\n3.1.5 数位拓展单元 数位拓展单元用于扩展数据的位数，以满足指令要求。它接收来自指令以及寄存器的数据，并执行扩展操作，将数据从较小的位宽转化为较大的位宽，以便进行算术和逻辑运算。\n3.1.6 数据通路 数据通路是负责在CPU内部传输数据的路径。它由数据总线和控制总线组成，用于连接寄存器、ALU、存储器和其他组件。数据通路承载着数据的传输和操作，确保各个组件之间的连接和协调。\n3.2 指令集设计 3.2.1 指令执行流程 一般来说，一个CPU在处理指令时需要经过以下几个步骤：\n（1）取指令（IF）：根据程序计数器 PC 中的指令地址，从存储器中取出一条指令，然后转到译码状态。同时，在 PC 中产生取下一条指令需要的指令地址。\n（2）指令译码（ID）：对取指令操作中得到的指令进行译码，确定这条指令需要完成的操作，从而产生相应的控制信号，驱动执行状态中的各种动作。\n（3）指令执行（EXE）：根据指令译码得到的控制信号，具体地执行指令动作，然后，转移到结果写回状态。\n（4）存储器访问（MEM）：所有需要访问存储器的操作都将在这个步骤中执行，该步骤给出访问存储器的数据地址，把数据写入到存储器中数据地址所指示的位置或者从存储器中的得到数据地址所指示的数据。\n（5）结果写回（WB）：该步骤负责把指令执行的结果或者访问存储器中得到的数据写回到相应的目的寄存器中。\n3.2.2 指令划分 对于32位指令，需要合理对其各位的含义进行分配，以实现对应的功能，例如其中最高六位将用作指令码，将被送往控制单元进行指令的译码，从而产生相应的控制信号。\n本次课程设计中对于指令的划分方案如下图所示。\n除指令码之外，指令的各部分被分别用作寄存器地址、运算立即数、PC值等，具体的功能将通过指令码译码产生的控制信号进行合理的控制与选择。\n3.2.3 指令格式及功能 完成指令的格式划分后，将进行指令的具体格式定义与功能设计，本次实验共设计了9条指令，分别为：Clear、Mov、Set、ADD、SUB、JMP、LW、SW、BEQ。\n其具体的格式与功能如下：\nClear cd 功能：清空目标寄存器cd。\nMov rt rd 功能：将寄存器rt中的数据转移到寄存器rd。\nSet rt 功能：将目标立即数data置入寄存器rt。\nADD rs rt rd 功能：将寄存器rs、rt中的内容取出相加，存储到rd寄存器之中。\nSUB rs rt rd 功能：将寄存器rs、rt中的内容取出相减，存储到rd寄存器之中。\nJMP target 功能：跳转到PC值为target的指令处。\nLW base rt offset 功能：取base值与offset相加，作为地址取数据并将其保存到rt寄存器之中。\nSW base rt offset 功能：取base值与offset相加，作为地址，并将rt寄存器的数据存入该地址所对应的内存空间中。\nBEQ rs rt target 功能：条件判断，如果rs和rt寄存器中的值相同，则PC转移到target处，否则PC=PC+1。\n3.3 控制信号设计 3.3.1 控制信号概述 控制单元对指令操作码进行译码，并发送各控制信号，从而控制各部件的工作状态，实现指定的要求。本次课程设计设计了9个控制信号，分别为PCSource、RegDst、ALUSrcB、ALUOp、Clear、MemToReg、RegWrite、MemWrite、Branch。\n3.3.2 控制信号功能 对于上述的各个控制信号，其具体功能如下表所示。\n信号名 无效时作用0 有效时作用1 PCSource PC=PC+1 PC=立即数 RegDst 写Reg地址来自rt字段 写Reg地址来自rd字段 ALUSrcB ALUB来自寄存器堆D2 符号拓展后的立即数 ALUOp ALU减法操作 ALU加法操作 Clear 正常读写 寄存器堆WriteData为0 MemToReg 正常读写 内存读写 RegWrite 无 上升沿到来时进行写寄存器 MemWrite 无 上升沿到来时进行写存储器 Branch PC=PC+1 PC=PC+offset 3.4 数据通路与控制线路 控制信号最后通过控制线路影响到各个部件的工作状态，且数据也会随着控制信号的改变产生不同的转移方向。\n四、模块详细设计 对于各模块的详细设计过程，大致可以分为主要硬件实现与控制单元的设计实现。完成各主要硬件模块的实现后，通过控制单元的控制信号对其进行统一控制。\n设计主要由Quartus II软件进行，为简化设计过程并明细设计流程，采用原理图的形式进行设计，必要时采用Verilog HDL语言进行补充设计，特别注意的是，在原理图的设计过程中，可以通过对引脚进行命名同步的操作以替代直接连线，简化了文件的复杂度。\n4.1 主要硬件实现 主要包含寄存器堆、存储器、数位拓展单元、程序计数单元、LED显示单元，其中LED显示单元是为了将二进制数据显示到数显板上而设计的。\n4.1.1 寄存器堆 寄存器堆用于数据的临时存储，采用D触发器实现。由于本次课程设计均为32位，故每一个存储单元需要由32个D触发器组成，考虑到设计的复杂性，本次设计过程中先实现了8位寄存器，再由4个8位寄存器级联组成32位计算器。如下图所示。\n完成32位寄存器的实现后，考虑到寄存器的寻址地址为5位，因此将32个32位寄存器进行组合，通过数据选择器控制指定的寄存器的写使能端，以实现数据的读写功能。数据的读操作也可以通过数据选择器实现，通过对给定的地址的译码操作，选中特定的寄存器输出信号作为整个寄存器堆的输出，这里可以设计成双端口读取。\n至此完成了对于寄存器堆的软件仿真实现，通过ModelSIM进行波形图仿真模拟，检测其功能的正确性。为简化设计过程，并体现模块化的设计理念，将以上整个寄存器堆导出为一个模块，便于后续的使用，如下图所示。\n4.1.2 存储器单元 本次课程设计采用将数据与指令分离的方法，将指令专门置于只读存储器ROM中，后续通过内存初始化文件MIF对其进行指令的写入，并将数据专门置于随机存储器RAM中，可在程序的任意时刻对其中的内存单元进行数据的读写操作。\n其中存放指令的ROM仅包含时钟信号输入端，地址输入端，指令输出端；存放数据的RAM包含时钟信号的同时，也包含了寻址地址端（共8位，寻址256个内存单元），写数据端，读数据端，读写控制信号。\n最终的存储器集成模块如下图所示。\n4.1.3 数位拓展单元 由于其余模块的操作数、指令均为32位，对于指令中的立即数，需要进行符号拓展操作，本次设计中涉及到26位至32位以及16位至32位的拓展，采用带符号的拓展方式，将最高位向高位方向进行同步拓展，最终达到拓展需求，该部分可以使用多个与门实现。\n以16位至32位的拓展为例，对于低15位采用直接输出的方法，最高位通过与门依次拓展补充，如下图所示。\n同理可以完成26位至32位的符号拓展单元，整体模块如下图所示。\n4.1.4 程序计数器 指令的执行需要程序计数器PC进行控制，正常的情况下PC自增，则按照顺序从指令存储器中进行指令的读取和执行，因此程序计数模块需要一个32位寄存器进行临时的指令存储，其中存储PC值，并连接一个加法器，在每次时钟上升沿时进行自增加一操作。\n除此之外，PC值也受一些控制信号的影响，例如JMP指令给出的PCSource信号和Beq指令给出的Branch信号，进行PC值的跳转，故该模块也要添加一些数据选择器，配合数位拓展单元对PC值进行更改。具体实现如下图所示。\n整体模块如下图x所示。\n4.1.5 LED显示单元 本次设计使用的开发板上有4位7段数显管，考虑将四位二进制通过一位数显管进行十六进制显示，因此只需要通过一些组合逻辑电路将输入的四位二进制转化为指定的数显管7位信号即可。另外，本次设计中仅考虑整数的相关运算，故无视数显管的小数点信号。\n通过查阅FPGA DE0开发板的用户手册可知，数显管的输入信号为低电平有效，该部分无明显的电路结构，仅在于逻辑转换，因此使用Verilog HDL代码实现。代码内容如下。\nmodule LEDHex(in, LED7S) ; input [3:0] in ; output reg [6:0] LED7S ; always@(in) begin case(in) 4\u0026#39;b0000:LED7S \u0026lt;= 7\u0026#39;b1000000; 4\u0026#39;b0001:LED7S \u0026lt;= 7\u0026#39;b1111001; 4\u0026#39;b0010:LED7S \u0026lt;= 7\u0026#39;b0100100; 4\u0026#39;b0011:LED7S \u0026lt;= 7\u0026#39;b0110000; 4\u0026#39;b0100:LED7S \u0026lt;= 7\u0026#39;b0011001; 4\u0026#39;b0101:LED7S \u0026lt;= 7\u0026#39;b0010010; 4\u0026#39;b0110:LED7S \u0026lt;= 7\u0026#39;b0000010; 4\u0026#39;b0111:LED7S \u0026lt;= 7\u0026#39;b1111000; 4\u0026#39;b1000:LED7S \u0026lt;= 7\u0026#39;b0000000; 4\u0026#39;b1001:LED7S \u0026lt;= 7\u0026#39;b0010000; 4\u0026#39;b1010:LED7S \u0026lt;= 7\u0026#39;b0001000; 4\u0026#39;b1011:LED7S \u0026lt;= 7\u0026#39;b0000011; 4\u0026#39;b1100:LED7S \u0026lt;= 7\u0026#39;b1000110; 4\u0026#39;b1101:LED7S \u0026lt;= 7\u0026#39;b0100001; 4\u0026#39;b1110:LED7S \u0026lt;= 7\u0026#39;b0000110; 4\u0026#39;b1111:LED7S \u0026lt;= 7\u0026#39;b0001110; default :LED7S \u0026lt;= 7\u0026#39;b1000000; endcase end endmodule 最终将二进制数字转化为特定的控制信号，以便于后续将信号绑定至开发板的数显管上，实现内容的显示，整合的模块内容如下图所示。\n4.2 控制单元设计 该部分内容为对控制单元进行详细的设计，包括控制信号与指令的对应关系，并通过组合逻辑电路的方式对各种控制信号进行实现，并将各控制信号的逻辑电路组合，即可实现基本的控制单元。从而实现输入指令码时同步产生特定的控制信号的功能。\n4.2.1 控制信号与指令的对应关系 经过指令功能与数据通路的分析，容易知道各指令需要的数据通路，并推出指定的控制信号值，其存在一一对应关系，如表所示。\n指令 OP PCSouces RegDst ALUSrcB ALUOp MemToReg RegWrite MemWrite Clear Branch Clear 000000 0 1 0 0 0 1 0 1 0 Mov 000001 0 1 0 1 0 1 0 0 0 Set 000010 0 0 1 1 0 1 0 0 0 ADD 000011 0 1 0 1 0 1 0 0 0 SUB 000101 0 1 0 0 0 1 0 0 0 JMP 000110 1 0 0 0 0 0 0 0 0 LW 000111 0 0 1 1 1 1 0 0 0 SW 001000 0 0 1 1 0 0 1 0 0 BEQ 001001 0 0 0 0 0 0 0 0 1 4.2.2 各控制信号的实现 逻辑表达式及其实现电路图。\n4.2.3 控制单元的组合 将各个控制信号的实现模块进行组合，实现整个控制单元，能够根据OP码为输入，解析出指定的控制信号。\n4.3 模块间连接 根据控制信号与数据通路，将各模块间进行线路连接。\n五、测试结果及分析 本次课程设计编写了9条指令，在完成CPU软件部分的基本搭建后，将对其进行功能测试。首先通过设计好的指令进行若干测试程序的编写，随后在软件层面通过波形图进行仿真检验，完成以上工作后，将基于Quartus II的仿真软件写入FPGA DE0开发板，并将特定的信号绑定到对应的信号灯上，以检验CPU与指令功能的正确性。\n5.1 程序编写 为测试设计的指令与CPU本身的功能正确性与完备性，通过Clear、Mov、Set、ADD、SUB、JMP、LW、SW、BEQ等指令进行若干段程序的编写，尝试测试加减法操作、数据的转移、数据的比较、存储器的读写、条件循环语句等功能。\n为方便表示，记寄存器ax的地址为00101，bx的地址为00110，cx的地址为00111，dx的地址为01000，ex的地址为01001。\n5.1.1 加减法测试 测试方案：\n将ax寄存器置数为6749H，bx寄存器置数为4238H，将ax与bx中的内容相加存于cx中，dx寄存器置数为1647H，将cx与dx中的内容相减存于ex中，最后使用JMP跳转指令回到程序开头并重复执行。\n编写程序：\nSet ax 6749H：\t00001000000001010110011101001001 Set bx 4238H：\t00001000000001100100001000111000 Add ax bx cx：\t00001100101001100011100000000000 Set dx 1647H：\t00001000000010000001011001000111 Sub cx dx ex：\t00010100111010000100100000000000 JMP 0：\t00011000000000000000000000000000 期望结果：\n检测并显示ALU的输出结果，应当分别在两条Set指令时显示6749H与4238H，ADD指令后显示相加结果A981H，执行下一条Set指令时应当显示1647H，SUB指令后显示相减结果933AH。\n5.1.2 循环语句测试 测试方案：\n计划实现for(int i=ax;i\u0026lt;=bx;i+=cx)的循环功能，首先设置循环变量的初始值ax、终止值bx、循环步长cx，这里令ax为1，bx为9，cx为1。随后使用BEQ指令判断ax和bx中的值是否满足小于等于关系，若满足则PC顺序执行，执行ADD指令，将ax与cx中的内容相加并覆盖于ax中，再使用JMP指令跳转回BEQ指令处，当不满足条件时则PC值向后增加，从而跳出循环程序。\n编写程序：\nSet ax 1H：\t00001000000001010000000000000001 Set bx 9H：\t00001000000001100000000000001001 Set cx 1H：\t00001000000001110000000000000001 BEQ ax bx：\t00100100101001100000000000001001 Add ax cx ax：\t00001100101001110010100000000000 JMP 3：\t00011000000000000000000000000011 EXIT 期望结果： 在设置初始变量时依次显示1、9、1，BEQ指令时不关注ALU的显示结果，ADD指令时查看ALU的结果，且此时应当隔两个上升沿再查看，应当显示ALU的结果依次从2到9，即实现简单的for循环功能。\n5.1.3 内存读写测试 测试方案：\n将ax置数3456H，bx置数1H，作为基址，以bx为基址，3H为偏移量进行内存寻址，将ax中的值存储到对应的内存单元中，再以同样的寻址方式将该内存单元中的内容读取到寄存器cx当中，最后将ax和cx的值进行相加存储到dx当中。\n编写程序：\nSet ax 3456H：\t00001000000001010011010001010110 Set bx 1H：\t00001000000001100000000000000001 SW bx ax 3H：\t00100000110001010000000000000011 LW bx cx 3H：\t00011100110001110000000000000011 ADD ax cx dx：\t00001100101001110100000000000000 JMP 0：\t00011000000000000000000000000000 期望结果： 检测ALU的输出值，在前两条指令时依次显示3456H和1H，SW时显示最终寻址到的内存地址，即为1H+3H=4H，LW指令也是如此，最后ADD指令时应当输出的结果为3456H*2的结果，即68AC。\n5.2 程序写入 完成程序的编写后，则需要将程序写入指令存储器中，本次课程设计采用MIF文件的方式，即内存初始化文件（Memory Initialization File），将每段程序处理成一个单独的MIF文件，并通过Quartus II软件将其设置到ROM中，即可完成程序的写入。\n以循环语句测试程序为例，对应的MIF文件如图所示，可以看到涉及到的六条指令被依次存放于0-5内存单元中。在Quartus II软件中，MIF文件有指定的可视化填写界面，便于MIF文件的生成和程序指令的写入。\n选中ROM模块，可以选择指定MIF文件，从而将程序指令预先写入到指令存储器当中，操作则如图所示。\n5.3 波形仿真 在将仿真工程上传至开发板之前，需要进行一定程度的工程编译与模拟，这里使用了基于ModelSim的波形仿真方法，将几个常见的控制信号、指令以及ALU的计算结果进行监测，分析其运行结果。该部分内容以循环语句测试程序为例。\n新建一个波形仿真文件vwf，将涉及到的节点均导入其中，这里仅以时钟信号clk为输入，各控制信号、当前指令、ALU结果为输出，并将其导入仿真文件，对时钟信号clk设置一定的周期信号，如图所示。\n运行仿真，观察结果。\n核对指令信息，如图所示。可以看到前三条指令（红色框）依次为Set指令，符合原先编写的代码内容，第四条指令为BEQ指令，值也与原先设置的指令内容一致，后面的指令则进入循环，这是由于BEQ指令的条件判断配合JMP指令的不断跳转使得程序进入循环，这也符合循环语句的实际功能。\n核对ALU计算结果，如图所示，可以看到前三条SET指令所对应的值正确，并在每一条ADD指令执行后ALU显示一串自增的值，从2开始，以步长为1自增，最终达到9，这也符合原先的程序设定。\n此外，检查控制信号，将其与表4.1进行核对比较，以检测控制单元的设计正确性。经检查，可以确认各指令的控制信号生成无误。\n5.4 硬件烧录 通过软件仿真，可以基本确定CPU以及各条指令的设计正确性，接下来将CPU设计文件编译并下载至开发板中，使用FPGA开发板进行CPU功能的实现。步骤整体包括引脚分配、程序编译、程序烧录。\n5.4.1 引脚分配 分析设计的CPU可知，执行的指令已经预先写入到ROM之中，唯一的输入信号便是时钟信号，而输出信号可以有很多，可以将其中的运算过程数据绑定到输出引脚上，从而能够显式地观察到执行过程。\n本次课程设计考虑将输入的时钟信号clk绑定到开发板的某一个按钮上，通过手动给与上升沿的方式控制指令的执行，开发板上自带的时钟信号频率过高，不易于执行过程的显示，但可以通过一个频率转换模块进行降频操作；输出信号部分，考虑将ALU的计算结果通过原先设计好的LED显示模块产生数显管信号，并依次绑定到开发板的指定引脚上，同时将控制信号绑定到LED等上，方便对指令的执行情况进行观察。\n对于开发板的引脚名及其对应信号，可以通过查阅DE0开发板的用户手册得知，在此不做赘述。例如Button0所对应的引脚编号为PIN_H2。\n使用Quartus II的Pin Planner工具即可完成对各输入输出信号的引脚分配，具体分配情况如图。\n5.4.2 程序编译 软件层面此时已完成了所能涉及到的所有配置，对程序进行编译，编译后Quartus II会自动在outputfile文件夹中生成sof文件，这是一个可重配置的逻辑设备文件，它包含了对 FPGA（现场可编程门阵列）进行重新编程所需的逻辑配置信息。在编译项目期间，Quartus II 将会综合和布局设计，并生成一个可被 FPGA 加载并执行的二进制文件sof。文件如图所示。\n5.4.3 程序烧录 使用Quartus II软件中的Programmer工具即可进行程序的烧录，选择上节中所提到的sof文件即可，在烧录之间，需要安装开发板的指定驱动，并使用串口连接线将其与项目所在的PC连接，启动开发板后Programmer工具即可自动识别开发板，选中sof文件后即可实现开发板的程序烧录。工具界面如图所示。\n点击start，观察进度到达100%后，即完成了程序的烧录，开发板已进入了程序运行的状态，由于设置了时钟信号由按钮控制，需要按按钮方可进行指令的顺序执行。\n5.5 运行结果记录 本节将对5.1节中设计的若干段测试程序进行运行测试，并记录开发板的显示结果。\n5.5.1 加减法测试程序运行结果 烧录程序，记录结果，如图所示，可以看到程序的运行结果与期望一致。包括加法后的结果与减法操作后的结果，均符合预计结果，6748H+4238H=A981H，A981H-1647H=933AH，由此判断CPU的基本运算功能无误，且程序进行了数据的读取转移，表现了寄存器堆寄存数据的功能的正确性。\n5.5.2 循环语句测试程序运行结果 烧录程序，记录结果，如图所示，可以看到程序的运行结果与期望一致。寄存器ax中的内容不断自增，直到到达终止条件bx中的值9，最终程序跳出循环。\n5.5.3 内存读写测试程序运行结果 烧录程序，记录结果，如图所示，可以看到程序的运行结果与期望一致。SW和LW之类执行时，ALU的结果为寻址地址，即为4H，与测试结果匹配，最后ADD指令会将两个3456H相加，得到结果68ACH，这可以说明通过内存进行数据的读写转移操作成功，数据3456H被顺利的复制。\n六、心得与体会 "},{"section":"Blog","slug":"/en/blog/database/","title":"【课程笔记】数据库原理与应用","description":"this is meta description","date":"September 25, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"219\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"数据库原理与应用","content":"一. 绪论 1. 数据库的几个基本概念 数据 描述事物的符号记录\n数据库 数据库时长期存储在计算机内、有组织、可共享的大量数据的集合\n数据库管理系统 位于用户和操作系统之间的一层数据管理软件\n包含以下功能：\n1.数据定义功能（提供数据定义语言DDL） 2.数据组织、存储和管理 3.数据操作功能（提供数据操作语言DML） 4.数据库的事务管理和运行管理 5.数据库的建立和维护功能\n数据库系统 由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理、维护数据的系统\n2. 数据库系统的特点 数据结构化 数据的共享性高、冗余度低且易扩充 数据独立性高 保证应用程序不会发生改变\n包含物理独立性和逻辑独立性\n物理独立性即指用户的应用程序域数据库中数据的物理存储方式是相互独立的；逻辑独立性则与数据库的逻辑结构相互独立\n数据由数据库管理系统统一管理和控制 DBMS需要提供以下数据控制功能\n数据的安全性保证 数据的完整性检查 并发控制 数据库恢复 3. 数据模型 数据模型是对现实世界数据特征的抽象，数据模型是用来描述数据、组织数据和对数据进行操作的。\n两类数据模型 概念模型：考虑ER图\n逻辑模型：包含层次模型、网状模型、关系模型、面向对象数据结构、对象关系数据模型、半结构化数据模型\n补充：物理模型是对数据最底层的抽象，是数据在计算机内部的表示方式和存取方式\n数据模型的组成要素 数据结构、数据操作和数据完整性约束条件这三个方面的内容完整地描述了一个数据模型。\n数据结构：描述数据库的组成对象以及对象之间的联系（描述静态特性）\n数据操作：对数据库中各类对象的实例允许执行的操作的集合，包括操作及有关的操作规则。（描述动态特性）\n数据的完整性约束条件：一组完整性规则，用于限定符合数据模型的数据库状态以及状态的变化，保证数据的这个却有效和相容。\n常用的逻辑数据模型 层次模型 优点：结构比较简单清晰、查询效率高、提供良好的完整性支持\n缺点：很多联系是非层次性的，如果一个节点具有多个双亲结点则难以表示，查询子节点必须经过双亲节点\n网状模型 优点：能够更为直接的描述现实世界，性能良好存储效率高\n缺点：结构复杂，DDL、DML较为复杂\n关系模型 关系模式：对关系的描述，一般表示为：关系名（属性1，属性2，\u0026hellip;，属性n）\n关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项。\n关系的完整性约束条件包含三大类：实体完整性、参照完整性、用户定义的完整性。\n优点：建立在严格的数学概念的基础上的；数据结构简单、清晰；存取路径对用户透明，具有更高的数据独立性\n缺点：查询效率往往不如格式化数据模型\n4.三级模式结构 模式是对数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及对型的描述，而不涉及具体的值。\n模式的一个具体值被称为模式的一个实例，模式是相对稳定的，而实例是相对变动的。\n模式 模式也称为逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n模式实际上是数据库数据在逻辑级上的视图，一个数据库只有一个模式。\n考虑成基本数据表。\n外模式 也称为子模式或者用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述\n外模式是模式的子集，一个数据库可以有多个外模式。\n考虑成用户视图。\n内模式 也成为存储模式，一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。\n外模式/模式映像 体现逻辑独立。\n模式改变时，对该模式映像进行改变，可以使外模式保持不变。\n应用程序是基于外模式编写的，从而让应用程序不必修改。\n模式/内模式映像 体现物理独立。\n模式/内模式映像是唯一的，定义了数据全局逻辑结构和存储结构之间的对应关系\n当存储结构发生改变时，对该模式映像进行改变，使得模式保持不变，从而顶层的应用程序也不必发生改变。\n二、关系数据库 1. 关系与关系模式 2. 关系操作 基本的关系操作 关系数据语言的分类 3. 关系的完整性 4. 关系代数 三、关系数据库标准语言SQL 四. 数据库安全性 数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。\n1. 不安全因素 非授权用户对数据库的恶意存取和破坏 数据库中重要或敏感的数据被泄露 安全环境的脆弱性 2. 安全标准 TCSEC/TDI将系统划分为4组共7个等级\n自高到低分别为：A1、B3、B2、B1、C2、C1、D\nCC标准\n低到高EAL1到EAL7，与上对应\n3. 数据库安全性控制 用户身份鉴别：静态口令鉴别（密码）、动态口令鉴别（验证码）、生物特征鉴别、智能卡鉴别 存取控制（自主和强制） 自主存取控制方法：授权 4. 自主存取控制 用户权限包含两个要素：数据库对象和操作类型\n存取控制的对象包含：数据本身（数据、属性列、具体数据）以及数据库模式（包含模式、基本表、视图、和索引的创建）。\n为什么要授权：是数据库安全控制中的自主存取控制方法，为了保护数据库、防止不合法的操作对数据库造成泄露、更改或毁坏。\n授权GRNAT GRANT 权限 ON 对象类型 对象名 TO 用户名 [WITH GRANT OPTION]\n用户可以是：一个或多个具体用户，也可以是PUBLIC，指全体用户。\nWITH GRANT OPTION子句：可以把权限再授予其它的用于。\n所有权限：ALL PREVILEGES\n不允许循环授权！\n收回授权REVOKE REVOKE 权限 ON 对象类型 对象名 FROM 用户名 [CASCADE|RESTRICT]\nCASCADE：级联回收，将用户传播出去的权限一并收回。（默认为CASCADE）\nRESTRICT：受限回收。若用户传播该权限，则无法进行权限回收。\n创建数据库模式的权限 以上授权均为对数据的操作权限，若要给与创建模式的权限则需要在创建用户时实现。\nCREATE USER 用户名 [WITH] [DBA|RESOURSE|CONNECT]\n只有超级用户才能创建数据库用户\nDBA权限可以：创建用户、创建模式、创建表、登录数据库执行查询和操纵\nRESOURSE权限：不可以创建用户、模式，可以创建表，可以登录数据库执行查询和操纵\nCONNECT权限：啥都不可以创建，可以连接数据库，具体操作权限需要被授权才可以。\n数据库角色 角色就是一组权限的集合\nCREATE ROLE 角色名\n在一个角色中添加角色或者用户：\nGRANT 角色 TO 某角色/某用户 [WITH ADMIN OPTION]\n如果指定WITH ADMIN OPTION子句，则表示可以把这种权限再授予其它角色\n给角色授权：\nGRANT 权限 ON 对象类型 对象名 TO 角色；\n授权授权：\nREVOKE 权限 ON 对象类型 对象名 FROM 角色；\n5. 强制存取控制 将实体划分为主体和客体\n主体就是活动实体，例如实际用户\n客体就是被动实体，例如文件、基本表、索引\n为每个实例派发一个敏感度标记，对主体来说为许可证级别，对客体来说是密集\n级别由：绝密TS、机密S、可信C、公开P\n当且仅当主体的许可证级别大于等于客体的密级时，该主体才能够读相应的客体。\n当且仅当主体的许可证级别小于等于客体的密级时，主体才能写相应的客体。\n6. 视图机制 通过视图机制把要保密的数据对无权存取的用户英藏起来\n7. 审计 把对数据库的所有操作都记录到审计日志中，然后可以通过日志审计这个里面是否有一些违法行为。\nAUDIT 操作 ON 对象；对某个对象的某个操作进行审计\nNOAUDIT 操作 ON 对象；取消审计\n是一种事后检查的安全机制。\n8. 数据加密 存储加密 透明存储加密：数据在写道磁盘时对数据进行加密（内核级）\n非透明加密：多个加密函数实现\n传输加密 五. 数据库完整性 1.定义 数据库的完整性是指数据的正确性、相容性\n正确性：数据是符合现实世界语义、反映当前实际状况的\n相容性：数据库同一对象在不同关系表中的数据是符合逻辑的\n区别完整性和安全性：完整性保证不存在不符合语义的数据，安全性是保护数据库被恶意破坏或者非法存取\n数据库管理系统需要实现：\n提供定义完整性约束条件的机制\n提供完整性检查的方法\n进行违约处理\n2. 实体完整性 定义 关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。\n有两种说明方法：列级约束条件（在属性后面直接定义）、表级约束条件（一张表后进行定义）\nCREATE TABLE STudent ( Sno CHAR PRIMARY KEY, 列级 PRIMARY KEY(Sno) 表级 ) 检查和违约处理 插入或者修改时自动进行检查：\n检查主码值是否唯一，不唯一则拒绝修改。 检查主码的各个属性值是否为空，只要有一个为空则拒绝修改 检查是否唯一的一种方法是全表扫描并依次对比，或者建立索引进行查找。\n3. 参照完整性 定义 在CREATE TABLE上用FOREIGN KEY短语进行外码的定义，使用REFERENCES短语指明外码参照哪些表的主码。\n检查和违约处理 对被参照表和参照表进行增删改操作时可能会破坏参照完整性约束，必须检查两个表的相容性。\n处理策略包括：\n拒绝执行NO ACTION（默认策略） 级联操作CASCADE 例如删除学生，对应的选课记录也会被删除。\n例如，这样会在删除Student表中的元组后级联删除SC表的对应项，修改同理。\nFOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE ON UPDATE CASCADE 设置为空值 4. 用户定义的完整性 定义 在建表时要求定义属性上的约束条件，即属性值限制\n包括：\n列值非空\n列值为一\n检查列值是否满足一个条件表达式（CHECK 短语）\n分为以下定义方法：\n属性上的定义：直接跟在属性后面 元组上的定义：表级类似，在表的最后进行CHECK语句的编写，一般这样能够控制多个属性 违约处理 拒绝执行\n5. 完整性约束命名子句 定义 CONSTRAINT 完整性约束条件名 \u0026lt;完整性约束条件\u0026gt;\n完整性约束条件包括NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK短语等。\n可以直接跟在属性的定义后面（对属性的一些约束）.\nCREATE TABLE Student( Sno CHAR(20) CONSTRAINT C1 CHECK(Sno BETWEEN 2000 AND BETWEEN 3000), ) 或者表级：\nCREATE TABLE Student( Sno CHAR(20), CONSTRAINT StudentKey PRIMARY KEY(Sno)， CONSTRAINT ForeignKey FOREIGN KEY(Sno) F, ) 修改 使用ALTER TABLE语句修改表中的完整性限制\nALTER TABLE Student DROP CONSTRAINT C4\nALTER TABLE Student ADD CONSTRAINT C1 CHECK(\u0026hellip;)\n6. 断言 创建断言：\nCREATE ASSERTION 断言名 \u0026lt;CHECK子句\u0026gt;\n断言创建后，任何对断言中涉及的关系的操作会触发对断言的检查，不符合断言的则被拒绝执行\n例如限制所有课程最多60名学生选修：\nCREATE ASSERTION CHECKX CHECK( 60\u0026gt;=ALL( SELECT COUNT(*) FROM SC GROUP BY Cno ) ) 增加表的属性：ALTER TABLE \u0026lt;X\u0026gt; ADD \u0026lt;NAME\u0026gt; \u0026lt;TYPE\u0026gt;\n7. 触发器 CREATE TRIGGER SC_T AFTER UPDATE OF Grade ON SC 触发事件 REFERENCING OLDROW AS old NEWROW as new FOR EACH ROW\t行级触发器，每执行一次对Grade的更新就会触发一次 行级有OLDROW和NEWROW 语句级触发器为FOR EACH STATEMENT 语句级有 NEWTABLE和OLDTABLE WHEN(new.Grade\u0026gt;=1.1*old.Grade) INSERT..... 需要对每一行数据做处理则使用行级触发器\n语句执行完后再执行语句的后续业务处理逻辑则使用语句级\n再举例：\nCREATE TRIGGER Insert_s BEFORE INSERT OR UPDATE ON Teacher REFERENCING NEWROW AS newT FOR EACH ROW BEGIN IF(newT.Job=1) AND(...) THEN newT.Sal:=4000 END IF; END; 触发器的激活：\n先BEFORE触发器，再激活触发器的SQL语句，最后AFTER触发器\n相同级别的谁先创建谁执行。\n删除触发器：\nDROP TRIGGER \u0026lt;触发器名\u0026gt; ON \u0026lt;表\u0026gt;\n六. 关系数据理论 纸质笔记\n七. 数据库设计 1. 数据库设计的一般定义 数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。\n2. 数据库设计的特点 数据库建设的基本规律：\n三分技术，七分管理，十二分基础数据\n结构（数据）设计和行为（处理）设计相结合。\n3. 数据库设计的步骤 需求分析：明确用户的需求，确定系统边界，生成数据字典和用户需求规格说明书 概念结构设计：概念模型-ER图 逻辑结构设计：ER转换为关系模型，根据范式规范理论对其进行优化，设计用户子模式 物理结构设计：关系模式选择存取方法、设计关系、索引等数据库文件的物理存储结构，确定数据库的存储结构 数据库实施：实际建立数据库结构、试运行、装入数据 数据库运行和维护 数据库的维护工作包含以下几个方面：\n数据库的转储和恢复\n数据库的安全性、完整性控制\n数据库性能的监督、分析和改造\n数据库的重组织与重构造\n八. 数据库编程 1.嵌入式SQL与主语言之间的通信 SQL向主语言传递执行状态信息，主要通过SQL通信区实现 主语言向SQL提供参数，主要通过主变量实现 将SQL语句查询数据库的结果交还给主语言处理，主要用主变量和游标实现 SQL通信区 SQL语句执行后的执行状态信息将送到SQL通信区中，应用程序从中取出这些信息，据此决定接下来指定的语句\n使用EXEC SQL INCLUDE SQLCA加以定义\n主变量 SQL语句中使用的主语言程序变量简称为主变量（即SQL使用主语言的变量）\n输入主变量由应用程序赋值，SQL引用\n输出主变量由SQL赋值或设置状态信息，返回应用程序\n一个主变量可以附带一个任选的指示变量（整型），用来指示所指的主变量的值或条件\n主变量名和指示变量名前面要加冒号（：）作为标识\n所有主变量和指示变量必须在SQL语句 BEGIN DECLARE SECTION 和 END DECLARE SECTION之间进行说明\n游标 一条SQL可能产生多条记录，而主语言面向记录的，一组变量一次只能存放一条记录，因此引入游标来协调这两种不同的处理方法，可以看作一个数据缓冲区，用来存放SQL语句的执行结果，每个游标区都有自己的名字\n建立连接 建立连接的嵌入式SQL语句为：\nEXEC SQL CONNECT TO target [AS connection-name] [USER user-name]；\ntarget就是要连接的数据库服务器，connection-name时可选的连接名\n关闭连接 EXEC SQL DISCONNECT {CONNECTION}\n2. 游标相关 不用游标的SQL语句 查询结果为单条记录的SELECT语句 非CURRENT形式的增删改语句 使用游标的SQL语句 查询结果为多条记录的SELECT语句 CURRENT形式的UPDATE和DELETE语句 3. 动态SQL 使用SQL语句主变量 程序的主变量包含的内容就是SQL语句的内容，这样的变量即为SQL语句主变量\n可以进行动态SQL语句的执行，就是执行这种包含在变量中的SQL语句\n动态参数 动态参数是SQL语句中的可变元素，使用参数符号（？）表示该位置的数据在运行时设定\n4. 过程化SQL 基本的SQL语句是高度非过程化的语言，过程化SQL是对SQL的扩展，使其增加了过程化语句功能。过程化SQL程序的基本结构是块，所有的过程化SQL程序都是由块者组成的，块之间可以相互嵌套，每个块完成一个逻辑操作。\n常量变量的定义 变量定义\n变量名 数据类型:=初值\n常量定义\n常量名 数据类型 CONSTANT:=常量表达式\n赋值语句\n变量名:=表达式\n流程控制 条件控制语句和循环控制语句\nIF condition THEN\n​\txxxxx\nEND IF；\nIF condition THEN\n​\txxxxx\nELSE\n​\txxxxx\nEND IF；\nLOOP\n​\txxxxx\nEND LOOP；\nWHILE condition LOOP\n​\txxxxx\nEND LOOP；\nFOR count IN [REVERSE] bound1..bound2 LOOP\n​\txxxxx\nEND LOOP;\n5.存储过程和函数 过程化的SQL块有两种类型，命名块和匿名块\n匿名块每次执行都要编译，不能被存储到数据库中，也不能在其它过程化SQL块中被调用。\n函数和过程都是命名块，编译完成后保存在数据库中，也成为持久性存储模块。\n存储过程优点 提供了在服务器端快速执行SQL语句的有效途径\n降低了客户机和服务器之间的通信量\n方便实施企业规则\n存储过程的定义 CREATE OR REPLACE PROCEDURE 过程名([参数1，参数2]) AS 过程化SQL块 存储过程的执行 CALL PROCEDURE 过程名（[参数1，参数2]）\n存储过程的修改 ALTER PROCEDURE 过程名1 RENAME TO 过程名2\n函数 和过程类似，定义有所区别，将PROCEDURE换成FUNCTION即可\n定义如下：\nCREATE OR REPLACE FUNCTION 函数名([参数]) RETURNS 类型 九、关系查询处理和查询优化 1. 查询处理步骤 查询分析 对查询语句进行扫描、词法分析和语法分析\n查询检查 对合法的查询语句进行语义检查\n这时候的完整性检查时初步的、静态的检查，检查通过后便把SQL查询语句转换为内部表示，即等价的关系代数表达式，一般用查询树或者语法分析树来表示拓展的关系代数表达式。\n查询优化 物理优化：是指存取路径和底层操作的算法选择，选择的依据可以是基于规则的，也可以是基于代价的，还可以是基于语义的\n代数优化：关系代数表达式的优化，按照一定规则进行等价变换\n查询执行 由代码生成器生成执行查询计划的代码，然后加以执行返回结果\n2. 查询操作的算法示例 选择操作 全表扫描算法 索引扫描算法 连接操作 嵌套循环算法 排序-合并算法：排完序之后再循环扫描，扫描到不一样的元素就跳下一个 索引连接算法：一个表建立索引，另一个表按照索引去连接 hash join算法：hash作为索引，开桶放元组，另一个表查桶并做链接 3. 代数优化 4. 物理优化 十.数据库恢复技术 1. 事务 定义 事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位\n一个事务可以是一个SQL语句，一组SQL语句，或者整个程序。一般来说一个程序包含多个事务。\n事务是恢复的基本单位，也是并发控制的基本单位。\n相关SQL语句 开始语句：BEGIN TRANSACTION\n结束语句：COMMIT 表示提交事务的所有操作 或者 ROLLBACK 表示回滚，即事务运行中发生了某种故障，需要对已经完成的操作进行撤销，回滚到事务的开始状态。\n2. 事务的4个特性 原子性 一个事务要么全做、要么全部都不做\n一致性 事务执行的记过必须一致，如果一个事务被迫中断，即事务中的一些操作做了，剩下的还没做，且做了对数据库造成的修改已经存入数据库的化，就会导致数据库处于不一致的状态。因此事务要么全做要么全不做，一致性与原子性密切相关\n隔离性 一个事务的执行不能被其他事务干扰\n持续性（永久性） 一个事务一旦提交，他对数据库中的数据改变应该是永久性的\n3. 数据库系统的故障种类 事务内部的故障 有的是可以通过事务程序本身发现的而直接进行ROLLBACK的，有的是非预期的 事务故障的情况下，数据库可能处于不正确的状态，恢复程序要在不影响其它事务运行的情况下强行回滚该事务，撤销该事务造成的修改，这类恢复操作成为UNDO（事务撤销）。\n系统故障 系统停止运转的任何事件，使得系统要重新启动（硬件错误，操作系统故障，DBMS代码错误，断电等）\n系统故障的情况下，在系统重新启动后，恢复子系统除了要撤销未完成的事务之外，还要REDO（事务重做）已提交的事务（但数据还在缓冲区没有被写入到数据库之类的）\n介值故障 就是硬故障，损毁之类的\n计算机病毒 4. 恢复技术的实现 恢复机制涉及的两个关键问题：如何建立冗余数据 如何利用冗余数据进行数据库的恢复\n恢复的基本原理：利用存储在后备副本、日志文件和数据库镜像中的冗余数据来重建数据库\n数据转储 DBA定期将整个数据库复制到磁带、磁盘或者其它存储介质上保存起来，这些备用数据被称为后备副本或者后援副本。重新装入副本即可恢复，但只能恢复到存储时的状态，想要恢复到故障发生的状态还需要REDO转储后的所有更新事务。\n分为：静态转储（在系统中无运行事务时进行）、动态转储（转储期间允许对数据库进行存取和修改）\n也可分为：海量转储、增量转储\n登记日志文件 日志文件是用来记录事务对数据库的更新操作的文件，有两种格式：以记录为单位、以数据块为单位\n以记录为单位的日志文件：\n登记各个事务的开始（BEGIN TRANSACTION）和各个事务的结束（COMMIT/ROLLBACK）、各个事务的所有更新操作。\n日志记录的内容：事务标识（哪一个事务）、操作类型（增删改）、操作对象（记录内部标识）、更新前数据的旧值、更新后数据的新值\n以数据块为单位的日志文件：\n日志记录的内容：事务标识、被更新的数据块\n日志文件的作用：\n事务故障恢复和系统故障恢复必须使用日志文件 在动态转储方式中必须建立日志文件，后备副本和日志文件结合（可以进行介质故障恢复）才能够有效恢复数据库 静态转储方式也可以建立日志文件，首先转储完后登记日志文件，在恢复时首先回到转储完的结果，再REDO日志文件中已经完成的事务，尚未完成的进行UNDO即可实现恢复。 登记日志文件的原则：\n登记的次序严格按并发事务执行的时间顺序 必须先写日志文件，后写数据库（防止写了数据库后日志文件未写入而导致该部分内容丢失） 5. 恢复策略 事务故障的恢复 由系统自动完成，对用户透明，利用日志文件UNDO此事务对数据库进行的修改\n系统故障的恢复 由系统重新启动时自动完成，不需要用户的干预：UNDO故障时未完成的事务，REDO已完成的事务\n正向扫描，有COMMIT的就表示已完成，放到REDO-LIST中，反之放到撤掉队列UNDO-LIST\n介质故障的恢复 恢复方法是重装数据库+重做已完成的事务\n首先装入最新的数据库后备副本，使数据库恢复到最近一次转储的一致性状态，对于动态转储的还需要装入从转储开始的日志文件副本才能将数据库恢复到一致性状态。\n其次装入相应的日志文件副本，通过REDO已完成，UNDO未完成的方法进行恢复\n6. 具有检查点的恢复技术 在日志文件中增加了检查点记录：在检查点之前的事务已经做完的了的不需要重做，如图即可。\n检查点的记录内容 建立检查点时期所有正在执行的事务清单\n这些事务最近一个日志记录的地址\n动态维护日志文件的方式是：周期性地执行建立检查点、保存数据库状态的操作。\n检查点记录步骤 将当前日志缓冲区中的所有日志记录写到磁盘的日志文件上。 在日志文件中写入一个检查点记录 在当前数据缓冲区中的所有数据记录写入磁盘的数据库中（保证如果一个事务在检查点之前提交，则T对数据库所做的修改一定会都写入到数据库中） 把检查点记录在日志文件中的地址写入一个重新开始文件 检查点恢复步骤 重新开始文件中找到最后一个检查点记录在日志文件中的地址 拿到该记录点中记录的所有正在执行的事务清单 首先放到UNDO-LIST中 从检查点开始正向扫描日志文件 有新开始的事务T就放到UNDO中 有提交的事务就把它从UNDO放到REDO中 7. 数据库镜像 自动把整个数据库或者其中的关键数据复制到另一个磁盘上，保证数据库和镜像一致性\n没有故障发生时还可以用于并发操作。\n十一. 并发控制 事务是并发控制的基本单位\n1. 数据不一致性 丢失修改：两个事务读入同一数据并修改，T2的提交破坏了T1提交的结果，导致T1的修改被丢失 不可重复读：T1读取数据后，T2执行更新操作，导致T1无法再现前一次读取结果。 读”脏“数据：T1修改某一数据后T2读，但是T1回滚了数据，导致T2读脏 并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。\n并发控制的主要技术有封锁、时间戳、乐观控制法、多版本并发控制等。\n2. 封锁 基本的封锁类型有两种：排他锁（X锁，写锁）和共享锁（S锁，读锁）\n加了X锁后其它事务不能再对对其加任何类型的锁，加了S锁后只能够读但不能修改，也不能再让别的事务加X锁。\n3. 封锁协议 一级封锁协议 T再修改R之前先对其加X锁，直到事务结束再释放锁\n二级封锁协议 在一级封锁协议基础上增加事务T在读取R之前必须加S锁，读完后可立即释放S锁\n三级封锁协议 读R时加S锁，等到事务结束才释放\n解决了”不可重复读“问题，因为如果当读完之后立马放锁，在事务期间别的事务可能会进行数据的修改，导致下一次读取时读不到原有的数据。\n4. 死锁 死锁预防 一次封锁法（对所有要使用的数据进行加锁）、顺序封锁法（对数据对象规定一个封锁顺序，所有事务按照顺序封锁）\nDBMS在解决死锁的问题上普遍采用的是诊断并解除死锁方法\n死锁诊断与解除 超时法：如果一个事务的等待事件超过了规定的时限就认为发生了死锁，可能误判或者不能及时发现 等待图法，构建事务等待图（节点表示运行的事务，边表示事务等待的情况）存在回路则表示出现了死锁，选择一个处理死锁代价最小的事务进行UNDO操作，释放该事务所持有的所有锁。 5. 可串行化调度 多个事务并发执行的结果=这些事务按照某种次序串行执行的结果，即为可串行化。\n一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。\n如何进行可串行化的判断？\n冲突可串行化调度 冲突操作：不同事务对同一个数据的读写操作和写写操作\n不同事务的冲突操作和同一事务的两个操作时不能进行交换的\n通过交换两个事务不冲突操作的次序得到一个串行的调度，则称当前调度为冲突可串行化的调度。\n冲突可串行化调度一定为可串行化的调度，反之不一定。\nSc=R1(A)W1(A)R2(A)W2(A)R1(B)W1(B)R2(B)W2(B)\n交换W2(a)和R1(B)W1(B)\n=R1(A)W1(A)R2(A)R1(B)W1(B)W2(A)R2(B)W2(B)\n交换R2(A)和R1(B)W1(B)\n=R1(A)W1(A)R1(B)W1(B)R2(A)W2(A)R2(B)W2(B)\n变为串行调度T1和T2了，则表示原Sc是冲突可串行化调度。\n6. 两端锁协议（2PL） 所有事务必须分为两个阶段对数据项加锁和解锁\n获得封锁（拓展阶段）：在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁。 释放封锁（收缩阶段）：在释放一个封锁之后，事务不再申请和获得其他任何封锁 若并发执行的所有事务均遵守2PL，则这些事务对任何并发调度策略都是可串行化的。\n7. 封锁的粒度 封锁对象的大小被称为封锁粒度。\n封锁粒度与系统的并发度和并发控制的开销密切相关。\n一个系统中同时支持多种封锁粒度供不同的事务选择是比较理想的，这种封锁方法被称为多粒度封锁。\n多粒度树。\n多粒度封锁 允许多粒度树上的每一个节点独立的加锁。对一个节点加锁意味着这个节点的所有子节点也被加上了同类型的锁。\n显示封锁：直接加到数据对象上的锁\n隐式封锁：由于其上级节点加锁而导致该数据对象加上了锁。\n显示隐式封锁都要进行检查\n意向锁 含义：如果对一个节点加意向锁，则说明该节点的下层节点正在被加锁，对任意一个节点加锁时，必须先对它的上层节点加意向锁。\n例如：对任一元组加锁时，必须对他所在的数据库和关系加意向锁。\n意向锁包含：意向共享锁IS、意向排他锁IX、共享意向排他锁SIX。\nIS锁：如果对一个节点加了IS锁，表示它的后裔节点（意向）加S锁\nIX锁：如果对一个节点加了IX锁，表示它的后裔节点（意向）加X锁\nSIX锁：如果对一个数据对象加了SIX锁，表示对它加了S锁，再加了IX锁。例如对某个表加了SIX锁，表示该事务要读整个表，故加了S锁，同时会对个别元组进行更新操作，即子节点意向加X锁，故对表要加IX锁。\n任意事务T要对一个数据对象加锁，必须对他的上层节点加意向锁，申请封锁应该是按照自上而下的顺序进行，解锁应当自下而上。\n"},{"section":"Blog","slug":"/en/blog/software-engineering/","title":"【课程笔记】软件工程","description":"this is meta description","date":"September 25, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"219\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/opticalflow/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/opticalflow\\/image-3_hue7cf7ea89128ba28bd2370291193be06_375826_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"软件工程","content":"1. 软件工程概述 1.1 软件的本质 软件是：\n（1）指令的集合（计算机程序），通过执行这些指令可以满足预期的特性、功能和性能需求；\n（2）数据结构，使得程序可以合理利用信息；\n（3）软件描述信息，它以硬拷贝和虚拟形式存在，用来描述程序的操作和使用。\n补充：软件是逻辑的而非物理的系统元素，软件不会“磨损”，但是软件退化是存在的，不断的变更时软件退化的根本原因。\n1.2 软件工程学科 定义 将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件。\n软件工程是一种层次化的技术。\n根本特性 可靠性、运行效率、经济性、工程化\n层次结构 自顶向下为工具、方法、过程、质量关注点。\n软件工程六大目标 达到要求的软件功能、取得较好的软件性能、开发出高质量的软件、付出较低的开发成本 、需要较低的维护费用 、能按时完成开发工作并及时交付使用\n软件工程七大原则 用分阶段的生命周期计划严格管理、坚持阶段评审、严格实施产品控制、采用现代的程序设计技术、结果应该能明确审查、开发成员应该少而精、承认不断改进软件工程实践的必要性。\n软件工程实践七大原则 Hooker的概括性原则\n存在价值、保持简洁KIS、保持愿景、关注使用者、面向未来、提前计划复用、认真思考\n软件工程实践四个精髓 理解问题、策划解决方案、实施计划、测试结果的正确性\n理解问题：谁将从问题的解决中获益？有哪些是未知的？哪些数据、功能和特征是解决问题必须的？问题可以划分吗？可以图形化描述吗？可以建立分析模型吗？ 策划解决方案：以前曾经见过类似问题吗?（可以识别一些模式？）类似问题是否解决过？可以定义子问题吗？如果可以，子问题是否已有解决方案？能用一种可以很快实现的方式来描述解决方案吗?能构建出设计模型吗？ 实施计划：解决方案和计划一致吗？解决方案的每个组成部分是否可以证明正确？ 测试结果：能够测试解决方案的每个部分？解决方案是否产生了与所需求的数据、功能和特征一致的结果?是否按照项目利益相关者的需求进行了确认？ 诞生的根本原因 软件工程诞生的根本原因：软件危机\n表现形式包括：\n软件开发进度难以预测 软件开发成本难以控制 用户对产品功能难以满⾜ 软件产品质量⽆法保证 软件产品难以维护 1.3 软件过程 定义 软件过程是工作产品构建时所执行的一系列活动、动作和任务的集合。\n活动：主要实现宽泛的目标（如与利益相关者进行沟通），与应用领域、项目大小、结果复杂性之类的没有关系\n动作：例如体系结构设计，包含主要工作产品生产过程中的一系列任务\n任务：关注小而明确的目标，能够生产实际产品\n过程框架 过程框架定义了若干个框架活动：沟通、策划、建模、构建、部署。\n框架活动可以不断迭代应用，每次项目迭代都会产生一个软件增量。\n普适性活动 软件工程过程框架活动由很多普适性活动来补充：软件项目跟踪和控制、风险管理、软件质量保证、技术评审、测量、软件配置管理、可复用性管理、工作产品的准备和生产。\n通用的框架活动和普适性活动构成了软件工程工作的体系结构轮廓。\n1.4 相关思考 软件工程的意义？\n软件工程是指导计算机软件开发和维护的工程学科，采用工程的原理，技术、概念和方法来开发和维护软件，把经过实践检验的正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并维护它。\n如何理解“工程化软件开发”与到目前为止大家所熟悉的“编程”之间的区别？\n概括过程框架。当谈及框架活动适用于所有的项目时，是否意味着对于不同规模和复杂度的项目可应用相同的工作任务？请解释\n普适性活动存在于整个软件过程中，他们均匀分布在软件过程中，还是集中在某个或者某些框架活动中？\n2. 软件过程 软件过程定义为一个创建高质量软件所需要完成的活动、动作和任务的框架。（过程框架）\n2.1 通用过程模型 框架活动 沟通、策划、建模、构建以及部署（在过程框架中定义的）\n普适性活动 软件项目跟踪和控制、风险管理、软件质量保证、技术评审、测量、软件配置管理、可复用性管理、工作产品的准备和生产\n过程流 过程流描述了在执行顺序和执行时间上如何组织框架中的活动、动作和任务。\n线性过程流：从沟通到部署顺序执行五个框架活动。\n迭代过程流：在执行下一个活动之前重复执行之前的一个或者多个活动\n演化过程流：采用循环的方式执行各个活动，每次循环都能产生更为完善的软件版本（增量交付）。\n并行过程流：将一个或者多个活动与其他活动并行（例如软件不同方面的构建活动可以并行执行）\n任务集 每一个软件工程动作（例如需求获取，一种与沟通活动相关的动作）都是由若干个任务集构成，而每一个任务集都由软件工程工作任务、相关工作产品、质量保证点和项目里程碑组成。\n（要适合开发团队特点，因此软件工程动作可以根据项目的特定需要和团队特点进行调整）\n2.2 惯用过程模型 每一个模型都对框架活动有不同的侧重，并且定义了不同的过程流以不同的方式执行每一个框架活动（以及软件动作和任务）\n瀑布模型 线性顺序模型，是一个系统的、顺序的软件开发方法。\n首先清晰地了解要解决问题的需求，然后顺序开展框架活动，最终交付完整的软件产品，并开展后续的技术支持和维护\n问题：1.实际项目很少完全遵循瀑布模型提出的顺序；2.客户难以在一开始就完整、准确地描述需求；3.客户必须要有耐心，因为只有在接近到项目尾声的时候，才能得到可执行的程序；4.在评审可运行程序之前，可能不会检测到重大错误。\n原型开发过程模型 当客户只定义了软件的一些基本任务，但是没有详细定义功能和特征需求。（需求很模糊的时候）\n将开发过程分成若干原型增量，每次增量选择一部分需求（最关键、最核心的需求）作为交付目标，产出一个可执行的中间产品。\n每个增量产出的中间产品可以提供给客户或用户，用于发现问题或者潜在的新需求。\n（原型是一个可实地运行的模型,有正式产品的主要特征,但不是全部特征。软件原型是软件系统的最初版本,以最少的费用,最短的时间开发出的、以反映最后软件的主要特征的系统。）\n演化过程模型 也称为螺旋模型，是风险驱动的周期性迭代，结合了原型迭代性质和瀑布模型的可控性和系统性的特点，采用迭代或者增量的方式开发高质量软件。\n螺旋模型被分割称一系列由软件工程团队定义的框架活动。\n螺旋模型将软件开发为一系列演进版本，在早期的迭代中，软件可能是一个理论模型或者是原型，在后来的迭代中会产生一系列逐渐完整的系统版本。\n包括：抛弃式原型和增量式原型\n主要问题：难以判断螺旋演进何时结束\n统一过程模型 统一过程（UP）建立了迭代的、增量的过程流，提供了演进的特征。\nUML——统一建模语言包含大量用于面向对象系统建模和开发的符号，作为需求模型和设计模型的表示方法。\n包括：\n​\t起始阶段：包含客户沟通和策划活动，该阶段识别基本的业务需求，并用用例初步描述每一类用户所需要的主要特征和功能。\n​\t细化阶段：包括沟通和通用过程模型的建模活动。细化拓展了初始阶段定义的用例，创建了用例模型、分析模型、设计模型、实现模型、部署模型。\n​\t构建阶段：和通用软件过程中的构建活动相同。软件增量所要求的必须具备的特征和功能在源代码中实现。随着构建的实现需要对构件设计并实施单元测试。\n​\t转换阶段：包括通用软件过程中的构建活动后半期和部署活动的第一部分。软件被提交给最终用户进行Beta测试，用户反馈报告缺陷以及必要的变更。在转换阶段结束时，软件增量成为可用的发布版本。\n​\t生产阶段：和通用软件过程中的部署活动一致。对软件进行监控，提供运行环境的支持。\n有可能在构建、转换和生产阶段的同时，下一个软件增量的工作已经开始了，即五个UP阶段不一定顺序执行，而是阶段性的并发进行。\n2.3 相关思考 描述三个适用于原型模型以及三个瀑布模型的软件项目\n原型：用户界面，需求不明确的项目，用户参与的项目\n瀑布模型：稳定需求和规范明确的项目，对项目整体和成本高度控制的项目，不需要频繁变更的项目\n可以合用几个过程模型吗？如果可以，举例说明\n假设有一个大型软件项目，其中一部分需求相对稳定而另一部分需求可能会频繁变化。在这种情况下，可以考虑将项目分为两个主要部分：混用演化（敏捷过程模型）与瀑布。\n统一过程和UML是同一概念 ？\n开发质量足够好的软件的优点和缺点是什么？也就是说当我们追求开发速度胜过产品质量的时候会产生什么后果？\n3. 敏捷和敏捷过程 3.1 敏捷概念 普遍存在的变更是敏捷的基本动力，敏捷不仅是有效的响应变更，还是敏捷开发宣言中提及的哲学理念。\n强调可运行软件的快速交付而不那么看重中间产品。\n敏捷可以应用于任何软件过程。\n3.2 敏捷过程 敏捷过程必须具有可适应性（对于快速变更的项目和技术条件，以解决不可预测性的过程）\n敏捷软件过程必须增量式地适应。应该使用增量式开发策略，在很短的时间间隔内交付软件增量（可执行原型或者部分实现的可运行系统）来适应变更（不可预测的）的步伐。\n3.3 敏捷开发宣言 敏捷软件开发宣言 个体和互动 高于 流程和工具 工作的软件 高于 详尽的文档 客户合作 高于 合同谈判 响应变化 高于 遵循计划\n也就是说，尽管右项有其价值，我们更重视左项的价值。\n敏捷软件的十二条原则 敏捷宣言遵循的原则 (agilemanifesto.org) 3.4 Scrum 基本概念 是一种敏捷过程模型，Scrum原则和敏捷宣言是一致的。过程由“需求、分析、设计、演化和交付”等框架性活动组成。\n每一个框架活动中，工作任务在相对较短的时间盒的期限内完成称为一个冲刺。\n组成 Scrum团队由产品负责人、Scrum master和一个小型（3~6人）开发团队组成。\nScrum开发的主要制品是：产品待定项、冲刺待定项和代码增量。\n开发将项目分解为一系列称为冲刺的增量原型开发周期，每个周期2~4周。\n产品待定项：产品需求或特征的优先级列表，可为客户提供业务价值，在产品负责人同意且开发团队认可后，可以随时将项目添加到待定项中。（可以理解成：对于客户来说的一些待实现的、列入计划（在待定项中了）的功能）\n冲刺待定项：产品团队选择的产品待定项的子集，在当前进行的冲刺期间作为代码增量完成。增量是以前冲刺完成的所有产品待定项和在当前冲刺中要完成的所有待定项的并集。\n会议 冲刺规划会议：在每个冲刺开始之前，排序产品待定项，在冲刺待定项中选择具体项目，确定开发目标，确定在分配的时间盒中可以作为增量交付哪些内容。\n每日Scrum会议：自从上次团队例会后做了什么？遇到什么苦难？下次例会前计划做些什么？\n冲刺评审会议：演示冲刺期间完成的代码增量，演示可能不包含所有计划的功能，但是要演示冲刺期间完成的功能，负责人决定接受不接受该增量。\n冲刺回顾：考虑：冲刺中哪些方面进展顺利？哪些方面需要改进？下一个冲刺中致力于改进什么？\n基本特征 开发活动由工作单元（packets）组成 测试和文档编制贯穿始终 发生于一个过程模式的工作任务被称为一个冲刺，来源于待定项中定义的需求 例会时间很短 在规定时间内将演示软件交付给用户 3.5 XP框架 极限编程包括策划、设计、编码和测试四个框架活动的规则和时间。\n策划 策划活动从倾听用户故事开始，描述待开发软件所需的输出、特征以及功能。（需求收集活动）\n每个用户故事由客户书写并且置于一张索引卡上，客户根据对应特征或功能的综合业务价值标明故事的权值（优先级）。新故事可以在任何时候书写。\n用户和XP团队共同决定如何将故事分组，并置于XP团队将要开发的下一个发布版本（软件增量）中。\n排序有待开发的故事：\n所有故事将尽快完成 具有最高权值的故事将移到进度表的前面并首先实现 高风险故事将移到进度表的前面并首先实现 项目速度是第一个发布版本中实现的用户故事个数。用于评估后续发布版本的日期和进度安排（用来适当修改计划的）\n设计 XP设计严格遵守KIS（保持简洁）原则\nXP鼓励使用CRC卡（类-职责-协作者）来确定和组织当前软件增量相关的面向对象的类，也是作为XP过程一部分的唯一设计工作产品。\n编码 XP建议不要直接开始编码，而是开发系列测试单元用于检验软件增量中发布的所有故事。一旦编码完成，就可以立即完成单元测试，从而向开发者提供及时反馈。\n结对编程：两个人面对同一台计算机共同为一个故事开发代码，提供了实时解决问题和实时质量保证的机制。\n测试 所建立的单元测试应当使用一个可以自动实施的框架。\nXP验收测试也称为客户测试。\n3.6 看板法 基本概念 Kanban是一种精益方法学（精益思想认为，应该从是否增加了价值的角度来评价一个活动是否是浪费，即消除浪费，做有价值的工作），描述改进过程或工作流的方法，专注于变更管理和服务交付。\n​\t变更管理：定义了将请求的变更集成到基于软件的系统过程。\n​\t服务交付：更专注于了解客户需求和期望。\n核心实践 使用看板图可视化工作流。看板图按列组织，分别表示软件功能的每个元素的发展阶段。团队会随着项目进展将\u0026quot;要做\u0026quot;推进到“正在进行”，再推进到“已完成”。 在给定的时间内要限制当下工作（WIP）负荷。鼓励开发人员在进行另一项工作前完成当前任务。以缩短交付时间，提高工作质量，提高团队向利益相关者频繁交付软件功能的能力。 通过当前价值流、分析停滞位置、定义变更以及实施变更来管理工作流，以减少浪费。 明确的过程策略（写下选择工作项目的理由，定义“完成”的标准） 通过创建反馈循环聚焦持续改进，基于过程数据引入变更。 过程变更要相互合作。 会议 问自己：每一个项目在看板中，现在在哪里？从哪里来？到哪里去？\n和Scrum会议类似，每日看板站立会议的基础是“走板“任务，找出正在处理的”板“中遗漏的项目并适当添加。\n每周回顾会议期间，检查过程测量。\n3.7 开发运维一体化DevOps 将开发和运维相结合。涉及阶段（会持续循环）：持续开发、持续测试、持续集成、持续部署、持续监控。\n**持续开发：**将软件可交付成果分解到多次冲刺会议中开发\n持续测试：自动化测试工具的使用，可以同时测试多个代码增量\n持续集成：将具有新功能的代码段添加到现有的代码段和运行环境中，对其检查以保证后续部署没有错误。\n持续部署：将集成代码部署到生产环境，\n持续监控：运维人员通过监控软件在生产环境中的性能来主动查找问题（尽可能地早于用户发现问题）以提高软件质量。\nDevOps通过快速响应客户的需求或希望的变化来提高用户体验。\n这样的精益方法能够减少重复劳动、转向更高业务价值的活动。\n3.8 相关思考 什么样的项目适合于采用计划驱动的开发方法？什么样的项目适合于采用敏捷开发方法？\n从敏捷到开发运维一体化体现了现代软件开发什么样的特点？\n软件变更的原因？从“过程”和“方法”两方面分别讲下如何应对变更？\n从敏捷适应变更（不可预测的）的角度来说？ P39中小结\nP29中敏捷产生的前提：市场情况变化迅速等\nXP模型在处理增量原型方面与螺旋模型有何不同？\n4. 理解需求 用户需求：用户的期望，希望系统向用户提供什么样的服务以及满足哪些约束\n系统需求：协商后确定的：系统所需要提供的服务、实现的功能、质量以及约束\n软件需求：在系统需求中关于待开发的软件的功能、质量及约束等方面的描述\n用户需求经过细化和商讨确定一系列系统需求。\n系统需求通过不断分解和精化步骤来确定软件与其它系统元素的职责分配，从而确定软件需求。\n4.1 需求工程 需求工程就是致力于不断理解需求的大量任务和技术。\n起始：提出一系列问题\n获取：征求各利益相关者的需求\n精化：开发一个需求模型，来说明软件的功能、特征和信息的各个方面\n协商：协商形成一个能令开发人员和客户都满意的交付软件\n规格说明：可以是一份写好的文档、一套模型、一个形式化的数学模型、一个原型、一个使用场景\n确认：对需求工程的工作产品进行质量评估，通过一组检查机制来发现一些错误、需要进一步解释的、丢失信息、不一致性、冲突需求\n需求管理：在项目进程中标识、控制和追踪需求以及需求变更。\n软件需求规格说明书 SRS一般至少包括下面三个主要的内容：功能特征描述、系统接口描述、质量特征描述\n主要目标 在现有的系统上下文环境中建立并实现愿景。\n愿景：给出了关于软件系统需要实现的目标的主观愿望\n上下文环境：给出了目标实现可以利用的客观便利条件或必须考虑的客观约束\n4.2 建立根基 确定利益相关者：”你认为我还应该和谁谈？“ 识别多重观点：利益相关者多了导致需求角度不同，需要把所有信息分类，消除不一致性或者矛盾的需求描述。 协同合作：客户之间、团队之间、客户与团队之间（利益需求的矛盾消除） 首次提问：谁请求的？谁使用的？收益如何？还需要其它资源？ 非功能需求：质量属性、性能属性、安全属性。例如可用性、可测性、安全性之类的。 可追溯性：软件工程工作产品间记录的文档化链接。 4.3 获取需求 需求获取是将问题求解、细化、协商和规格说明等元素结合在一起。\n协作收集需求 会议由软件工程师和其它的共利益者共同举办，拟定一个会议议程，由一个主持人控制会议。\n为了：标识问题、提出解决方案的要素、协商不同的方法、确定一套解决需求问题的初级方案。\n​\t需求分解与精化\n​\t愿景分解：针对愿景提问“如何才能实现”，识别一组更加具体的目标，这些目标的达成可以确保愿景的实现\n​\t目标分解：得到的目标又可以进一步被分解成下一级子目标，方式同样是针对目标提问“如何才能实现”\n​\t方式：与分解、或分解，表示子目标与父目标之间的关系。\n​\t•目标分解和精化过程不断迭代进行，直至得到可明确指导设计和实现的详细需求，其中伴随着问题和解决方案的不断迭代转换\n​\t需求优先级排序\n​\t低优先级需求往往依赖于一些高优先级的需求\n使用场景 收集需求时，系统功能和特性的整体愿景开始具体化，为了将其转移到技术化的软件中，可以创建一系列场景——场景可以识别将要构建系统的使用线索，通常被称为用例。\n站在参与者的视角分析与待开发系统的交互过程、关注于业务实体和实体之间关系的类分析、关注于系统响应外部事件的方式的行为分析也都有一些应用\n获取工作产品 通常结合自然语言描述与形式化的模型描述（模型具有规范性和精确性，但在普适性灵活性和易用性存在不足）。\n产品可以包括：\n要求和可行性说明 系统技术环节说明 需求列表 一系列使用场景 4.4 开发用例 确定故事中的参与者（使用系统的各类人员或者设备，是任何与系统或产品通信的事务，且对系统本身来说是外部的） 明确交互操作，具有相同目标且交互过程相似的一组场景可以被组织为一个用例。需要进行识别用例，判断是否满足：过程明确且完整、可独立完成且不可再分、对于用户有价值 用例描述：UML用例图（概览描述）、UML泳道图（用例详细描述）、UML活动图（用例详细描述）。 用例详细描述还可以通过自然语言：用例名称、参与者、目标、前置条件、触发条件、主场景、其他场景、异常场景、发生频率。 4.5 构建分析模型 分析模型的元素 ​\t基于场景：用例、更精细的基于模板的用例、用例图、描述\n​\t基于类：UML类图\n​\t行为元素：状态图、顺序图\n分析模式 分析模式在特定应用领域内提供一些解决方案（如类、功能、行为）的模板。\n5. 需求建模 使用文字或者图表综合的形式来描绘需求。\n5.1 建模方法 ​\t原则：\n问题的信息域必须得到表达和理解； 必须定义软件执行的功能； 必须表示软件的行为（作为外部事件的结果） 描述信息、功能和行为的模型必须以分层（或分级）的方式进行分割以揭示细节。 分析任务应从基本信息转向实现细节。 场景分析与描述 创建用例 使用：用例图、活动图、泳道图、自然语言描述 详细的自然语言描述的用例举例：\n类分析与描述 类包含一组所有对象或实体都具有的属性和操作。\n类之间存在多种不同类型的关系：继承（Inheritance）、聚合（Aggregation）、关联（Association）、依赖（Dependency）\n​\t识别分析类\n​\t选取名词（潜在类），分类：外部实体、事物、偶发事件或事件、角色、组织单元、场地、结构\n​\t考虑特征：保留信息、所需服务（一组可确认的操作）、多个属性、公共属性、公共操作、必要需求。P107\n​\t分析类的种类\n​\t实体类、边界类、控制类\n​\t边界类：与用户的接口（交互屏幕或报表之类的）\n​\t控制类：可以管理：实体类的创建与更新、对象集合间的复杂通信、数据交换的确认\n​\t呈现\n​\tUML类图、CRC（类-职责-协作者）\n行为分析与描述 行为：系统或其一部分响应外部的事件激励而执行一些动作，同时伴随自身状态的变化\n行为分析从系统本身而非场景分析中的外部参与者的角度了解到系统如何响应外部事件进行状态转换并执行各种动作的\n包含的基本内容：状态、事件、状态转换、动作\n顺序图、状态图\n5.2 相关思考 数据流图、E-R图、UML类图、UML用例图、UML活动图、UML顺序图、UML状态图\n6. 软件设计 软件设计是软件需求与实现代码之间的桥梁\n6.1 层次 数据/类设计\n体系结构设计\n组件接口设计\n组件（构建）级设计\n6.2 软件设计思想（概念） ​\t分解与抽象：\n​\t分解：将软件不断地分解为更细粒度的代码单元，例如从组件、模块到文件和类\n​\t抽象：忽略无关细节，只保留与当前问题相关的关键信息\n​\t（例如接口抽象使得我们可以针对接口进行编程而忽略内部数据结构、算法等实现细节）\n​\t数据抽象：对于目标对象的数据化抽象描述\n​\t过程抽象：对一系列过程性步骤和指令序列的整体抽象\n​\t软件体系结构：\n​\t大规模软件系统（特别是网络化软件系统）需要更高层的设计考虑\n​\t软件体系结构给出了软件系统的顶层设计（包括一组软件组件、它们的外部属性以及相互之间的关系）\n​\t充分体现了分解与抽象的基本原则\n​\t总体质量在很大程度上取决于体系结构设计\n​\t关注点分离：\n​\t关注点：软件系统中所实现的某种功能或特性，反映不同涉众所关注和关切的方面\n​\t关注点分离：将软件系统的整体需求分解为尽可能小的关注点并分解到不同的模块单元（例如模块、包、类、方法等）中实现\n​\t模块化划分就体现了关注点分离的思想。\n​\t存在问题：关注点散布（一个关注点散到多个模块单元中）和混杂（同一模块单元混杂了多个关注点）问题。\n​\t面向切面的编程（简称AOP）为这种横切关注点的封装提供了一种有效的手段\n​\t模块化\n​\t模块化：将整个产品或系统分解为大小合适、相对独立的模块\n​\t信息隐藏：\n​\t将实现细节隐藏在内部，仅通过受限的接口对外提供访问。\n​\t过度公开则可能会导致不必要的耦合。\n​\t重构\n​\t很多敏捷方法都建议进行重要的设计活动——重构。是实现所谓的演化式设计的一种重要手段。\n​\t推崇在增量和迭代化的特性实现过程中不断发现设计中的问题并通过重构不断进行改进。\n​\t重构为在不改变代码外在行为的前提下，对代码作出修改以改进程序的内部结构。\n​\t为了：提高软件的可维护性和可扩展性。\n​\t复用\n​\t不同层次：\n​\t源代码复制粘贴\n​\t软件库API调用\n​\t软件设计模式（需要结合具体问题需要进行实例化）\n​\t面向特定类型软件应用的软件框架（spring框架）\n6.3 面向对象软件设计 基本步骤：识别设计类、明确设计类职责和协作、细化设计类内部细节\n潜在设计类 ​\t来自问题域中的设计类、位于接口上的设计类、与基础设施相关的设计类（实现数据库访问之类的设计类）\n判断设计类合理性 明确职责与协作 ​\t关注点分离、高内聚低耦合\n细化内部细节 ​\t类属性需要细化的主要是访问修饰符、属性类型及初始值\n​\t方法需要细化的主要是访问修饰符、参数及类型、返回值类型、前置及后置条件\n​\t类内部需要用到的局部数据结构和算法\n设计描述 ​\tUML类图：描述面向对象的静态设计结构，包括类及类之间的静态关系\n​\tUML顺序图：特定场景中类与类之间的动态交互关系\n​\tUML状态图：通过状态转换的方式描述类的实例对象的行为\n​\tUML包图：以包的形式描述更大粒度的模块之间的静态结构关系\n​\tUML通信图：类的实例对象间关系的基础上描述对象间消息发送的顺序\n​\tUML活动图：描述由类方法调用构成的业务处理过程及算法流程\n其它内容 模块独立性\n高内聚、低耦合\n​\t内聚形态\n​\t功能内聚、层次内聚、通信内聚、顺序内聚、过程内聚、时间内聚、功用内聚\n​\t通信内聚：模块中仅包含访问同样一组数据的操作\n​\t耦合形态\n​\t内容耦合、共用耦合、控制耦合、印记耦合\n​\t内容耦合：消除内容耦合的主要手段是实现信息隐藏，提供接口等\n​\t共用耦合：考虑共享全局变量\n​\t控制耦合：某个方法需要根据实际情况进行调整，引入多态，设置抽象方法来消除控制耦合\n6.4 面向对象程序设计原则 单一职责原则 每个类、接口、方法都应该只具有单一的职责，强调的是类、接口、方法的内聚性\nJavaEE中的分层框架模式实际上体现了单一职责原则\n开闭原则 软件实体应当对扩展开放，对修改关闭。\n实现开闭原则的关键是抽象\n定义一个抽象层，只规定功能而不提供实现，实现通过定义具体类来完成（继承和多态）\n需求变化时不是通过修改抽象层来完成，而是通过定义抽象层新实现完成了。\n例子：JavaEE多层模式下,可以定义业务、DAO接口，是和其他层对接的规范。可以增加不同的实现类，而不是去修改原来的实现类。\n里氏替换原则 子类对象可以出现在任何父类对象出现的地方\n里氏代换原则对如何良好继承提出了衡量依据\n里氏代换原则是使代码符合开闭原则的一个重要保证\n依赖倒置原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象\n其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合\n依赖倒置原则核心就是要面向接口编程\n例子：早期电脑所有硬件整合在一起，一个模块坏全部坏，现在的电脑依赖于插槽（规范），更换cpu、内存、卡等方便\n接口分离原则 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。\n例子：在车站售票窗口排队的人有买票的，有查开车信息，有退票的，不必排在同一窗口中。多开几窗口，每个窗不同功能，让不同需求的人排在不同窗口，可以节约时间和人力。\n迪米特法则 强调不要和“陌生人”说话，只与直接“朋友”交谈\n迪米特法则的初衷在于降低类之间的耦合\n外观模式和中介者模式都是迪米特法则的应用\n6.5 面向切面的编程AOP 面向切面的编程方法支持横切关注点解耦和模块化封装\n将散布出去的关注点进行整合封装\n开发人员在基本程序上定义连接点，相关工具自动将切面编织到对应的连接点上并形成最终的完整程序\n横切关注点单独以“切面”这种新引入的模块化机制来进行模块化封装和实现\n•切面（Aspect）：实现关注点的模块化单元\n•通知（Advice）：由切面所封装的、将插入到基本程序中指定地方执行的功能代码\n•连接点（Join point）：基本程序结构或者执行流上的一种可以明确定义的位置\n•编织（Weave）：将基本程序与切面集成到一起获得完整程序的过程\n6.6 设计模式 这些设计问题的具体形式有所差异，但可抽象为共性问题\n要素 名称：有意义的、能揭示设计模式目的的名称\n问题：关于设计模式所针对的问题域描述，解释了该模式何时适用\n解决方案：对于设计解决方案的描述。\n使用效果\n分类 创建型模式：与类的实例对象创建相关的设计模式，关注于对象创建过程的抽象和封装\n​\t工厂方法、抽象工厂、单例、建造者、原型\n结构型模式：与类和对象的结构组织相关的设计模式，关注于如何实现对象的组合\n​\t适配器、装饰器、代理、外观、桥接、组合、\n行为型模式：与类和对象之间的交互行为和通信相关的设计模式，关注于类和对象之间的交互关系和职责分配\n​\t策略、观察者、模板方法\n单例模式 一个类只允许有一个对象实例\n例如操作系统中的任务管理器和回收站、网站的计数器、金融交易的引擎、应用程序的日志引擎等\n解决：私有构造函数，静态实例对象，对外共有静态方法返回实例对象\n适配器模式 使用场景：一个类所需要的接口与另一个类所提供的接口不匹配，但功能相同或相近\n解决：额外引入的适配器类，继承了Adaptee从而具备了该类所实现的能力，同时实现了Target接口\n组合模式 客户端获得抽象组件对象的引用后可以直接调用其操作方法，而不用关心它是原子对象还是复合对象\n例如：在画图工具中的复合图形绘制中，抽象的组件对象是抽象图形，原子对象是基本图形（三角形、圆形等，可以有多个），复合对象是复合图形。可以按照抽象图形调用其操作（例如绘制、移动、删除），从而实现整个图形的操作，而不用关心其是一个原子图形还是复合图形\n策略模式 策略模式突出体现了面向对象设计的开闭原则。\n对算法策略进行封装，称为抽象算法策略，实现该抽象方法即可有具体的算法策略。使得算法策略的扩展变得更加容易，避免了通过多重选择语句选择不同的算法策略。\n观察者模式 观察者模式通过主题类与具体观察者类的解耦实现了对于具体观察者类扩展的支持，MVC？\n例如消息队列、事件驱动编程（Java中的Swing）\n7. 体系结构设计 体系结构设计从数据设计开始，并创建系统体系结构的一个或多个表示。然后在对多个可选体系结构风格或者模式分析的基础上，选择一个最符合顾客需求和质量基础的结构。\n7.1 “4+1”视图 逻辑视图 面向：分析师/设计师\n聚焦：结构\nUML类图、UML组件图\n实现视图 面向：开发人员\n聚焦：软件管理\nUML包图\n运行视图 面向：系统集成人员\n聚焦：性能、可伸缩性、吞吐量等\nUML顺序图\n部署视图 面向：安装部署人员\n聚焦：系统拓扑、交付、安装、通信\nUML部署图\n用例视图（+1） 面向：最终用户\n聚焦：功能\nUML用例图\n7.2 软件体系结构风格 风格？举例：\nC/S风格可以实现复杂的客户端逻辑并充分利用客户端计算机资源；\n​\t功能强大并针对特定操作系统专门开发的客户端软件\n​\t大部分业务逻辑可以在客户端实现，而服务器端可以相对简单甚至只提供数据库服务\nB/S风格依赖于用户计算机上所安装的浏览器来展现界面并实现用户交互\n层次化体系结构风格 每个层次都有明确的功能和职责划分，上层依赖于下层而下层则不能依赖于上层\n以数据为中心的体系结构 一种以数据为中心的体系结构风格\n以数据的形式存在的知识在中心知识库中被集中保存和管理，围绕知识库的一组软件组件通过共享知识库间接进行交互\n实现简单并且能够依托成熟的数据库系统实现大量数据的共享。\n但：当中心知识库数据量大到一定程度之后难以实现高效的数据访问和管理\n数据流体系结构 例如管道-过滤器模式\n即其中的组件是按照数据流进行组织\n组件间关系主要体现在输入输出数据流上，因此耦合相对较松\n人机交互性较强的软件系统，例如需要图形用户界面支持的系统，但适合于以数据传输和处理逻辑为主的系统（例如数据批处理系统）\n面向对象的体系结构 系统的构件封装了数据和必须用于该数据的操作，构件之间的通信和合作是通过信息传递实现的。\nMVC 模型：所有应用特定内容和处理逻辑\n视图：包含所有接口特定功能并能够显示终端用户所需的内容的操作逻辑\n控制器：管理对模型和视图的访问并协调数据流。\n分布式软件体系结构 CAP定理：对于同时存在数据读取（如读取商品数量）和更新（如更新商品数量）操作的分布式系统，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）三个属性无法同时被满足，即如果想满足其中两个那么剩下的一个必须被牺牲\nBASE原则：牺牲数据的强一致性来换取高可用性并在最后能实现最终一致性\n"},{"section":"Blog","slug":"/en/blog/svd/","title":"【泛学内容】奇异值(SVD)分解","description":"this is meta description","date":"July 2, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"数学相关, 泛学内容","tags":"线性代数, 奇异值分解, 特征值分解","content":"奇异值分解 一、特征值分解 必要条件 待分解矩阵$A_{n \\times n}$为方阵，同时具有n个线性无关的特征向量，可进行相似对角化（特征值分解）。\n定理内容 记特征值为$\\lambda_{1} \\le \\lambda_{2}\\le \u0026hellip; \\le \\lambda_{n}$，对应的n个线性无关的特征向量为$v_{1},v_{2},\u0026hellip;,v_{n}$，则存在正交矩阵$V$，满足以下式子。其中$V$为特征向量按列排列，且为正交矩阵，即$V=(v_{1},v_{2},\u0026hellip;,v_{n})$。\n$$ V^{-1}AV=V^{T}AV=\\Lambda = \\begin{pmatrix} \\lambda_{1} \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026hellip; \u0026amp; \\\\ \u0026amp; \u0026amp; \\lambda_{n} \\end{pmatrix} $$\n上式对$A$进行了相似对角化，通过可逆矩阵$V$来得到$A$的相似矩阵$\\Lambda$。也相当于为$A$进行了特殊的表达，即转化为$A=V\\Lambda V^{-1}$，从而将A这个线性变换转化为“旋转-缩放-旋转”的形式。\n简要分析 考虑到对于任何一个方阵$ A_{n \\times n }$，可以将其看作n维空间中的一个线性变换，它的一个特征向量$\\hat{v}$以及对应的特征值$\\lambda$，可以看作为在经过线性变换$A$后，特征向量$\\hat{v}$的方向并未发生改变，只是进行了缩放比为$\\lambda$的缩放。即满足$A \\hat{v} = \\lambda \\hat{v}$。\n若能够找到n组特征向量与特征值，且这n个特征向量相互线性无关，那么将这n个特征向量组成一个基则能够保证在该基之下，线性变换A能够与一个对角矩阵相似（即A在V基下的线性变换为一个对角阵）。具体原因在于：$A(v_{1},v_{2},\u0026hellip;,v_{n})= \\begin{pmatrix} \\lambda_{1} \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026hellip; \u0026amp; \\\\ \u0026amp; \u0026amp; \\lambda_{n} \\end{pmatrix} (v_{1},v_{2},\u0026hellip;,v_{n}) $。而对于基$V$，可以进行正交化，最终将矩阵$A$进行分解得到“正交阵-对角阵-正交阵”的形式，即将线性变换分解为“旋转-缩放-旋转”。（正交阵带来的正交变换不改变距离、夹角、内积等性质，即为旋转；对于对角阵，只对各基方向进行成比例缩放）\n二、奇异值分解 定义 将一个非零的$m \\times n$实矩阵$A$，$A \\in R^{m \\times n}$，表示为以下三个实矩阵的乘积形式的运算，即矩阵的因子分解。其中$U$时$m$阶正交矩阵，$V$时$n$阶正交矩阵，$\\Sigma$是由降序排序的非负的对角线元素组成的$m \\times n$矩形对角矩阵。 $$ A=U\\Sigma V^{T} $$ 满足： $$ UU^T=I \\\\ VV^T=I \\\\ \\Sigma = diag(\\sigma_{1},\\sigma_{2},\u0026hellip;,\\sigma_{p})\\\\ \\sigma_{1} \\ge \\sigma_{2} \\ge \u0026hellip; \\ge \\sigma_{p} \\ge 0 \\\\ p \\le min(m,n) $$ 则$\\sigma_i$为矩阵$A$的奇异值，$U$ 的列向量称为左奇异向量，$V$的列向量称为右奇异向量。\n奇异值分解存在定理 任意给定一个实矩阵，其奇异值分解一定存在。证明见《统计学习原理》P273。\n紧奇异值分解与截断奇异值分解 紧奇异值分解是与原始矩阵$A$等秩的奇异值分解，截断奇异值分解是比原始矩阵$A$低秩的分解。\n具体地，截断奇异值分解中，只取最大的k个奇异值（$k \u0026lt; R(A)$）来组成$\\Sigma$。\n举例：\n对于以下矩阵$A$，其秩为3。\n$$ A= \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 4 \\\\ 0 \u0026amp; 3 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 2 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{pmatrix} $$\n$A$的紧奇异值分解为：$A=U_r \\Sigma_r V_r^T$，其中：\n$$ U_r= \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; \\sqrt{0.2} \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; \\sqrt{0.8} \\\\ \\end{pmatrix}, \\Sigma_r = \\begin{pmatrix} 4 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 3 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; \\sqrt{5} \\\\ \\end{pmatrix}, V_r^T = \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{pmatrix} $$\n$A$的截断奇异值分解为：$A=U_k\\Sigma_kV_r^T$，其中：\n$$ U_r= \\begin{pmatrix} 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \\\\ \\end{pmatrix}, \\Sigma_r = \\begin{pmatrix} 4 \u0026amp; 0 \\\\ 0 \u0026amp; 3 \\\\ \\end{pmatrix}, V_r^T = \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{pmatrix} $$\n相当于缺失了一部分信息，但也可能够根据剩余的奇异值还原原有矩阵的信息，实现一定程度的数据压缩。例如以上截断奇异值分解可以进行以下还原：\n$$ A_2=U_2\\Sigma_2V_2^T= \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 4 \\\\ 0 \u0026amp; 3 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{pmatrix} $$\n几何含义 对于线性变换$A=U\\Sigma V^T$，即等价于经过旋转$V^T$，缩放$\\Sigma$，旋转$U$。$U$和$V$都是正交阵，对应的线性变化仅为旋转。如下图所示。\n计算方法 给定$m \\times n$的矩阵$A$，进行奇异值分解$A=U\\Sigma V^{T}$。\n（1）求$A^TA$的特征向量和特征值。\n计算对称矩阵$W=A^TA$，有以下特征方程： $$ (W-\\lambda E)x=0 $$ 求解特征方程可得特征值$\\lambda_{i}$，将特征值从大到小进行排列：$\\lambda_{1} \\ge \\lambda_{2} \\ge \u0026hellip; \\ge \\lambda_{n} \\ge 0$。带入特征方程能够得到对应的的特征向量。\n（2）求解n阶的正交矩阵$V$\n将求得的特征向量进行单位化，得到单位特征向量$v_1,v_2,\u0026hellip;,v_n$，构成n阶的正交矩阵$V=[v_1,v_2,\u0026hellip;,v_n]$。\n（3）求$m \\times n$对角阵$\\Sigma$\n计算$A$的奇异值： $$ \\sigma_i=\\sqrt{\\lambda_i} \\ , i=1,2,\u0026hellip;,n $$ ,那么可以构造出$\\Sigma$，主对角线的元素为奇异值，其余为0。 $$ \\Sigma=diag(\\sigma_1,\\sigma_2,\u0026hellip;,\\sigma_n) $$ （4）求m阶的正交矩阵$U$\n对A的前r个正奇异值，令$u_j=\\frac{1}{\\sigma_j}Av_j,j=1,2,..,r$。得到部分正交矩阵： $$ U_1=[u_1 \\ u_2 \\ \u0026hellip; \\ u_r] $$ 求$A^T$的零空间中的一组标准正交基${u_{r+1},u_{r+2},\u0026hellip;,u_{m}}$，记为$U_2$。\n则能够得到： $$ U=[U_1 \\ U_2] $$ （5）得到奇异值分解结果。 $$ A=U\\Sigma V^T $$\n"},{"section":"Blog","slug":"/en/blog/web-vue/","title":"【课程笔记】Web前端开发-Vue","description":"this is meta description","date":"March 25, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"Web前端开发","content":"HTML CSS 复合属性\nborder:宽度 样式 颜色\nfont:风格 粗细 字号/行高 字体\nbackground:背景色 url 平铺 定位 固定\ntransition:属性 时长 速度曲线 延时\nlist\nJavaScript 数组操作 push、unshift\t压入\npop、shift\t弹出\nreverse、sort改变原数组\nsplice：删除，返回删除区间数组，传入起始索引+长度 长度为0则表示添加\nslice：截取，不改变原数组，传入区间\nsubstring：类似slice，end无负值\nsubstr：截取，第二个参数为长度\n正则：\n？：0/1\n+：\u0026gt;=1\n*：\u0026gt;=0\nVue.js 1.概要介绍 概念 Vue是一套用于构建用户界面的渐进式框架，Vue被设计为自底向上逐层应用。\n声明式编程：不需要直接操作DOM元素。Vue是一个响应式系统：数据和DOM元素绑定在一起，所有的元素都是响应式的。\nMVVM模式 Model-View-ViewModel。Model指的是数据部分，主要负责业务数据；View指的是视图部分，即DOM元素，负责视图的处理；ViewModel连接视图和数据的数据模型，负责Model监听或者View的修改。\n把需要改变的视图数据初始化到Vue中，然后通过修改Vue中的数据从而实现对视图的更新。\n核心技术 组件化和虚拟DOM技术。Vue通过虚拟DOM技术来减少对DOM的直接操作。\n2.基础技术 2.1 基本架构 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;!-- 插值表达式，将data中数据渲染到页面 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;msg\u0026#34;\u0026gt; \u0026lt;!-- 数据双向绑定 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 实例化Vue程序 var vm = new Vue({ el:\u0026#39;#app\u0026#39;, //Vue管理的DOM节点入口，值为选择器 不能为html或者body data: { //指定初始化数据 msg:\u0026#34;Hellowrold\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 2.2 Vue实例 el唯一根标签 class或者id选择器可以用来将页面结构与Vue实例对象中的el绑定。\ndata初始数据 Vue的数据对象为data，Vue会将data的数据转换为get、set接口从而让data的属性能够相应数据变化。\n可以通过vm.$data访问原始数据对象。vm.name等价于vm.$data.name，由于Vim实例代理了data对象的所有属性。\nmethods定义方法 methods属性用来定义方法，方法中this指向Vue实例本身。\n其中绑定事件语句**@click等价于v-on:click**，v-on为事件监听指令，直接与事件类型配合使用。\n\u0026lt;button @click=\u0026#34;showInfo\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;!-- 绑定事件 --\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data: { msg:\u0026#34;Hellowrold\u0026#34; }, methods: { //定义事件处理方法 showInfo() { this.msg=\u0026#34;Click\u0026#34; //this指向该Vue实例vm } //或者写为 showInfo:function() { } } }) computed计算属性 一些数据需要随着其他数据的变动而变动，使用computed计算属性。\n事件处理方法中，this指向的Vue实例的计算属性结果会被缓存起来，只有依赖的响应式属性变化时，才会重新计算，返回最终结果。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;自变量X:{{dataX}}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;dataX\u0026#34;\u0026gt; //双向绑定数据 \u0026lt;p\u0026gt;自变量Y:{{dataY}}\u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;dataY\u0026#34;\u0026gt;\t//双向绑定数据 \u0026lt;p\u0026gt;计算结果X+Y:{{Sum}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#34;#app\u0026#34;, //挂载唯一根标签 data: { dataX:0, dataY:0, }, computed: { //计算属性 Sum作为绑定的目标数据 Sum() { return Number(this.dataX) + Number(this.dataY) } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; watch状态监听 原有的事件出发不能自动监听Vue实例的状态变化，watch只需监听当前Vue实例中的数据变化。\n例如：\nwatch: { Sum(newName,oldName) { console.log(newName,oldName) } } 监听Sum变量的变化，如果发生变化则打印旧值和新值。\nfilter过滤器 可以在插值表达式中使用filter，使用管道符|，语法为**{{data|filter}}**。\n其中filter定义为函数形式，将data作为参数传入filter函数，以实现指定操作。P9例代码\nv-bind属性绑定也可以使用过滤器，如“v-bind:id=\u0026ldquo;data”，表示绑定id属性为data，data后面可以加过滤器。\n2.3 Vue数据绑定 绑定样式 使用v-bind将样式数据绑定给DOM元素。\n可以1.绑定样式属性；2.绑定样式对象；3.绑定样式类\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-bind:style=\u0026#34;{backgroundColor:pink,width:width,height:height}\u0026#34;\u0026gt; 这里使用的是绑定样式属性值，具体值也是Vue实例的data数据 \u0026lt;/div\u0026gt; \u0026lt;div v-bind:style=\u0026#34;myDiv\u0026#34;\u0026gt; 这里使用的是绑定样式对象，对象在Vue实例data中定义 \u0026lt;/div\u0026gt; \u0026lt;div v-bind:class=\u0026#34;box\u0026#34;\u0026gt; 这里使用绑定样式类class的方法实现样式的绑定，类值也在Vue实例data中 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data: { //样式对象 myDiv:{backgroundColor:\u0026#39;red\u0026#39;,width:\u0026#39;300px\u0026#39;,height:\u0026#39;100px\u0026#39;}, //样式属性值 pink:\u0026#39;pink\u0026#39;, width:\u0026#39;100%\u0026#39;, height:\u0026#39;200px\u0026#39;, box:\u0026#39;box\u0026#39; //box类的样式在style标签中声明 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-model指令 实现数据的双向绑定，通常用于表单数据上，格式为：v-model=\u0026ldquo;data\u0026rdquo;\nv-text指令 实现在DOM元素内部插入文本内容，格式为：v-text=\u0026ldquo;txt\u0026rdquo;\nv-html指令 在DOM元素内部插入HTML标签内容，可以是HTML结构。\nv-bind指令 实现属性数据的单向绑定，格式为：v-bind:value=\u0026ldquo;values\u0026rdquo;。其中value为元素属性，如style、value等，可以简写为： :value=\u0026ldquo;values\u0026rdquo;。\nv-on指令 属于事件监听指令，直接与事件类型配合使用。格式为：v-on:events=\u0026ldquo;methods\u0026rdquo;，其中events为事件类型，如click，methods为Vue实例中定义的具体方法。可以简写为@events=”methods“。\n注意，event会作为响应函数的默认形参，代表原生DOM事件，当调用的函数有多个参数传入时，需要使用原生DOM事件时，则通过$event作为实参传入。\nv-for指令 遍历数组，以**（项，索引）**的形式遍历，其中索引可以省略，但高版本的Vue最好不要省略。\n迭代对象时，语法为v=for=\u0026rdquo;(value,key,index) in Object\u0026quot;。其中value为每个对象的属性值，key为属性名，index为索引值。后两个可选。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 以（项，索引）的形式遍历data列表 --\u0026gt; \u0026lt;div v-for=\u0026#34;(item,index) in list\u0026#34;\u0026gt; 索引为:{{index}},内容为:{{item}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data: { list:[2,3,4,5] } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-if指令 控制元素的隐藏和显示，和v-show功能类似，v-show操作的是display属性，元素始终被渲染并保留在DOM中，而v-if会对元素进行删除和重建，性能较差。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 绑定事件，反转flag --\u0026gt; \u0026lt;button @click=\u0026#34;flag=!flag\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;!-- 判定flag，为true则显示 --\u0026gt; \u0026lt;div v-if=\u0026#34;flag\u0026#34; style=\u0026#34;background-color:red\u0026#34;\u0026gt;Try v-if\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ flag:true } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 2.4 Vue事件 使用按键修饰符监听按键 监听键盘事件时，需要检查常见的键值。Vue允许为v-on添加按键修饰符来监听按键。\n例如v-on:keyup.enter=\u0026ldquo;func\u0026rdquo;。该事件为回车键被按下。\n格式：v-on:keyup.按键名，或者@keyup.按键名\n常见的按键名包括.enter .tab .delete .esc .space \u0026hellip;\n.stop阻止事件冒泡 通过在事件后面加.stop,例如click.stop，可以使得事件冒泡行为被阻止，即事件不会向上传递至父级元素。\n.prevent阻止默认事件行为 对于HTML标签的自身特性，例如a会进行自动跳转，可以使用.prevent修饰符对事件进行控制，使得元素的默认事件行为被阻止。例如在a标签中加入语句v-on:click.prevent，即可阻止跳转行为。\n.capture事件捕获 对于默认情况，事件由内到外执行，即冒泡顺序，而.capture事件捕获则时由外及内的。\n.self自身触发 该事件修饰符来实现只有DOM元素本身会触发事件。即若某事件是冒泡触发的，而非其元素本身受到的触发，则不会执行事件触发。\n.once只触发一次 阻止事件的多次触发。\n修饰符顺序 事件修饰符可以控制事件按照一定规则触发。\n例如，v-on:click.prevent.self阻止所有的单击,v-on:click.self.prevent阻止对元素本身的单击。\n2.5 Vue组件 全局注册 使用Vue.component()方法进行全局注册组件。\n1.通过Vue.extend()方法生成组件构造器，内容包含data，template，watch等。(与new Vue接收相同的选项)\n（Tips:此类配置选项在组件内部有独立作用域，不能从外面直接访问。）\n2.调用Vue.component()方法注册组件。\n3.在Vue实例的作用范围使用组件。\n例如：\nvar myConponent = Vue.extend({ //data在组件中必须为一个函数，通过返回值来返回初始数据 data() { return { count:0 } }, template:\u0026#39;\u0026lt;button v-on:click=\u0026#34;count++\u0026#34;\u0026gt;被单击{{count}}次\u0026lt;/button\u0026gt;\u0026#39; }) //2.注册组件 Vue.component(\u0026#39;my-conponent\u0026#39;,myConponent); //3.挂载app并在元素中使用组件 var vm = new Vue({ el:\u0026#39;#app\u0026#39; }) 其中组件构造器可以省略调用extend方法构造，用JavaScript对象来定义，如下。\nVue.component(\u0026#39;myConponent\u0026#39;,{ //data在组件中必须为一个函数，通过返回值来返回初始数据 data() { return { count:0 } }, template:\u0026#39;\u0026lt;button v-on:click=\u0026#34;count++\u0026#34;\u0026gt;被单击{{count}}次\u0026lt;/button\u0026gt;\u0026#39; }) 局部注册组件 通过Vue实例的components属性来实现，如下。其中myConponent1为组件构造器。\nvar vm = new Vue({ el:\u0026#39;#app\u0026#39;, components:{ myConponent: myConponent1} }) template模板 Vue提供了\u0026lt;template\u0026gt;标签来定义结构的模板，在该标签中书写HTML代码，通过id值绑定到目标组件内的template上。\n例如\u0026lt;template id=\u0026ldquo;tmp1\u0026rdquo;\u0026gt; HTML代码 \u0026lt;\\template\u0026gt;，组件构造器内：template:\u0026rsquo;#tmp1'\n组件间切换 可以采用v-if和v-else来进行显示与否的切换。也可以使用\u0026lt;component\u0026gt;标签的is属性值来进行组件的切换，is的属性值即为显示的组件名称。通过v-bind对该属性值进行绑定即可实现切换。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 超链接事件被取消默认响应，事件操作为修改comName --\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; @click.prevent=\u0026#34;comName=\u0026#39;login\u0026#39;\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; @click.prevent=\u0026#34;comName=\u0026#39;register\u0026#39;\u0026#34;\u0026gt;Register\u0026lt;/a\u0026gt; \u0026lt;!-- 通过component标签的is属性进行显示的组件切换，v-bind将该属性进行绑定 --\u0026gt; \u0026lt;component v-bind:is=\u0026#34;comName\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 组件定义 Vue.component(\u0026#39;login\u0026#39;,{ template:\u0026#39;\u0026lt;div\u0026gt;登录页面\u0026lt;/div\u0026gt;\u0026#39; }) Vue.component(\u0026#39;register\u0026#39;,{ template:\u0026#39;\u0026lt;div\u0026gt;注册页面\u0026lt;/div\u0026gt;\u0026#39; }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ comName:\u0026#39;login\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 2.6 组件间通信 组件实例具有局部作用域，需要一些工具来实现组件间通信，例如父组件向子组件传递数据信息。\nprops传值 props即为道具，用来接受父组件中定义的数据，其值为数组，数组中是父组件传递的信息。\nprops是以从上到下的单向数据流传递，且父级组件的props更新会向下流动到子组件，但反过来不行。\nprops在声明组件对象中（组件构造器）定义，有三种方式：（1）数组形式传递属性名；（2）对象形式传递属性名和数据类型；（3）指定属性名、数据类型、必要性、默认值。\n举例：\n\u0026lt;body\u0026gt; \u0026lt;template id=\u0026#34;tmp1\u0026#34;\u0026gt; \u0026lt;!-- 采用template标签来构造组件模板 --\u0026gt; \u0026lt;div\u0026gt;父组件消息:{{name}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 父组件处传入name的值 --\u0026gt; \u0026lt;my-parent name=\u0026#34;传入信息12132\u0026#34;\u0026gt; \u0026lt;/my-parent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;my-parent\u0026#39;,{ //在组件构造器中声明，表示接受name数据，它在父组件处传入 props:[\u0026#39;name\u0026#39;], template:\u0026#39;#tmp1\u0026#39; }) var vm = new Vue({ //挂载 el:\u0026#39;#app\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; Tips：如果在默认情况下，无法从外面去给组件内部的值进行赋值，使用props可以想象成开通某个管道，使得数据能够通过该管道进入到组件内部。\n可以使用v-bind来动态绑定传入数据的值，如下代码。\n\u0026lt;body\u0026gt; \u0026lt;template id=\u0026#34;tmp1\u0026#34;\u0026gt; \u0026lt;!-- 采用template标签来构造组件模板 --\u0026gt; \u0026lt;div\u0026gt;父组件消息:{{name}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 使用v-bind来绑定name这个属性，值也是从父节点（此处）来的 --\u0026gt; \u0026lt;my-parent v-bind:name=\u0026#34;inputdata\u0026#34;\u0026gt; \u0026lt;/my-parent\u0026gt; \u0026lt;!-- 双向绑定 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;inputdata\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;my-parent\u0026#39;,{ //在组件构造器中声明，表示接受name数据，它在父组件处传入 props:[\u0026#39;name\u0026#39;], template:\u0026#39;#tmp1\u0026#39; }) var vm = new Vue({ //挂载 el:\u0026#39;#app\u0026#39;, data:{ //声明一个数据，从来接受文本框的数据 inputdata:0 } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; $emit传值 $emit能够将子组件中的值传递到父组件中，触发父组件中定义的事件，子组件的数据信息通过传递参数的方式完成。\n例如：子组件通过this.$emit触发父组件的自定义函数，将其data作为参数传出，父组件通过事件响应函数接收该传出的参数，完成组件间传值。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;parent\u0026gt;\u0026lt;/parent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;click\u0026#34;\u0026gt; Send \u0026lt;/button\u0026gt; \u0026lt;!-- 双向绑定给子组件的data --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;parents\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 在child组件上绑定了一个名为childfn的事件，事件处理方法为transContent --\u0026gt; \u0026lt;child @childfn=\u0026#34;transContent\u0026#34;\u0026gt;\u0026lt;/child\u0026gt; From child: {{message}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; //父组件parent Vue.component(\u0026#39;parent\u0026#39;,{ template:\u0026#39;#parents\u0026#39;, data() { return { message:\u0026#39;\u0026#39; } }, methods:{ //对于事件处理方法，将传入的形参赋值给父组件的数据message transContent(payload) { this.message = payload } } }) //子组件child Vue.component(\u0026#39;child\u0026#39;,{ template:\u0026#39;#child\u0026#39;, data() { return{ message:\u0026#39;child message\u0026#39; } }, methods: { click() { //按钮按下后响应该方法 //子组件触发自定义事件childfn，并且将message作为参数传出 this.$emit(\u0026#39;childfn\u0026#39;,this.message); } } }) var vm = new Vue({el:\u0026#39;#app\u0026#39;}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 2.7 Vue的生命周期 每个Vue实例在被创建时要经过一系列初始化过程，三大阶段：初始化显示、更新显示、销毁Vue实例\n初始化阶段的钩子函数：\nbeforeCreate()实例创建前：数据和模板均为获取到\ncreated()实例创建后：最早可访问到data数据，但模板未获取到\nbeforeMount()数据挂载前：模板已经获取到，但数据未挂载到模板上\nmounted()数据挂载后：数据已经挂载到模板中\n更新阶段的钩子函数：\nbeforeUpdate()模板更新前：data改变后，更新数据模板之前调用\nupdated()模板更新后：将data渲染到数据模板中\n销毁阶段的钩子函数\nbeforeDestroy()实例销毁前\ndestroyed()实例销毁后，vm实例在这两个阶段都存在，但是销毁之后获取不到页面中的div，所以，实例销毁后无法操作DOM元素。\n2.8 自定义指令 除了内置指令外，Vue允许注册自定义指令。\n注册全局指令 //指令名不要带v- Vue.directive(\u0026#39;指令名\u0026#39;,{ //el代表使用该指令的DOM元素 //binding可获取使用了此指令的绑定值 inserted:function(el,binding) { //逻辑代码 } }) 注册局部指令 directive:{ \u0026#39;指令名\u0026#39;:{ inserted:function(el,binding) { //逻辑代码 } } } 全局自定义的案例 Vue.directive(\u0026#39;upper-text\u0026#39;,{ //一般对样式的操作在bind中 bind:function(el) { el.style.color=\u0026#39;red\u0026#39; }, //一般对js的操作在inserted中 //el为指令作用的DOM元素 //binding用于获取使用该指令的绑定值(value)、表达式(expression) inserted:function(el,binding) { el.innerHTML=binding.value.toUpperCase() } }) 2.9 一些全局API Vue.use（插件相关） 用于在Vue中安装插件，通过插件可以为Vue添加全局功能。插件可以是一个对象或者函数，如果是对象，必须提供install方法，用来安装插件。\n使用Vue.use进行插件的安装，随后可以使用插件中的内容。\n\u0026lt;body\u0026gt; \u0026lt;!-- 使用插件中的自定义指令 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; v-my-directive\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 定义一个对象，表示插件 let MyPlugin = {} // 定义该插件的安装函数，传参Vue构造器，和可选的配置对象 MyPlugin.install = function (Vue, options) { console.log(options) //插件中注册全局的自定义指令 Vue.directive(\u0026#39;my-directive\u0026#39;,{ bind(el,binding) { el.style=\u0026#39;width:100px;height:100px;background-color:#ccc\u0026#39; } }) } //安装插件 Vue.use(MyPlugin,{someOption:true}) //实例化Vue对象并挂载元素 var vm = new Vue({ el:\u0026#39;#app\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; Vue.extend（构造子类） 用来构建一个Vue子类，对Vue构造器进行拓展。\n\u0026lt;body\u0026gt; \u0026lt;!-- app1报错，Vue中没有title，app2则不报错，Vue2是Vue的子类，包含title的data --\u0026gt; \u0026lt;!-- \u0026lt;div id=\u0026#34;app1\u0026#34;\u0026gt;app1:{{title}}\u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;div id=\u0026#34;app2\u0026#34;\u0026gt;app2:{{title}}\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var Vue2 = Vue.extend({ data() { return { title:\u0026#39;hello\u0026#39; } } }) // var vm1 = new Vue({ // el:\u0026#39;#app1\u0026#39; // }) var vm2 = new Vue2({ el:\u0026#39;#app2\u0026#39; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; Vue.set（添加属性） 用于向响应式对象中添加一个属性，确保新属性也是响应式的。格式为Vue.set(vm.obj,\u0026rsquo;tar\u0026rsquo;,\u0026lsquo;data\u0026rsquo;)。及向Vue实例vm中的obj数据对象中添加一个属性tar，属性值为data。需注意无法动态地添加根级属性，即添加的属性不能和obj同级。\nVue.mixin（全局混入） 用于全局注册一个混入（Mixin），将影响之后创建的每一个Vue实例。向实例中注入指定的行为（函数）。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 注册全局混入 Vue.mixin({ //注入钩子函数created created() { //取到自定义属性myOption并在控制台输出 var myOption = this.$options.myOption if(myOption) { console.log(myOption.toUpperCase()) } } }) //实例化时，由于全局注入了，钩子函数生效 var vm = new Vue({ //钩子函数检测该属性并在控制台输出 myOption:\u0026#34;Hello Mixin!\u0026#34; }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 对于混入，局部创建则为在Vue实例化时为mixins属性传入一个混入对象。\n//混入对象 var mixin = { created: function () { document.write(\u0026#39;混入调用\u0026#39; + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;) } } //传入混入对象，以数组形式传入，这样会进行合理的合并 new Vue({ mixins: [mixin], created: function () { document.write(\u0026#39;组件调用\u0026#39; + \u0026#39;\u0026lt;br\u0026gt;\u0026#39;) } }); 如果 methods 选项中有相同的函数名，则 Vue 实例优先级会较高。其次是混入对象中的。\n2.10 一些实例属性 vm.$props 接收从上级组件向下传递的数据，见传值一节。\nvm.$options 获取指定的选项（el,data,methods等），以及自定义的选项。或者说属性？\nvm.$el 用来访问vm实例使用的根DOM元素。即挂载的目标，返回的是一个DOM对象。\nvm.$children 获取当前实例的直接子组件，但返回值不保证顺序，也不是响应式的。\nvm.$root 用来获取当前组件树的根Vue实例，如果当前实例没有根实例，则获取到该实例本身。注意：是根组件，不是父组件。\nvm.$slot 插槽就是定义在组件内部的template模板，可以通过$slot动态获取。插槽用于决定将所携带的内容，插入到指定的某个位置\n每个默认插槽会接收组件标签中的所有内容，对于指定name的插槽，通过template标签的v-slot属性来完成命名指定。或者在指定标签中使用slot属性进行插槽的选定。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt; \u0026lt;!-- 内容插入到插槽当中 --\u0026gt; Hello \u0026lt;!-- 使用template模板结构定义插槽 --\u0026gt; \u0026lt;template v-slot:second\u0026gt;World\u0026lt;/template\u0026gt; \u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;first\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 启用插槽 --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;!-- 启用插槽指定name为second --\u0026gt; \u0026lt;slot name=\u0026#34;second\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 注册组件 Vue.component(\u0026#39;my-component\u0026#39;,{template:\u0026#39;#first\u0026#39;}) var vm = new Vue({el:\u0026#39;#app\u0026#39;}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; vm.$attrs 可以获取组件的属性，但不包括class、style以及被声明为props的属性。\n2.11 createElement\u0026amp;render 渲染 createElement()函数返回的是一个描述节点，用来告诉Vue在页面上渲染什么样的节点，亦称为虚拟节点，VNode。\n第一个参数：HTML标签名或者组件选项对象\n第二个参数：可选，可以传入一个与模板中属性相对应的数据对象\n第三个参数：是由createElement构建而成的子级虚拟节点，也可以用字符串生成文本虚拟节点。\n代码样例1：含有默认插槽\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt; 成功渲染，此处为默认插槽 \u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 注册组件 Vue.component(\u0026#39;my-component\u0026#39;,{ render(createElement) { // 传入createElement函数返回的VNode // 该VNode告知标签类型、样式属性、子级虚拟节点 return createElement(\u0026#39;p\u0026#39;,{ style: { color:\u0026#39;red\u0026#39;, fontSize:\u0026#39;16px\u0026#39;, backgroundColor:\u0026#39;#eee\u0026#39; } //this.$slots.default 理解为一个创建默认插槽 },this.$slots.default) } }) var vm = new Vue({el:\u0026#39;#app\u0026#39;}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 代码样例2：含有命名插槽\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;my-component\u0026gt; \u0026lt;!-- 各模板通过v-slot来定义指定的命名插槽 --\u0026gt; \u0026lt;template v-slot:header\u0026gt; \u0026lt;div style=\u0026#34;background-color: #ccc;height: 50px;\u0026#34;\u0026gt; header \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:content\u0026gt; \u0026lt;div style=\u0026#34;background-color: #ddd;height: 50px;\u0026#34;\u0026gt; content \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:footer\u0026gt; \u0026lt;div style=\u0026#34;background-color: #eee;height: 50px;\u0026#34;\u0026gt; footer \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;my-component\u0026#39;,{ render(createElement) { //该VNode类型为div，包含三个子级虚拟节点 return createElement(\u0026#39;div\u0026#39;, [ //三个子级虚拟节点，其各自的子节点包含命名插槽 createElement(\u0026#39;header\u0026#39;,this.$slots.header), createElement(\u0026#39;content\u0026#39;,this.$slots.content), createElement(\u0026#39;footer\u0026#39;,this.$slots.footer), ] ) } }) var vm = new Vue({el:\u0026#39;#app\u0026#39;}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; render函数写法 render函数由Vue调用，其中传入的参数为createElement函数，返回参数为createElement函数的返回值。\nrender(createElement) { return createElement(...) } render:(createElement) =\u0026gt; {return createElement(...)} render:createElement =\u0026gt;createElement(...) render:h=\u0026gt;h(APP)//h传入组件 3.Vue过渡和动画 3.1 transition组件 Vue为\u0026lt;transition\u0026gt;标签内部的元素提供了三个进入过渡和三个离开过渡的类。\n内置的class类名实现过渡 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 用于div的隐藏和显示的切换 --\u0026gt; \u0026lt;button v-on:click=\u0026#34;toggle\u0026#34;\u0026gt; Click \u0026lt;/button\u0026gt; \u0026lt;!-- name属性设置在过渡中切换的类名前缀,默认为v- --\u0026gt; \u0026lt;transition name=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;chart\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data: { show:true, }, methods: { toggle() { this.show=!this.show } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 其中transition标签设置name，前缀为box，在CSS中实现以该box-为前缀的过渡类，不设置则默认为v-。该标签自动应用这些class在达到效果。\n过渡类有：v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to。\n在CSS中操作transition（过渡）和animation（动画）来达到不同的效果。\n.chart { width: 200px; height: 50px; background-color: aqua; } /* 通过css内置类名来实现过渡,name前缀为box */ .box-enter-active, .box-leave-active { transition: width 3s; /*某一项属性 + 持续的时间*/ } .box-enter, .box-leave-to { width: 0px; } .box-enter-to, .box-leave { width: 200px; } 自定义类名 无需对transition标签的name属性进行设置，可以通过设置以下属性来配置自定义的css类。例如animate.css中已定义了一系列动画类。\nenter-class、enter-active-class、enter-to-class、leave-class、leave-active-class、leave-to-class\nappear初始渲染动画 给元素添加初始渲染的动画效果。在transition标签中进行相关属性的设置。\nappear-class表示初始class样式；appear-to-class表示过渡完成的class样式；appear-active-class会应用到整个过渡过程中。\n三者的顺序要求见vue.js教材P69。\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;show=!show\u0026#34;\u0026gt; Click \u0026lt;/button\u0026gt; \u0026lt;!-- 为transition标签设置appear属性 第一个appear代表开启此特性 --\u0026gt; \u0026lt;transition appear appear-active-class=\u0026#34;animated swing\u0026#34; enter-active-class=\u0026#34;animated bounceIn\u0026#34; leave-active-class=\u0026#34;animated bounceOut\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;show\u0026#34;\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; 使用@keyframes创建CSS动画 与前面提到的CSS过渡用法相比，@keyframes动画中的v-enter类名在节点插入DOM后并不会立即删除，而是在animationend（动画结束）事件触发时删除。\n@keyframes规则创建动画，即将一套CSS样式逐步演变成另一套，过程中可以多次改变CSS样式，通过百分比或者from和to（相当于0%和100%）来规定动画的状态。\n基本语法如下为： @keyframes 规则名字 {百分比 {样式；}}\n例子如下：\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;show=!show\u0026#34;\u0026gt;@keyframes创建CSS动画\u0026lt;/button\u0026gt; \u0026lt;!-- 内置class类实现过渡的方法 --\u0026gt; \u0026lt;transition name=\u0026#34;bounce\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;circular\u0026#34; v-if=\u0026#34;show\u0026#34;\u0026gt;原型\u0026lt;/div\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ show:true } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; transition标签中绑定name属性为bounce，在CSS中的过渡类将以他为前缀。CSS代码如下。\n\u0026lt;style\u0026gt; div.circular { width: 100px; height: 100px; background: red; border-radius: 50%; margin-top: 20px; text-align: center; line-height: 100px; color:aqua; } /* CSS中操作动画,通过animation */ .bounce-enter-active { animation: Ami .5s; } .bounce-leave-active { animation: Ami .5s; } /* 定义动画规则 */ @keyframes Ami { 0% { transform:scale(0); background: aqua; } 20% { transform:scale(1); background: burlywood; } 50% { transform:scale(1.5); background: blueviolet; } 100% { transform:scale(1); background: burlywood; } } \u0026lt;/style\u0026gt; 常见的一些CSS属性 animation：绑定动画，后带上绑定的动画规则名+时长\ntransition：绑定过渡，后带上需要变动的属性+时长，如果属性为all则为所有效果\nopacity：不透明度，0为隐藏，1为显示\ntransfrom：包括scale缩放，translateX水平方向移动等。\n使用钩子函数实现动画 Vue可以借助JavaScript来完成动画。在\u0026lt;transition\u0026gt;标签中定义了一些钩子函数。在methods中编写钩子函数。示例见教材P71。\n3.2多元素过渡 不同标签名的元素过渡 不相同标签名的元素可以使用v-if和v-else来实现过渡。\n相同标签名元素的过渡 需要通过key特性设置唯一值来标记，通过key让Vue来进行区别。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 进行切换 --\u0026gt; \u0026lt;button @click=\u0026#34;f=!f\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;!-- 设置唯一的key值以区分button --\u0026gt; \u0026lt;button v-if=\u0026#34;f\u0026#34; key=\u0026#34;edit\u0026#34;\u0026gt; EDIT \u0026lt;/button\u0026gt; \u0026lt;button v-else key=\u0026#34;save\u0026#34;\u0026gt;SAVE\u0026lt;/button\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ f:true } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 过渡模式 新旧两个元素参与过渡的时候，新元素的进入和旧元素的离开会同时触发。可以使用transition提供的过渡模式mode，它有两个值，分别为in-out和out-in。前者为新元素进来后旧元素再离开，后者表示旧元素离开后新元素再进来。\n多组件过渡 多组件过渡不需要使用key特性，使用动态组件即可。动态组件需要通过Vue中的\u0026lt;component\u0026gt;元素绑定is属性来实现。\n3.3 列表过渡 对于列表过渡，需要使用v-for和transition-group组件来实现。\n\u0026lt;transition-group\u0026gt;标签相当于给每个包裹的元素在外面加了一个transition标签。\n列表的每一项都需要进行过渡，列表在循环时要给每一个列表项添加唯一的key属性值。\n列表的进入和离开过渡 以下案例实现简单的列表过渡\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 绑定响应函数 --\u0026gt; \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;ADD\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;remove\u0026#34;\u0026gt;REMOVE\u0026lt;/button\u0026gt; \u0026lt;!-- 定义过度类前缀 --\u0026gt; \u0026lt;!-- 修改tag,渲染出p标签 --\u0026gt; \u0026lt;transition-group name=\u0026#34;list\u0026#34; tag=\u0026#34;p\u0026#34;\u0026gt; \u0026lt;!-- item赋给唯一的key属性 --\u0026gt; \u0026lt;span v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;list-item\u0026#34;\u0026gt; {{item}} \u0026lt;/span\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ items:[1,2,3,4,5], nextNum:6 }, methods:{ randomIndex() { return Math.floor(Math.random()*this.items.length) }, add() { this.items.splice(this.randomIndex(),0,this.nextNum++) }, remove() { this.items.splice(this.randomIndex(),1) } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 其中CSS样式为：\n\u0026lt;style\u0026gt; .list-item{ display: inline-block; margin-right: 10px; background-color: red; border-radius: 50%; width: 25px; height: 25px; text-align: center; line-height: 25px; color: #fff; } .list-enter-active,.list-leave-active { transition: all 1s; } .list-enter,.list-leave-to { opacity: 0; transform: translateY(30px); } \u0026lt;/style\u0026gt; 列表的排序过渡 通过v-move特性，在元素改变定位的过程中应用，可以通过name属性来自定义前缀，也可以通过move-class属性来设置自定义类名，和过渡类一致。\n4.Vue路由 实现URL和组件之间的一一对应。更新视图而不更新请求页面（单页面应用SPA）。\n4.1 vue-router 实现单页面前端路由时，提供了hash模式和history模式。默认为hash模式，使用URL的hash来模拟一个完整的URL，当URL改变时，页面不会重新加载。#就是hash符号，也成为锚点或者哈希符。hash值是指导浏览器动作的，对服务器没有影响。\n基本使用如下。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 该标签实现跳转链接功能 --\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt; 首页 \u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt; 关于我们 \u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 占位符使用，将路由规则中匹配的组件进行展示 --\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 组件模板 --\u0026gt; \u0026lt;template id=\u0026#34;sy\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;ab\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;关于我们\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 路由表 var routes=[ { path:\u0026#39;/\u0026#39;, component:{ template:\u0026#39;#sy\u0026#39; } }, { path:\u0026#39;/about\u0026#39;, component:{ template:\u0026#39;#ab\u0026#39; } } ] //通过全局路由构造函数构造一个路由器，其中配置路由表 var router = new VueRouter({ routes:routes }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, //将路由规则对象注册到实例上 router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; query方式传参 参数值存放在query对象，通过user组件对象的$route属性访问当前路由，调用query获取相关参数信息。\n使用query传参，参数会以查询字符串的形式显示在浏览器地址栏中。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/user?id=10\u0026amp;name=admin\u0026#34;\u0026gt; Login \u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;tmp\u0026#34;\u0026gt; \u0026lt;!-- 通过query获取参数对象 --\u0026gt; \u0026lt;h3\u0026gt;id:{{this.$route.query.id}} + name:{{$route.query.name}}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var user = { template:\u0026#34;#tmp\u0026#34;, //钩子函数输出当前路由 created() { console.log(this.$route) } } // 路由表对象 var router = new VueRouter({ routes:[ {path:\u0026#39;/user\u0026#39;, component:user} ] }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, // 注册路由 router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; params方式传参 将参数放在路径中或者隐藏，如下例子。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 此处会进行参数的解析 通过params进行参数的获取 --\u0026gt; \u0026lt;router-link to=\u0026#34;/user/10/admin\u0026#34;\u0026gt; Login \u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;tmp\u0026#34;\u0026gt; \u0026lt;!-- 插值表达式中省略了this --\u0026gt; \u0026lt;h3\u0026gt; id:{{$route.params.id}} name:{{$route.params.name}}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var user = { template:\u0026#39;#tmp\u0026#39;, created() { console.log(this.$route) } } var router = new VueRouter({ routes:[ // 在path中路径中以冒号的形式设置参数，传参id和name // 在link to中进行解析 {path:\u0026#39;/user/:id/:name\u0026#39;,component:user} ] }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.2 嵌套路由 嵌套子路由通过属性children实现，children也是一组路由。在路由表中的某一路由对象中加入children属性即可。例如\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34; tag=\u0026#34;li\u0026#34;\u0026gt;关于公司\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/contact\u0026#34; tag=\u0026#34;li\u0026#34;\u0026gt;联系我们\u0026lt;/router-link\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;about-tmp\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;about-detail\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;北京xx科技有限公司简介\u0026lt;/h1\u0026gt; \u0026lt;!-- 结构为：父路由地址/要去的子路由 --\u0026gt; \u0026lt;router-link to=\u0026#34;/about/detail\u0026#34;\u0026gt;公司简介\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/about/governance\u0026#34;\u0026gt;公司治理\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;contact-tmp\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;about-detail\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;联系我们\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;公司位于北京市海淀区中关村科技园内\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var about ={template:\u0026#39;#about-tmp\u0026#39;} var contact={template:\u0026#39;#contact-tmp\u0026#39;} //子路由对应的两个组件 var detail = { template:\u0026#39;\u0026lt;p\u0026gt; xx 是全球领先的 \u0026lt;/p\u0026gt;\u0026#39; } var governance = { template:\u0026#39;\u0026lt;p\u0026gt;公司坚持以客户为中心\u0026lt;/p\u0026gt;\u0026#39; } var router = new VueRouter({ //路由表 routes:[ //重定向路由 redirect { path:\u0026#39;/\u0026#39;,redirect:\u0026#39;/about\u0026#39; }, //带有子路由的路由对象 { path:\u0026#39;/about\u0026#39;, component:about, //子路由也是一组路由表 children:[ { //这里的path不用加上/，否则默认都从根路径开始请求 path:\u0026#39;detail\u0026#39;,component:detail }, { path:\u0026#39;governance\u0026#39;,component:governance } ] }, { path:\u0026#39;/contact\u0026#39;,component:contact } ] }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.3 命名路由 通过v-bind指令，绑定\u0026lt;router-link\u0026gt;标签的to属性，to属性中，name用于唯一标识某一条路由。在路由中，需通过name属性进行设置。\n传入对象的话to前面要加冒号。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 标签中绑定name属性，选定用哪一条路由，并传参数，该参数在路由对象通过params可获取 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;user1\u0026#39;,params:{id:123}}\u0026#34;\u0026gt;Login\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var usercomponent ={ template:\u0026#39;\u0026lt;h3\u0026gt; user component \u0026lt;/h3\u0026gt;\u0026#39;, created() { //打印当前路由的信息 console.log(this.$route) } } var router = new VueRouter({ //给路由中加入name属性，以标识一条路由 routes:[ { // 使用冒号的形式匹配参数 path:\u0026#39;/user/:id\u0026#39;, // 为路由进行命名 name:\u0026#39;user1\u0026#39;, // 映射的组件 component:usercomponent } ] }) // 挂载并注册路由 var vm = new Vue({ el:\u0026#39;#app\u0026#39;, router:router }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.4 命名视图 使用\u0026lt;router-view\u0026gt;可以为视图进行命名，其中定义name属性表示视图的名字，后续可以根据不同的name值展示不同的页面。如果没有设置名字，那么默认为default.\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 默认为default --\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view name=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;router-view name=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;h-tmp\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;header\u0026#34;\u0026gt;header头部区域\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;s-tmp\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;sidebar\u0026#34;\u0026gt;sidebar侧导航区域\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template id=\u0026#34;m-tmp\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;main\u0026#34;\u0026gt;mainBox主体区域\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; var header = {template:\u0026#39;#h-tmp\u0026#39;} var sidebar = {template:\u0026#39;#s-tmp\u0026#39;} var mainBox = {template:\u0026#39;#m-tmp\u0026#39;} var router = new VueRouter({ routes:[ { path:\u0026#39;/\u0026#39;, //根据命名的视图进行组件的分配 components: { \u0026#39;default\u0026#39;:header, \u0026#39;left\u0026#39;:sidebar, \u0026#39;main\u0026#39;:mainBox } } ] }) var vm = new Vue({el:\u0026#39;#app\u0026#39;,router:router}) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 4.5 编程式导航 router.push() 可以导航到不同的URL地址。这个方法会向history栈添加一条新的记录。\n单击\u0026lt;router-link\u0026gt;时，router.push()方法会在内部调用。\nrouter.replace() 用法和push类似，只是不会在history栈中添加新的记录。\nrouter.go() 参数是一个正数，代表在history历史中前进几步或者后退几步。\n5.Vuex状态管理 Vuex对象store可以理解为一个容器，立马包含了应用中大部分的状态state，定义组件初始状态，相当于Vue实例中的data属性；mutations通过事件处理方法改变数组状态，最终将state状态反应到组件中，类似于Vue实例中的methods属性。\n计数器案例 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt; {{this.$store.state.count}} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const store = new Vuex.Store({ state: { //定义初始数据count count:0 }, mutations: { //定义事件处理方法increase //接收参数为state初始状态，通过state获取到count的值并进行操作 increase(state) { state.count++ } } }) var vm = new Vue({ el:\u0026#39;#app\u0026#39;, store, methods: { increment() { //显式的提交mutation，提交状态变更 this.$store.commit(\u0026#39;increase\u0026#39;) } } }) \u0026lt;/script\u0026gt; 6.Vue.js Ajax(axios) axios为第三方Ajax请求库。使用：结合生命钩子函数获取数据，渲染数据。\n举例：\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{info}} \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el:\u0026#39;#app\u0026#39;, data() { return { info:null } }, mounted () { axios //发送GET请求 .get(\u0026#39;https://www.runoob.com/try/ajax/json_demo.json\u0026#39;) // 获取数据的处理 .then(response =\u0026gt; (this.info = response)) // 请求失败处理 .catch(function (error) { console.log(error); }); } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 7.组合式API 7.1 基本概念 组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：\n**响应式API：**例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。\n**生命周期钩子：**例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。\n**注入依赖：**例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。\n\u0026lt;template\u0026gt; Count is: {{ state.count }}, doubleCount is: {{ state.doubleCount }} \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;加\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive, computed } from \u0026#34;vue\u0026#34;; export default { setup() { const state = reactive({ count: 0, doubleCount: computed(() =\u0026gt; state.count * 2), }); function add() { state.count++; } return { state, add } } } \u0026lt;/script\u0026gt; 7.2 setup组件 setup() 函数在组件创建 created() 之前执行。\nsetup() 函数接收两个参数 props 和 context。\n第一个参数 props，它是响应式的，当传入新的 prop 时，它将被更新。\n第二个参数 context 是一个普通的 JavaScript 对象，它是一个上下文对象，暴露了其它可能在 setup 中有用的值。\n7.3 ref函数 ref() 函数可以根据给定的值来创建一个响应式的数据对象，返回值是一个对象，且只包含一个 .value 属性。\n在 setup() 函数内，由 ref() 创建的响应式数据返回的是对象，所以需要用 .value 来访问。\n7.4 reactive函数 作用：reactive是一个函数，接收一个普通的对象传入，把对象数据转化为响应式对象并返回\n7.5 生命钩子函数 在 Vue3 组合 API 中实现生命周期钩子函数可以在 setup() 函数中使用带有 on 前缀的函数：\n"},{"section":"Blog","slug":"/en/blog/network/","title":"【课程笔记】计算机网络","description":"this is meta description","date":"March 12, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"计算机网络","content":"Chapter1. 计算机网络与因特网（概述） 1.1 相关概念： 1.因特网服务提供者ISP（Internet Service Provider），提供IP地址，从而通过ISP接入因特网。\n2.分组交换机（packet switch），如路由器（router）和链路层交换机（link-layer switch）。\n3.主机（host）、端系统（end system），两者意义相同，主机可进一步被分为客户（client）和服务器（server）。\n1.2 网络边缘 - 接入网（access network） 1.定义 指端系统连接到其边缘路由器（edge router）的物理链路。边缘路由器是端系统到任何其它远程端系统的路径上的第一台路由器。\n2.家庭接入网（residential access nets） 常见类型：数字用户线（Digital Subscriber Line，DSL）和电缆因特网接入（cable Internet access）。\n数字用户线：每个用户的DLS调制解调器（modem）使用现有的电话线（双绞铜线）与位于本地电话公司的本地中心局（center office，CO）中的数字用户接入复用器（DSL access multiplexer，DSLAM）来交换数据。\n电缆接入：采用频分复用（frequency division multiplexing）。且这个系统中应用了光纤和同轴电缆，被称为混合光纤同轴（Hybrid Fiber Coax，HFC）。与DSL类似，电缆调制解调器（cable modem）与电缆调制解调器端接系统（Cable Modem Termination System，CMTS）进行数据交换。 光纤到户（Fiber to the home，FTTH）\n3.企业接入网（Enterprise access networks ） 以太网（Ethernet），通过以太网交换机与机构路由器相连，用户通过双绞铜线与以太网交换机相连。\n局域网（LAN）\n4.无线接入网（Wireless access networks） wireless LANs（无线局域网） 与 wide-area wireless access（广域无线接入）\n5.物理媒介（Physical media） 引导型媒体（guided media）\n双绞线（twisted pair ,TP）、同轴电缆（coaxial cable）：两个同心的铜导体、光缆（fiber optic cable）\n非引导型媒体（unguided media）\n地面微波（terrestrial microwave）、卫星无线电信道（satellite）\n6.主机发送数据报文（Host: sends packets of data） 将应用数据分成L bits长度的小块，称为包（packets）。\n以R(bits/sec)的传输速率（transmission rate）将数据包送入接入网。\n链路传输速率，也就是链路容量（link capacity），也就是链路带宽（bandwidth）。\n报文传输时延（packet transmission delay）：将l位数据包传输到链路所需的时间。计算式为L/R。\n1.3 网络核心 1.分组交换网络（包交换网络）Packet-switching 主机将应用层消息分解成包，数据块种有目的地址、源地址等辅助信息。\n单个分组传递到相邻节点，存储后查找转发表，转发到下一个节点。\n在源和目的地之间，每个分组都通过通信链路和分组交换机（packet switch），分组交换机有两类：路由器和链路层交换机。\n关键为存储与转发（store and forward）。对于路由器，在对输出链路传输当前分组的第一个比特之前，需要接收到整个分组。\n则对于长度为L bits的分组，需要L/R的时间完成源到路由器之间的传输，该时间过后路由器接收到整个分组，再进行下一次传输，总时延为2L/R。\n排队时延和分组丢失（queue delay and loss）\n分组丢失（丢包）（packet lost）：输出缓存（output buffer）或称输出队列（output queue）容量有限。\n两个关键的网络核心功能：路由、转发（routing and forwarding）\n每台路由器具有一个转发表（forwarding table），用于将目的地地址映射成输出链路。\n2.电路交换网络 circuit switching 包含以下三个步骤：（1）建立连接；（2）通话；（3）释放连接。效率较低，线路上真正用来传输的时间往往不到10%。\n3.报文交换网络 报文交换是分组交换的前身。报文被整个地交换而非拆分成若干个分组。\n1.4 计算机网络的分类 1.按网络的覆盖范围分类 广域网(Wide Area Network，WAN)\n城域网(Metropolitan Area Network，MAN)\n局域网(Local Area Network，LAN)\n个域网(Personal Area Network，PAN)\n2.按网络的使用者分类 公用网（Public Network）\n专用网（Private Network）\n3.按其它角度分类 传输介质分类：无线和有线\n网络拓扑分类：总线型、星型、环形、网状型\n交换方式分类：电路交换、报文交换、分组交换\n传输技术分类：点对点、广播\n1.5 计算机网络的性能指标 1.速率 指数据的传送速率，每秒传送多少个比特，也称为数据率（Data Rate）和比特率（Bit Rate）。单位为bps。\n**注意：**数据量单位中的K、M、T、G为2的10次、20次、30次、40次幂；速率单位中的k、M、G、T为10的3次、6次、9次、12次。\n2.带宽Bandwidth 在模拟信号在中带宽的单位为HZ，指某个信号所包含的各种不同频率成分所占的频率范围。\n计算机网络中表示线路的数据传输能力，单位和速率单位一致。\n传输速率从主机接口速率、线路带宽、交换器或者路由器接口速率中取最小值。（木桶效应）\n3.吞吐量throughput 单位时间通过某个网络或者接口的实际数据量。常被用于对于实际网络的测量。\n通信相关的应用程序增多时、吞吐量也会随之增大，但是受到网络带宽的限制。\n4.时延delay/latency 由传输时延（transmission delay ，发送时延）、传播时延（propagation delay）、排队时延（queuing delay）、处理时延（processing delay）四部分组成。\n传输时延 或称发送时延，指主机或者路由器发送路由器所耗费的时间，从发送分组的第一个比特开始到最后一个比特发送完毕的时间。 $$ 发送时延=\\frac{分组长度(b)}{发送速率(b/s)} $$\n传播时延 指电磁波在链路上传播一定距离所耗费的时间。 $$ 传播时延=\\frac{链路长度(m)}{电磁波在链路上的传播速率(m/s)} $$\n排队时延 分组进入路由器后，在路由器的输入队列中排队缓存并等待处理。\n网络通信量很大时，可能会造成路由器的队列溢出，使分组丢失，这时候排队时延相当于无穷大。\n处理时延 例如检查分组首部是否误码、提取地址、查找转发接口等。\n5.时延带宽积 $$ 时延带宽积=传播时延(s)×链路带宽(b/s) $$\n表示该链路能够容量的比特数目。也成为以比特为单位的链路长度。\n6.往返时间 往返时间（Round-Trip Time，RTT）指从发送端发送数据分组开始，到发送端受到从接收端发来的相应的确认分组的耗费时间。\n1.6 计算机网络体系结构 1.开放系统互连参考模型 国际标准化组织（International Organization for Standardization，ISO）提出开放系统互连参考模型（Open Systems Interconnection Reference Model，OSI/RM，简称OSI）。是一个七层协议的体系结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n2.TCP/IP参考模型 是一个四层协议的体系结构，网络接口层、网际层、运输层、应用层。核心协议是网际协议IP。\n传输控制协议（Transmission Control Protocol，TCP）和用户数据报协议（User Datagram Protocol，UDP）是TCP/IP体系结构传输层中的两个重要协议。\n3.原理参考模型 五层协议的体系结构：物理层、数据链路层、网络层、传输层、应用层。\n4.各层的任务 应用层：解决通过应用进程的交互来实现特定网络应用的问题\n运输层：解决进程之间基于网络的通信问题\n网络层：解决数据包在多个网络之间传输和路由的问题\n数据链路层：解决数据包在一个网络或者一段链路上传输的问题\n物理层：解决使用何种信号来表示比特0和1的问题\n1.7 专用术语 1.对等实体和实体 实体是指任何可发送或者接收信息的硬件或者软件进程。\n对等实体就是通信双方相同层次中的实体。\n2.协议 协议是控制两个对等实体在“水平方向”进行“逻辑通信”的规则的集合。\n计算机网络协议由三个要素：语法、语义、同步\n语法 用来定义通信双方所交换信息的格式\n语义 用来定义通信双方所要完成的操作。\n同步 用来定义通信双方的时序关系。\n3.服务 在协议的控制下，两个对等实体在水平方向上的逻辑通信使得本层能够向上一层提供服务。要实现本层协议，还要使用下一层所提供的服务。\n在同一系统中相邻两层的实体交换信息的逻辑接口被称为服务访问点。服务访问点用于区别不同的服务类型。\n数据链路层的服务访问点为帧的“类型”字段；网络层的服务访问点为IP数据包的“协议”字段；传输层的服务访问点为“端口号”字段。\n上层要使用下层提供的服务，必须通过与下层交换一些命令，成为服务原语。\n4.数据包术语 对等实体之间传送的数据包被称为该层的协议数据单元（Protocol Data Unit，PDU）。\n物理层：比特流（bit stream）\n数据链路层：帧（frame）\n网络层：分组（packet）；如果是IP协议，也成为IP数据报\n运输层：使用TCP协议，为TCP报文段（segment）；使用UDP协议，为用户数据报（datagram）\n应用层：应用报文（message）\nChapter2. 应用层 2.1 网络应用体系结构 1. 客户/服务器方式 客户和服务器是指通信中所涉及的两个应用进程。客户/服务器方式（Client/Server，CS）所描述的是进程之间服务和被服务的关系。\n基于C/S方式的应用服务通常是服务集中型的。\n2. 对等方式 没有固定的服务请求者和服务提供者，分布在网络边缘的各端系统中的应用进程是对等的，被称为对等方。\n基于P2P的应用是服务分散型 ，突出的特征之一就是它的可拓展性。\n2.2 动态主机配置协议 1.DHCP的作用 网络中的主机开机后自动启动DHCP程序，向DHCP服务器请求网络配置参数，包括IP地址、子网掩码、默认网关、DNS服务器。\nDHCP可为计算机自动配置网络参数，使得计算机“即插即联网”（Plug-and-Play Networking）。\n2.DHCP工作过程 下层协议 使用UDP提供的服务\nUDP端口号 DHCP服务器使用67；DHCP客户使用68\n工作流程 （1）DHCP DISCOVER DHCP客户端广播DHCP发现报文（DHCP DISCOVER）。\n源IP为0.0.0.0，目的IP为255.255.255.255。\n（2）DHCP OFFER DHCP服务器发现DHCP发现报文后，根据封装的MAC地址来查找数据库，查看是否有针对该MAC的配置信息。\n如果有则采用这些配置信息发送DHCP提供报文（DHCP OFFER）；如果没有，则采用默认配置信息进行发送。\n源IP为DHCP服务器的IP地址，目的IP仍为255.255.255.255。\n网络中的所有设备都会接收到DHCP OFFER，对于服务器会丢弃报文；对于主机则会进行检验是否为本主机发出的请求。\nTips：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址时，会使用ARP来确保所选的IP地址从未被网络中的其它主机占用。\n（3）DHCP REQUEST DHCP客户向所选择的DHCP服务器发送一个DHCP请求报文（DHCP REQUEST）。\n源IP为0.0.0.0，目的IP为255.255.255.255。以告知网络中的DHCP服务器是否被选择。\nDHCP REQUEST中封装事务ID、DHCP客户端的MAC地址和接收的租约中的IP地址，提供租约的服务器IP等信息。\n（4）DHCP ACK 服务器向DHCP客户端发送DHCP确认报文（DHCP ACK）。\n源IP为服务器的IP地址，目的IP仍为广播。\nDHCP客户收到该ACK报文段后，就可以使用所租用到的IP地址了。\nTips：在使用租用的IP地址之前，主机还会通过ARP检测该IP地址是否被网络中的其他主机占用。若被占用，则发送DHCP谢绝报文（DHCP DECLINE），并重新发送DHCP DISCOVER。\n（5）更新租用期 当IP的租期过半，DHCP客户会向DHCP服务器发送DHCP REQUEST来请求更新租用期。\n这里的REQUEST报文的源IP为原先租用到的IP地址，目的IP为DHCP服务器的地址。\n（6）续租响应 1.DHCP服务器同意续租，发送DHCP ACK。\n2.DHCP服务器拒绝续租，发送DHCP否认报文（DHCP NACK）。DHCP服务器收到NACK后，需要立即停止使用该租用的IP地址，并重新发送DHCP DISCOVER来获取IP地址。\n3.DHCP服务器未响应，在租用期过了87.5%后，DHCP客户必须重新发送DHCP REQUEST，若未响应，则在租用期到期后立即停止使用IP并重新获取IP地址。\n（7）DHCP RELEASE DHCP客户可以随时提前终止DHCP服务器所提供的租用期，发送DHCP释放报文（DHCP RELEASE）。\n源IP为0.0.0.0，目的IP为255.255.255.255。\n备注 DHCP为了增强协议的健壮性，规定：如果TCP/IP协议栈在初始化的过程中不接受单播IP数据包，则对于DHCP DISCOVER和DHCP REQUEST报文中，通过设置”BROADCAST“标志位为1，告知DHCP服务器，之后使用广播形式进行通信；反之”BROADCAST“标志位设置为0，并在报文中填入自己的MAC地址，则DHCP服务器在数据链路层封装帧的时候可以填入该MAC地址。\n3.DHCP中继代理 DHCP DISCOVER广播报文不会被路由器进行转发，需要给路由器配置DHCP服务器的IP地址并使之成为DHCP中继代理。\n当成为DHCP中继代理的路由器收到广播的DHCP发现报文后，会将其单播给DHCP服务器。\n2.3 域名系统 DNS使用UDP，熟知端口号为53.\n1.因特网的域名结构 域名的结构由若干分量组成，各分量之间用.隔开，分别代表不同级别的域名。每一级的域名都由英文字母和数字组成，不超过63个字符，也不区分大小写。完整的域名不超过255个字符。\n如：\u0026hellip;三级域名.二级域名.顶级域名。eecs.nbu.edu.cn。\ncn是顶级域名，代表中国；edu是在其下注册的二级域名，代表教育机构；nbu是在edu下注册的三级域名，代表宁波大学；eecs代表该校自行管理的四级域名，为信息学院。\n顶级域名 顶级域名（Top Level Domain，TLD）分为以下三类。\n1.国家顶级域名(nTLD)\n2.通用顶级域名(gTLD)：com代表公司企业；net代表网络服务机构；org代表非营利性组织；int代表国际组织；edu代表美国教育机构；gov代表美国政府部门；mil代表美国军事部门\n3.反向域(arpa)：用于反向域名解析。\n二级域名 在国家顶级域名下注册的二级域名由该国家自行确定。\n我国将二级域名划分为以下两类：\n1.类别域名：共七个，ac科研机构；com工商金融等企业；edu教育机构；gov政府部门；net提供网络服务的机构；mil军事机构；org非营利性组织。\n2.行政区域名：共34个，适用于我国各省、自治区、直辖市。\nTips：名称相同的域名其等级未必相同。\n2. 因特网上的域名服务器 域名系统DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。\n分为以下四个类型：\n根域名服务器 最高层次的域名服务器，每个根域名服务器都知道所有的顶级域名服务器的域名和IP地址。\n因特网上共有13个不同IP地址的根域名服务器，但每台服务器实际上是分布在世界各地的计算机组成的服务器群集。\n顶级域名服务器 这些域名服务器负责管理在其下注册的所有二级域名。\n当收到DNS查询请求时就会给出响应的回答，这可能是最终的查询结果，也可能是下一级权限域名服务器的IP地址。\n权限域名服务器 负责管理某个区的域名，每个主机的域名都必须在某个权限域名服务器所在处注册登记。\n权限域名服务器知道其管辖的域名和IP地址的映射关系。也知道其下级域名服务器的地址。\n本地域名服务器 主机发送DNS请求报文时首先会被送往该主机的本地域名服务器。\n本地域名服务器有代理的作用，会将报文转发给上述的域名服务器的等级结构中。\n本地域名服务器也叫默认域名服务器，其IP地址需要直接配置在需要域名解析的主机中。\n3.域名解析过程 因特网有两种域名查询方式：递归查询和迭代查询。\n递归查询主要是各级域名服务器接受上一级的委托后直接对下一级的域名服务器发起查询请求。\n迭代查询通过本地域名服务器依次访问根域名服务器、顶级域名服务器、权限域名服务器，对应的服务器地址由上一级域名服务器给出。\nTips：对于含有CDN的服务器的访问，在权威服务器处可能不会直接返回对应的IP地址，而是返回其对应的CDN服务器的权威域名服务器的域名。（重定向）\n4.域名系统高速缓存 高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。（记录时间通常为2天）\n不但在本地域名服务器中需要高速缓存，在用户主机中也需要。许多用户主机在启动时则从其本地域名服务器下载所有映射信息，只有在查询信息不存在时则向本地域名服务器发出查询请求。\n5.DNS记录和报文 DNS服务器存储了资源记录（Resource Record，RR），RR提供了从主机名到IP地址的映射。\nRR是一个四元组：{name，value，type，ttl}。\nTTL是该记录的生存时间，记录了应当从缓存中删除的时间。\nType A 此时Name是主机名，value是对应的IP地址。\n一条类型为A的RR提供了从标准主机名到IP地址的映射。\nType NS 对该域中的主机来说Name是域（如foo.com），Value是一个知道如何获取该域中主机IP地址的权威域名服务器的主机名。\n例如(foo.com dns.foo.com NS)就是一条类型为NS的RR。\nType CNAME Value是主机别名（host aliasing）Name对应的规范主机名（canonical hostname）。\n该记录能够向查询的主机提供一个主机对应的规范主机名。\n主机别名要比规范主机名来的容易记忆。\nType MX Value是一个别名为Name的邮件服务器的规范主机名。\nMX记录允许邮件服务器主机名具有简单的别名。通过MX记录，一个公司的邮件服务器和其他服务器（例如它的Web服务器）可以拥有相同的别名。\nDNS报文格式 首部区域 第一个字段（标识符）是一个16bit的数，用于标识该查询。会被复制到对查询的回答报文中，以便让客户用来匹配发送的请求和接收的回答。\n标识字段含有若干标识：1.查询/回答 2.权威的 3.希望递归 4.递归可用。\n首部中也包含一些有关数量的字段：问题数、回答RR数、权威RR数、附加RR数。\n问题区域 包含Name字段和Type字段\n回答区域 包含了对最初请求的名字的资源记录。再回答区域可以包含多条RR，因此一个主机名能有多个IP地址。\n权威区域 权威区域包含了其它权威服务器的记录\n附加区域 附加区域包含了其他有用的记录。例如：一条MX请求的查询，回答区域包含了一个RR，提供了规范主机名，在附加区域中，该记录也提供了对于邮件服务器的规范主机名所对应的IP地址。\n2.4 文件传输协议 FTP提供交互式的访问，允许客户明确文件类型与格式，并允许文件具有存取权限。\nFTP常见的用途是在计算机之间传输文件，尤其是用于批量传输文件。FTP的另一个用途是让网站的设计者将构成的网站内容的大量文件批量上传到他们的Web服务器。\n1.FTP的工作原理 FTP采用C/S方式，由主动模式和被动模式。\n主动模式 FTP服务器主动连接FTP客户。\n（1）FTP服务器监听监听端口号21，FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户和服务器之间传送FTP的相关控制命令。\n（2）有数据要传输时，FTP客户通过命令通道告知FTP服务器，让FTP服务器和FTP客户的另一个临时端口号建立TCP连接，为数据通道。\n（3）FTP服务器使用20端口和FTP客户告知的临时端口号建立TCP连接，用于文件的传输。\n被动模式 其余步骤与主动模式类似，在数据通路的建立过程中，为客户向服务器发起TCP连接。即在FTP服务器协商好临时端口后被动地等待FTP客户的TCP连接。\n2.5 电子邮件 1.电子邮件的组成 用户代理 用户代理是用户和电子邮件系统的接口，又称为电子邮件客户端软件。\n邮件服务器 邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接受邮件，还要维护用户的邮箱。\n电子邮件协议 发送方使用用户代理通过邮件发送协议（例如SMTP），将邮件发送给发送方的服务器；发送方服务器通过邮件发送协议将邮件发送到接收方的服务器；接收方使用用户代理通过邮件读取协议（例如POP3和IMAP）从接收方服务器中读取邮件。\n2. 电子邮件的发送和接受过程 （1）发送方作为SMTP客户，与发送方邮件服务器中的SMTP服务器进行TCP连接，端口号为25。\n（2）发送方邮件服务器中的SMTP客户和接收方邮件服务器中的SMTP服务器进行TCP连接，端口号为25。\n（3）接收方的用户代理作为POP3客户，从接收方邮件服务器中的POP3服务器进行TCP连接，端口号为110。\n3. SMTP的基本工作过程 SMTP使用C/S方式通信，负责发送邮件的SMTP进程为SMTP客户，负责接收邮件的SMTP进程为SMTP服务器。\nSMTP客户给SMTP服务器发送14条命令，SMTP服务器收到命令后给SMTP客户发送21种应答。\n（1）TCP连接建立后，服务器推送”服务就绪“给用户。\n（2）客户使用”HELO“命令向服务器说明身份，告知自己的域名。\n（3）服务器认为身份有效，发送应答代码250，否则发送其它错误代码（如421服务不可用）\n（4）客户收到应答后，使用”MAIL FROM”命令告知邮件来自何处。\n（5）服务器若认为合法则发送250。\n（6）客户收到应答后，使用命令“RCPT To“来告诉服务器去往何处。\n（7）服务器若由该收件人邮箱，则发送250。\n（8）客户收到应答后，发送”DATA”命令告知服务器准备进行内容的发送。\n（9）服务器若准备接收则发送代码354。\n（10）客户收到应答后，开始发送数据。\n（11）客户完成数据发送后，还要发送结束符\u0026rsquo;.\u0026rsquo;。\n（12）服务器若收件成功，则发送250。\n（13）客户收到应答后，使用命令“QUIT”请求断开连接。\n（14）服务器发回响应代码221表示接受请求并主动断开TCP连接。\n4.电子邮件的信息格式 首部包含From、To、Cc、subject，其中From和To是必填的。\nFrom 填入发件人的电子邮件地址，一般由邮件系统自动填入。\nTo 填入一个或者多个收件人的电子邮件地址。\nCc 抄送人的地址。\nSubject 邮件的主题，反应的是邮件的内容。\n5.多用途因特网邮件拓展 SMTP只能传输ASCII码文本数据，通过多用途因特网邮件拓展（Multipurpose Internet Mail Extensions，MIME）将非ASCII码的数据转换为ASCII码数据。随后采用SMTP协议进行传输。\n6.常用的邮件读取协议 邮局协议 邮局协议（Post Office Protocol，POP），POP3是其第三个版本。\nPOP3是个非常简单、功能有限的邮件读取协议。用户只能以下载并删除的方式或者下载并保留的方式对邮件服务器上的邮件进行简单管理，不能进行如创建文件夹、分类等操作。\nTCP连接，熟知端口号为110。\n因特网邮件访问协议 因特网邮件访问协议（Internet Message Access Protocol，IMAP）是功能比POP3强大的邮件读取协议。用户在自己的计算机上可以操作邮件服务器的邮件，就像在本地操作一样。IMAP是一个联机协议。\nTCP连接，熟知端口号为143。\n2.6 超文本传输协议 1.万维网 万维网是一个大规模的、联机式的信息存储所，是运行在因特网上的一个分布式应用。万维网通过网页之间的超链接，将不同网站的网页连接成一张逻辑上的信息网。\n2.统一资源定位符 万维网使用统一资源定位符（Uniform Resource Locator，URL）来指明因特网上的各种类型的“资源“的位置。\n由协议、主机、端口、路径组成。\u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;\n3.HTTP简介 超文本传输协议（HyperText Transfer Protocol，HTTP）定义了以下功能的实现方法：1.浏览器（即万维网客户进程）向万维网服务器请求万维网文档；2.万维网服务器把万维网文档传输给浏览器。\n基于TCP连接的，周知端口号为80.\n非持续连接方式 HTTP/1.0采用非持续连接方式。在该方式下，每次浏览器进程请求一个文档都要与服务器建立TCP连接，收到响应后则关闭连接。\n请求一个文档由接近2RTT的开销。\n持续连接方式 HTTP/1.1支持持续连接方式，万维网服务器在发送响应后仍然保持TCP连接，使同一个万维网客户和自己可以继续在这条TCP连接上传输后续的HTTP请求报文和响应报文。节省了很多RTT。\n4.报文格式 HTTP请求报文格式 第一行是请求行。”方法“字段开始，后跟一个空格，后跟URL，后再跟一个空格，后跟”版本“字段，最后回车换行（CRLF）。\n第二行开始是首部行。每一个首部行由”首部字段名“开始，后跟一个冒号，再跟一个空格，然后是该字段的取值。最后回车换行。\n可以有很多首部行。\n最后的首部行下面是一个空行。\nHTTP响应报文格式 第一行是状态行。由”版本“字段开始，后跟空格，后跟”状态码“字段，后跟空格，最后跟”短语“字段，最后CRLF。\n除状态行，其余部分和HTTP请求报文格式类似。\n状态码 常见的状态码包括\n200 OK：请求成功，信息返回在响应报文当中。\n301 Moved Permanently：请求的对象被永久转移了，新的URL在响应报文当中的”Location“首部行中。\n400 Bad Request：一个通用差错代码，表示该请求不能被服务器理解。\n404 Not Found：被请求的文档不在服务器上。\n505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP版本。\n5.Cookie Cookie提供了一种机制，使得万维网服务器能够”记住“用户，而无须用户主动提供标识信息。\n过程如下：\n（1）浏览器初次向Web服务器发送HTTP请求报文，Web服务器回为其产生一个唯一的Cookie识别码，并以此为索引在Web服务器的后端数据库中创建一个项目，用来记录该用户访问该网站的各种信息。\n（2）Web服务器给浏览器发回HTTP响应报文，包含一个首部字段”Set-Cookie“，该字段的取值就是Cookie识别码。浏览器收到响应报文后，就在特定的Cookie文件夹中添加一行，记录域名和识别码。\n（3）再次访问时，每发出一个HTTP请求报文，浏览器都会从Cookie文件中取出该网站的Cookie识别码，放到HTTP请求报文的Cookie首部行中。\n6.Web缓存和代理服务器 原始服务器会给每个响应对象设置一个”修改时间“字段（Last-Modified）和一个有效日期字段（Expires）。当主机需要请求原始服务器中的某个文档时，首先向代理服务器（Proxy server）发送请求，若代理服务器中该文档未过期，则直接将响应报文发送回给主机，否则该代理服务器就向原始服务器发送请求报文，其中包含首部行”If-modified-since“，取值即为该文档的修改日期。\n原始服务器比较该字段值和该文档的修改时间，若一致则回送304 Not Modified。代理服务器更新有效时间，并向主机发回响应。\n若不一致则原始服务器给代理服务器发送带有该文档的响应报文，则代理服务器也更新了该文档的内容和有效期，随后再将该文档响应发送会给主机。\nChapter3. 运输层 3.1 概述 运输层（Transport layer）协议为运行在不同主机上的应用进程提供了逻辑通信（logic communication）。\n传输层协议是在端系统中而不是在路由器中实现的。\n将主机间交付拓展到进程间交付被称为运输层的多路复用（multiplexing）和多路分解（demultiplexing）。\n3.2 多路复用和多路分解 将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。\n在源主机中将不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，将报文段传输到网络层的工作为多路复用。\n1.端口号 TCP/IP体系的运输层使用端口号来区别应用层的不同应用进程。\n端口号用16比特表示，取值为0~65535；\n熟知端口号 well-known port number, 0~1023，IANA（因特网号码分配管理局）将这些端口号指派给了TCP/IP协议中的一些重要的应用协议。\n例如FTP使用21/20；HTTP使用80；DNS使用53；SMTP使用25；DHCP使用67/68；BGP使用179；HTTPS使用443；RIP使用520\n登记端口号 1024~49151，为没有熟知端口号的应用程序使用，但需要进行手续登记以防重复。\n短暂端口号 49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。\n2.TCP的多路分解和复用 TCP套接字是由一个四元组进行标识的：（源IP、源端口、目的IP、目的端口）【需要向源进行反馈】\n发送方复用：IP数据报首部中协议字段为6，表示封装的是TCP报文段\n接收方分解：网络层根据首部协议字段向上交付给UDP\n3.UDP的多路分解和复用 UDP套接字是由一个二元组进行标识的：（目的IP、目的端口）\nIP数据报首部中协议字段为17，表示封装的是UDP用户数据报\n接收方分解：网络层根据首部协议字段向上交付给TCP\n4.特例 OSPF报文并不使用运输层的UDP或者TCP进行封装，而是直接使用网络层的IP进行封装，封装时的协议字段值为89。\n3.3 UDP和TCP的对比 UDP是无连接的；TCP是面向连接的\nUDP支持广播、多播和广播；TCP仅支持单播\nUDP是面向应用报文的，对应用进程交付下来的报文既不合并也不拆分，而是保留这些报文的边界。\nTCP是面向字节流的，将应用进程交付下来的应用报文仅仅看作一连串的、无结构的字节流。TCP不保证接收方应用进程所接收到的数据块和发送方应用进程所发出的应用层报文之间具有对应大小的关系。\nUDP用户数据报首部仅有8各字节；TCP报文段首部大小20~60字节不等。\n3.4 用户数据报协议UDP 1.UDP报文段结构 首部+应用数据报文\n首部中包含：源端口号、目的端口号、长度、检验和\n2.UDP检验和 UDP校验和提供了差错检测功能，但是对差错恢复无能为力。\n发送方的UDP对报文段中的所有16比特字的和进行反码运算，注意在求和时遇到的所有溢出都要进行回卷操作。\n接收方将所有16比特字进行相加，包括检验和，如果没有差错结果必然为16个1。\n3.5 传输控制协议TCP 1.TCP报文段首部格式 TCP发送数据时，从发送缓存中取出一部分或者全部字节并给其添加一个首部使其成为TCP报文段后再进行发送。\n由20字节的固定首部和最大40字节的扩展首部组成。\n源端口（Source Port）和目的端口（Destination Port）占16比特，标识发送该TCP报文段的应用进程。\n序号（Sequence number）占32比特，当序号取到最后一个时，下一个序号回到0。指出本TCP报文段数据载荷的第一个字节的序号。\n确认号（Acknowledgement number）占32比特，和序号类似，指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认（comulative acknowledgment，累计确认）。\n确认标志位ACK：取值为1时确认号字段才有效；取值为0时确认号字段无效。TCP规定在连接建立后传送的所有TCP报文段ACK需置1。\n首部长度（Header Length）占4比特，并以4字节为单位，用来指出TCP报文段数据载荷部分的起始处距离TCP报文段起始位置的距离。首部固定长度为20字节，因此该字段最小为0101（5*4=20），最大为60，即该字段最大为1111（15*4=20）\n保留字段：占6比特，目前应置为0\n窗口（Window size value）占16比特，以字节为单位，指出发出本报文段的一方的接收窗口。\n检验和（checksum）占16bit\n紧急指针（urgent pointer）16bit，以字节为单位，指明紧急数据的长度。发送方有紧急数据时，可以将其插队到缓存最前面，并立刻封装进行发送。紧急指针会指出本报文段数据载荷包含了多长的紧急数据，紧急数据后面是普通数据。接收方也不必缓存直接上交。\n同步标志位SYN：在TCP建立连接时用来同步序号。\n终止标识位FIN：用来释放TCP连接。\n复位标志位RST：用来复位TCP连接，当RST=1时，表明TCP连接出现了异常，必须释放连接后重连。还可以用来拒绝一个非法的报文段或者拒绝打开一个TCP连接。\n推送标志位PSH：接收方的TCP接收到PSH为1的报文段回尽快上交应用进程，不必等到接收缓存都填满后再上交。\n紧急标志位URG：和紧急指针字段配合使用。为1时紧急指针字段有效。\n选项字段包含：\n最大报文段长度（Maximum Segment Size，MSS）用来指出TCP报文段数据载荷部分的最大长度。\n窗口扩大选项：用来扩大窗口，提高吞吐率。\n时间戳选项：用于计算RTT，处理序号超范围清空，防止序号绕回（Protect Against Wrapped Sequence Numbers，PAWS）\n2.“三次握手”建立TCP连接 TCP客户：\nCLOSED状态\u0026mdash;(发送SYN包,SYN=1,seq=x)\u0026mdash;SYN-SENT状态\u0026mdash;(接收SYN,ACK包,发送ACK=1,seq=y,ack=x+1)\u0026mdash;ESTABLISHED\nTCP服务器：\nCLOSED状态\u0026mdash;LISTEN监听\u0026mdash;(接收SYN包,发送SYN=1,ACK=1,seq=y,ack=x+1)\u0026mdash;-SYN-RCVD状态\u0026mdash;(接收ACK=1,seq=x+1,ack=y+1)\u0026mdash;ESTABLISHED\nTips：\nTCP请求报文段没有数据载荷（SYN=1的报文段不能携带数据，但是要消耗掉一个序号）；\n对于最后一个ACK，TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不会消耗序号，即如果该ACK不携带数据，客户端发送的下一个报文段的序号仍为x+1。\n3.”四次挥手“释放TCP连接 Tips：\nTCP规定FIN等于1的TCP报文段即使不携带数据，但也要消耗掉一个序号。\nMSL（Maximum Segment Lifetime）意思是最长报文段寿命，RFC建议为2分钟。进入时间等待是为了避免数据报丢失而导致服务器方不断地进行超时重传。也可以使得本次TCP连接所产生的报文段从网络中消失，从而使得新的TCP连接中不会出现旧连接的报文段。\n保活计时器 当TCP服务器每次收到TCP客户进程的数据时，就重新设置并启动保活计时器（Keepalive Timer）。若保活计时器定时周期内未收到TCP客户进程发来的数据，到期后TCP服务器进程就向TCP客户进程发送一个探测报文段，反复发送10次若仍无响应则判断TCP客户进程所在主机出现故障，接着就关闭当前的TCP连接。\n4.可靠数据传输协议rdt rdt1.0 经完全可信的信道传播\nrdt2.0 经有比特差错信道的可靠数据传输；\n假定分组按序被接收\n基于重传机制的rdt：自动重传请求（Automatic Repeat reQuest，ARQ）\nARQ中处理比特差错的功能：差错检测、接收方反馈、重传\n它是一种停等协议（stop-and-wait）\n概括以下就是：基于差错检测和反馈机制，根据反馈来判断是否进行重传\n但是反馈的ACK和NAK也可能出错，sol：进行重传，并通过seq判断是重传的NAK（ACK）还是新发出的。\nrdt2.1 对seq进行模2操作，若接收新分组则模2结果发生变化\nrtd2.2 在ACK、NAK中将参数0、1带入，以减少一定的状态\nrdt3.0 经有比特差错和丢包可能的信道的可靠数据传输\n发送方负责检测和恢复丢包工作\n这里引入了倒计时定时器（countdown timer）[重传计时器]\n但rdt3.0仍为停等协议，于是引出了流水线（pipelining）工作\n对于流水线中的差错、超时、丢失，处理的两种基本方式是回退N步（Go-Back-N，GBN）和选择重传（Selective Repeat，SR）\n回退N步GBN GBN协议也常被成为滑动窗口协议（sliding-window protocol），N通常被成为窗口长度（window size）\nGBN的发送方必须做到以下若干事件的响应：\n上层调用 发送方首先检查发送窗口是否已满，若未满则产生一个分组并将其发送，反之将数据返回给上层\n收到ACK 由于采用累计确认（cumulative acknowledgment），若收到序号为n的分组的确认，即ack=n+1，那么表明接收方已经正确的接收到了序号为n及其以前的所有分组。\n超时事件 如果出现超时，那么发送方将重传所有已经发送但还未被确认过的分组。\n一个窗口中有一个计时器，它一般为最早已经发送但未被确认的分组的计时器。\n如果收到ACK后，仍有已经发送但未被确认的分组，则计时器被重启，反之停止该计时器。\n选择重传SR 对于GBN，单个分组的差错可能引起GBN重传大量分组，而许多分组根本没有必要重传。\n对于选择重传SR，通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。\n对于发送方 SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组被收到为止。\n[如果收到了一个ACK，倘若该ACK处于窗口之中，那么则标记该分组已被确认，如果该分组正好为send_base，即第一个已发送但未被确认，那么则进行窗口移动，基需要send_base移动到具有最小序号的未确认分组处。窗口移动后，如果有序号落在未发送分组中，则发送]\n对于接收方 如果接收窗口内的分组被收到，那么则送回一个ACK。如果以前没有收到该分组，那么进行缓存。如果该分组的序号等于接收窗口的基序号rev_base，则该分组及其以前的缓存号连续，分组交付给上层。\n如果序号是以前接受过的，那么则发送一个冗余ACK即可。\nTCP的选择确认 TCP的选择确认（selective acknowledgement，SACK）允许TCP接收方有选择地确认失序报文段，而不是累计确认最后一个正确接收的有序报文段。\n5.TCP的流量控制 TCP未其应用提供了流量控制服务（flow-control service）以消除发送方使接收方缓存溢出的可能性。\n注意：TCP发送方也可能因为IP网络的拥塞而被遏制，这种形式的发送方的控制被称为拥塞控制（congestion control）。\nTCP让发送方维护一个成为接收窗口的变量rwnd。接收窗口给发送方一个指示，该接收方还有多少可用的缓存空间。\nTCP发送方的发送窗口=min[自身拥塞窗口，TCP接收方的接收窗口]\n当发送方接收到来自接收方的确认报文，则将发送窗口移动至ack处，随后根据确认报文中的接收窗口大小动态地调整发送窗口。\nTCP发送方当接收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文，以避免死锁。\n6.TCP的拥塞控制 某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变差，这种情况叫做拥塞（congestion）。\n发送方要维护一个叫做拥塞窗口（Congestion Window）的状态变量cwnd，其值取决于网络的拥塞程度和所采用的TCP拥塞控制算法。\n判断网络拥塞的依据是：没有按时收到应到达的确认报文段而产生了超时重传。\n发送方维护的发送窗口（Sender Window）的状态变量swnd。swnd=min(cwnd,rwnd)。\n发送方还要维护一个慢开始门限（SSThresh）的状态变量ssthresh：\ncwnd\u0026lt;ssthresh，使用慢开始算法；cwnd\u0026gt;ssthresh，停止使用慢开始算法而改用拥塞避免算法；等于则都可以使用。\n慢开始 slow-start\ncwnd初始值为1个MSS（最大报文段长度）；ssthresh也有初始值，假设为16.\n每当传输的报文段首次被确认就增加一个MSS，即每个确认报文段就将cwnd增加一个MSS。\n相当于在一个传播轮次中cwnd翻倍。\n当即将超过ssthresh时，继续翻倍显然不合理，当cwnd等于ssthresh时，进入拥塞避免。\n拥塞避免 congestion avoidance\n每个RTT只将cwnd的值增加一个MSS。相当于对于每一个新到达的确认，cwnd增加一个MSS*（MSS/cwnd）字节。\n例如MSS是1460字节并且cwnd是14600字节。则在一个RTT内发送10个报文段。每到达一个ACK就增加1/10MSS的cwnd，因此在收到对所有10个报文段的确认后，cwnd就增加了一个MSS。\n是一种线性增长。\n当重传计时器超时，则判断网络很有可能出现了拥塞，进行：\n1.将ssthresh更新为发生拥塞时的cwnd的一半；2.将cwnd减少为1，重新开始执行慢开始算法。\n快速重传 fast retransmit\n对于拥塞，对于发送方来说可以有两种指示方式：1.重传计时器超时，2.收到三个冗余的ACK\n所谓快速重传就是发送方要尽快进行重传，而不是等待重传计时器超时后再进行重传。即收到三个冗余的ACK。这就要求了接收方要立即发送确认信息，即使受到了失序的报文段也要立即发出对已收到的报文段的重复确认（发出冗余ACK）。\n快速恢复 fast recovery\n发送方一旦收到三个冗余ACK，就知道仅仅丢失了个别报文段。于是不启动慢开始算法，而执行快速恢复算法。\n发送方将慢开始门限ssthresh和cwnd值调整为当前窗口的一半，开始执行拥塞避免算法。\n也有的快速恢复是把快速恢复开始时的cwnd再增大一点，即等于新的ssthresh+3。（TCP Reno）[既然发送方收到三个冗余ACK，则代表有三个数据报文段已经离开了网络，在接收方的接收缓存中，网络中减少了三个报文段，因此可以将cwnd适当扩大一些]\n7.TCP可靠传输的实现 滑动窗口机制（sliding window）\n对于不按序到达的数据，TCP无明确规定，通常对不按序到达的数据先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，然后再按需交付上层的应用进程\nTCP要求接收方必须有累积确认和捎带确认机制，这样可以减少传输开销。接收方不应过分推迟发送确认，否则会导致不必要的重传，TCP标准规定，确认推迟的时间不应超过0.5s。\n8.TCP超时重传时间的选择 指数加权移动平均 Exponential Weighted Moving Average，EWMA\n初始状态下：EstimatedRTT=SampleRTT；\n当获取新的样本时：EstimatedRTT=(1-α)·EstimatedRTT+α·SampleRTT （RFC推荐α=0.125）\n偏差加权移动平均 测量得到的样本RTT值：SampleRTT；RTT偏差：DevRTT；\n初始状态下：DevRTT=SampleRTT/2；\n在获取新的样本时：DevRTT=(1-β)·DevRTT+β·|SampleRTT-EstimatedRTT|（RFC推荐β=0.25）\n超时重传时间RTO TimeoutInterval=EstimatedRTT+4·DevRTT\n初始的TimeoutInterval的值为1秒。同时，当出现超时情况时，其值加倍；反之收到报文则通过上式进行计算。\n相关问题 当出现重传时，发送方极有可能无法判断收到的确认报文是对原发送报文的确认还是重传报文的确认，会导致对RTT的估计出错，因此Karn提出一个算法：在计算加权平均往返时间时，只要报文段重传了，就不采用其样本RTT。即重传时EstimatedRTT不被重新计算。\n而如果报文段的时延突然上升且保持。在原来计算出的重传时间RTO中不会受到确认报文段，于是重传。根据Karn，重传不被重新计算，这样RTO无法被更新，导致重传不断进行。\n对Karn算法进行修正，即重传一次，RTO则增大一些，一般是变成两倍。\nChapter4. 网络层 4.1 概述 1. 数据平面和控制平面 数据平面 数据平面功能，即网络层中每台路由器的功能，该数据平面功能决定到达路由器输入链路之一的数据报（即网络层分组）如何转发到该路由器的输出链路之一。\n控制平面 控制平面功能，即网络范围的逻辑，该控制平面功能控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。\n2. 分组转发和路由选择 分组转发 forwarding\n当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。\n转发是在数据平面中实现的唯一功能。将一个分组从输入链路接口转移到适当的输出链路接口的路由器本地操作。\n通常在几纳秒中完成，因此通常使用硬件来实现。\n路由选择 routing\n网络层必须决定这些分组所采用的路由或者路径。计算这些路径的算法被称为路由选择算法（routing algorithm）。\n是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。\n3. 网络层向上层提供的服务 面向连接的虚电路服务 核心思想是“可靠通信应由网络自身来保障”\n必须首先建立网络层连接—虚电路（Virtual Circuit，VC），以保证通信双方所需要的网络资源。\n通信双方沿着已建立的虚电路发送分组。\n这是一条逻辑上的连接，分组沿着这条逻辑链接按照存储转发的方式进行传送。\n但不被使用。\n无连接的数据报服务 核心思想是：可靠的通信应由用户主机来保障。\n不需要建立网络层连接。每个分组可以走不同的路径。\n通信结束后双方没有需要释放的连接。\n分组可能误码、重复、失序。是一个尽最大努力（best effort）的分组交付功能。\n4.2 网际协议IP 网际协议（Internet Protocol，IP）是TCP/IP体系结构中网际层中的核心协议。\n配合使用的四个协议：\n地址解析协议（Address Resolution Protocol，ARP）\n逆地址解析协议（Reverse Address Resolution Protocol，RARP）\n网际控制报文协议（Internet Control Message Protocol，ICMP）\n网际组管理协议（Internet Group Management Protocol，IGMP）\n1. 异构网络互连 网络根据其用户需求的不同拥有不同的拓扑、性能、协议，对于这些众多的异构网络，通过路由器进行互连。这些异构网络的网络层都使用相同的网际协议IP，从网络层看他们都好像一个统一的网络，即IP网。\n2.IPv4地址概述 32比特的唯一标识符，由因特网名字和数字分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）进行分配。\nIPv4的表示方法 采用点分十进制表示方法\n分类编址 包含网络号和主机号两个部分\n网络号：用来标志主机（或路由器）的接口所连接到的网络。\n主机号：用来标志主机（或路由器）的接口。\n分类编址将IPv4地址分成以下五类：\nA类地址：网络号8b，主机号24b，网络号最前面一位固定为0.\nB类地址：网络号16b，主机号16n，网络号最前面两位固定10.\nC类地址：网络号24b，主机号8b，网络号最前面三位固定110.\nD类地址：多播地址，最前面四位固定1110.\nE类地址：保留地址，最前面四位固定1111.\n只有A、B、C类主机可以分配给网络中的主机（或路由器）的各接口。\n主机号全0的地址是网络地址，不能分配给接口，主机号全1的是广播地址，不能分配。\nA类地址 网络号8b，第一位固定0\n最小网络号0，保留\n最大网络号127，用作本地环回测试地址，不指派\n最小的本地环回测试地址为127.0.0.1，最大的本地环回测试地址为127.255.255.254\n第一个可指派的网络号为1，网络地址为1.0.0.0\n最后一个可以指派的网络号为126\n可以指派的网络数量为126\n每个网络可以分配的IP地址的数量为2^24-2 [24位主机号，减去全0和全1]\nB类地址 网络号16b，前两位固定10\n最小可指派的网络号为128.0[2字节的网络号]\n最大可指派的网络号为191.255\n可指派的网络数量为2^(16-2)=16384\n每个网络可以分配的IP地址的数量为2^16-2=65534\nC类地址 网络号24b，前三位固定110\n最小可指派的网络号为192.0.0\n最大可指派的网络号为223.255.255\n可指派的网络数量为2^(24-3)=2097152\n每个网络可以分配的IP地址的数量为2^8-2=254\n通过左起第一个十进制数可以判断网络类别：\n小于127的是A类，128~191的是B类，192~223的是C类\n地址0.0.0.0是一个特殊的IPv4地址，只能作为源地址使用，表示“在本网络上的本主机”，比如DHCP DISCOVERY。\n地址255.255.255.255只能作为目的地址使用，表示“只在本网络上进行广播（各路由器均不转发）”。\n对于网络的分配，需要考虑到其连接的路由器端口也需要IP地址，广播地址和网络地址各需要一个IP地址。\n划分子网 将原来分类编制后的网络号再进行一定的拓展，选取原本的若干主机号将其定位子网号，从而实现进一步的划分\n子网掩码：将网络号和子网号的对应位置置为1，主机号置为0，这样将IP地址和子网掩码进行与操作可以获取网络号和子网号。\n对于默认子网掩码，A类为255.0.0.0，B类为255.255.0.0，C类为255.255.255.0。\n无分类编址 无分类域间路由选择（Classless Inter-Domain Routing，CIDR）消除了传统的A、B、C类地址以及划分子网的概念。\n改为两级结构：网络号和主机号\n原网络号在CIDR被称为网络前缀（Network-Prefix），是不定长的。\n与子网掩码类似，CIDR采用了32位的地址掩码（Address Mask），它消除了划分子网的概念，但经常也被成为子网掩码。\n采用斜线记法（Slash Notation）[亦称为CIDR记法]，在地址后面加上斜线\u0026quot;\\\u0026quot;，表明其网络前缀的长度。\nCIDR将网络前缀相同的IPv4地址组成一个“CIDR地址块”。\n路由聚合 由于一个CIDR地址块可以包含多个地址，在路由表中可以利用CIDR地址块来查找目的网络。这种地址的聚合被称为路由聚合（route aggregation）。路由聚合也被称为构造超网（supernetting）。方法就是找最长的共同前缀。\n网络前缀越长，地址块越小，路由就越具体，因此当有多条转发条目匹配时，应当选择最长前缀的[最具体的]，被称为最长前缀匹配。\nIPv4地址的应用规划 将给定的IPv4地址块划分成几个更小的地址块（或子网）。分为使用定长的子网掩码（Fixed Length Subnet Mask，FLSM）和使用变长的子网掩码（Variable Length Subnet Mask，VLSM）。\n对于变长的子网掩码，其通过已申请到的CIDR地址块中按需划分出更小的地址块，每个块的起始位置不能随意选取。最好连续。\n3.地址解析协议 IPv4地址和MAC地址 MAC地址（Media Access Control Address，MAC，媒体存取控制位址）封装在帧首部（数据链路层的协议数据单元PDU）。IP地址在IP数据报的首部。\n分组传递过程中，源IP和目的IP始终不变，而源MAC和目的MAC会逐链路不断变化。\n路由器在收到IP数据报后，根据其首部中的目的IP地址的网络号部分，基于自己的路由表进行查表转发。查表转发的结果可以指明IP数据报的下一跳路由器的IP地址，但无法指明该IP地址所对应的MAC地址，因此引入了地址解析协议（Address Resolution Protocol，ARP）。\nARP 每台主机都会维护一个ARP高速缓存表，记录IP地址和MAC地址的对应关系。\n当ARP高速缓存表中找不到想要的MAC地址，那么主机就要发送ARP请求报文来获取对应的MAC地址。\nARP请求报文中包含源IP、源MAC、希望得到MAC的IP地址。被封装在MAC帧中进行发送，MAC帧的目的地址位广播地址（FF-FF-FF-FF-FF-FF）。\n其它主机收到广播帧后，将其封装的ARP请求报文上交处理。上层的ARP进程进行解析，判断是否发出响应。ARP响应报文告知目标IP对应的MAC地址，将ARP响应报文封装在MAC帧中发送，目的地MAC为发出ARP请求的源MAC，即进行单播。\n其它主机收到单播帧后，判断MAC地址，若不匹配则丢弃，匹配则上交ARP响应报文，上层进程解析，将其中的对应记录添加到ARP高速缓存表中。\n高速缓存表中有动态和静态两种类型：动态类型是指主机通过ARP协议自动获取的，生命周期一般为2分钟。\nTips：ARP协议解决同一个局域网上的IP和MAC的映射问题，而不能跨网络使用。\n除了ARP请求报文和响应报文，还有用于检查IP地址冲突的“无故ARP（或者免费ARP）（Gratuitous ARP）”\n4.IP数据报 转发过程 主机发送 源主机通过自己的IP和掩码相与得到自己所在的网络号，同时拿目的IP和自己的掩码进行相遇，得到的网络号如果不相等，那么判断不在同一个网络中。[考虑：如果在同一个网络中，那么使用同一个子网掩码与出来的结果必定相同]\n在同一个网络中的网络设备之间可以直接访问。\n每一个网络中存在一个默认网关，在间接交付时，源主机通过ARP获取默认网关的MAC。由默认网关代替源主机进行转发。\n路由器转发 路由器根据IP数据报的目的IP进行查表，如果找得到条目则进行转发，反之向源主机发送ICMP差错报告。\n通过给路由器接口配置IP和掩码，路由器能自行得出与该接口直连的网络号。\n路由器不对广播IP数据报进行转发，否则容易导致巨大的广播风暴，浪费资源。（路由器可以隔离广播域和冲突域）\n首部格式 版本（Version）：占4b，表示IP协议的版本\n首部长度（Header Length）：占4b，以4字节为单位，最小取值为0101（5），表示IP数据报首部只有20字节的固定部分\n区分服务类型（Differentiated Services Field）：占8b，区分不同类型的IP数据报，提供不同等级的服务质量\n总长度（Total Length）：占16b，表示IP数据段的总长度（首部+数据载荷）最大取值为65535，以字节为单位\n[每一种数据链路层协议规定了帧的数据载荷的最大长度MTU（Maximum Transmission Unit），因此有些IP数据报要进行分片操作，PPP和以太网协议一般取为1500字节。]\n标识（Identification）：占16b，属于同一个IP数据报的各分片应具有相同的标识，IP软件会维护一个计数器，每产生一个IPv4数据报，计数器的值就加一。\n标志（Flags）：占3b，最低位（More Fragment，MF），MF=1表示后面还有分片，反之表示本分片为最后一个分片；中间位（Don\u0026rsquo;t Fragment，DF），表示是否允许分片，DF=1则不允许分片；最高位为保留位，设为0.\n片偏移（Fragment offset）：占13b，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。以8个字节为单位。\n生存时间（Time to live，TTL）：占8b，最初以秒为单位，最大生存周期为255秒。转发时，将该字段的值减去IP数据报在本路由器上耗费的时间，若不为0则转发，否则就丢弃。现在以跳数为单位，每次减一。[防止在路由环路中反复转发]\n协议（Protocol）：占8b，指明数据部分是何种协议数据单元：常用的有：ICMP1；IGMP2；TCP6；UDP17；IPv6（41）；OSPF89\n首部检验和（checksum）：占16bit，检测是否出现差错。每经过一个路由器，checksum重新计算。\n源IP地址（Source）：32bit，Destination也是如此。\n5.IPv6地址 IPv6基本首部 基本首部Base Header，40字节，是固定的，因此首部中取消了首部长度字段。\n拓展首部（Extension Header）不属于首部，和后面的数据部分组合起来构成有效载荷（payload），也成为净负荷。、\nIPv6首部字段仅有8个。\n取消了区分服务（服务类型）字段，其中通信量类和流标号字段实现了该功能。\n版本Version：4b，IPv6则为6\n通信量类Traffic Class：8b，区别数据报的类别\n流标签Flow Label：20b，属于同一个流的IPv6数据报具有同样的流标号。即流标号用于资源分配。对于传统的非实时数据，流标号没有什么作用，置为0即可。\n[流就是因特网上从特定源点到特定终点的一系列IPv6数据报（如实时音视频数据的传输），流的路径上所有路由器保障指明的服务质量]\n有效载荷长度Payload length：16b，最大值为65535，有效载荷的字节数量（包括拓展首部和数据部分）\n下一个首部Next Header：8b，相当于IPv4中的协议字段。当IPv6没有拓展首部，则它指出了IPv6数据报封装的何种协议数据单元PDU。如果有扩展首部，那么其值标注后面第一个拓展首部的值。\n跳数限制Hop Limit：8b，即为TTL，最大255跳。\n源和目的（Source \u0026amp; Destination）：均为128b。\n扩展首部 为了提高路由器处理数据报的速度，将原来IPv4的选项字段放到了拓展首部中。只有源和终点的主机处理，传输过程中的路由器均不处理这里的拓展首部。\n拓展首部字段有六种类型：逐条选项；路由选择；分片；鉴别；封装安全有效载荷；目的站选项。每一个拓展首部都有若干个字段组成，他们的长度也各不相同。\n每一个拓展首部的一个字段都是8b的”下一个首部“字段。\n表示方法 冒号十六进制记法：128个划分为8组，每组16个，16个可以变成4位十六进制。\n不区别大小写。\n在此基础上使用”左侧0省略“和”连续0压缩“。\n左侧0省略：每一组之中最前面的0可以不写；\n连续0压缩：两个冒号中间的一连串0可以省略，但只能进行一次压缩\n还可以集合点分十进制的后缀。\nCIDR斜线表示法也可以继续使用。\n地址分类 目的地址的三种基本类型：单播（unicast）、多播（multicast）、任播（anycast）\n为指明地址：全0，只能用于还没一个配置到地址的主机作为源地址\n环回地址：最低比特为1其余为0\n多播地址：最高八位为1，即为FF00::/8\n本地链路单播地址：最高十个比特为1111111010，即为FE80::/10\n全球单播地址：剩余的即是，结构包含：48b的全球路由选择前缀(Global Routing Prefix)，相当于原来的网络号；16b的子网标识符(Subnet ID)，用于各共公司和机构构建子网；64b的接口标识符(Interface ID)，相当于主机号。\n从IPv4到IPv6的过渡 双协议栈 双协议栈（Dual Stack），一部分主机装有IPv4和IPv6两套协议栈；在不同协议栈的两部分分界处进行报文的转换。\n隧道技术 隧道技术（Tunneling），当IPv6数据报要进入IPv4网络时，将IPv6数据报重新封装成IPv4数据报，即整个IPv6数据报称为IPv4数据报的数据载荷。\n4.3 路由配置和路由选择 1.静态路由配置 路由器除了自行得出的直连路由和手动配置的非直连路由。还有一些特殊的路由：默认路由和特定主机路由。\n默认路由 默认路由条目中的目的网络填为0.0.0.0/0，其中0.0.0.0表示任意网络。由于最长前缀匹配，因此这里前缀为0的优先级最低。\n特定主机路由 网络前缀为/32，是最长的网络前缀，匹配优先级最高。\n2.路由选择协议 分类 域间路由选择（Interdomain Routing）-对应协议为外部网关协议（External Gateway Protocol，EGP）：RIP OSPF\n域内路由选择（Intradomain Routing）-对应协议为内部网关协议（Interior Gateway Protocol，IGP）：BGP\n集中式路由选择算法（centralized routing algorithm）：需要全局网络信息\u0026ndash;链路状态（Link state，LS）算法 分散式路由选择算法（decentralized routing algorithm）：通过迭代和信息交换的分布式计算\u0026ndash;距离向量（Distance-vector,DV）算法\n路由信息协议 路由信息协议（Routing Information Protocol，RIP）是内部网关协议IGP。RIP报文信息封装在UDP中，端口号520。\nAS内每个路由器都要维护一个距离向量，使用跳数（Hop Count）作为度量。\n距离等于16时相当于不可达。因此RIP只能适用于小型网络。\n当到达同一目的网络有多条RIP距离相等的路由时，可以进行等价负载均衡。\nRIP的特点：\n仅和相邻路由器交换信息；交换的信息是路由器的路由表；周期性交换（30S）\nBellmanFord思想进行更新。同一目的网络下，如果新路由表的下一条信息相同，则进行更新[因为可以知道是网络拓扑发生了变化]，如果下一跳的信息不同，那么则取最优，如果RIP距离相等，则保留，可以进行等价负载均衡。\n存在的问题：\n无穷计数问题（更新消息传递不及时，导致被误导），更正方案：路由表发生变化时则立马发送路由更新报文；水平分割[不让信息从原接口反方向传输]。\n开放最短路径优先协议 开放最短路径优先协议（Open Shortest Path First，OSPF），OSPF报文直接封装在IP数据报中。协议字段为89。\n基于链路状态并采用最短路径算法计算路由。\n链路状态 链路状态是指本路由器都和哪些路由器相邻，以及相应链路的代价，代价用来表示费用、距离、时延和带宽。\n思科路由器中OSPF协议计算代价的方法是：100Mb/s除以链路带宽，结果小于1则取1。[带宽越小，代价值越大]。\n邻居关系维护 通过问候（Hello）分组来建立和维护邻居关系。\nOSPF分组封装在IP数据报中，协议号字段为89。\nHello分组的发送周期为10秒，若40秒没有收到来自邻居的问候分组，则认为该邻居不可达。因此每个路由器都会建立一张邻居表。该40秒倒计时通过一个判活计时器进行计时。\n链路状态通告 使用OSPF的每一个路由器都会产生链路状态通告（Link State Advertisement，LSA）。包含：直连网络的链路状态信息和邻居路由器的链路状态信息。\n链路状态更新分组 LSA被封装在链路状态更新分组（Link State Update，LSU）中，使用洪泛法（Flooding）发送。即通过自己的所有接口进行转发，最终整个区域中所有的路由器都获得信息。\n链路状态数据库 使用OSPF的每个路由器都有一个链路状态数据库（Link State Database，LSDB），用于存储各路由器的LSA，各路由器的LSDB最终一致。\n最短路径计算 每个路由器根据LSDB可以得到一个带权有向图，执行Dijkstra可以得到以各自路由器为根的最短路径。\nOSPF区域划分 为了使OSPF协议能够用于规模较大的网络，OSPF把一个AS再划分成若干个更小的范围，称为区域（area）。\n每个区域都有一个32b的区域标识符，可以用点分十进制表示。主干区域的标识必须为0。每个区域一般包含的路由器不应超过200个\n如果路由器的所有接口都在区域内，则为区域内路由器（internal router）；一个接口用于连接自身所在区域，另一个接口用于连接主干区域，则为区域边界路由器（area border router）；主干区域的路由器被称为主干路由器（backbone router）；在主干区域中有一个专门和本AS外的其它AS交换路由信息的路由器，成为自治区域边界路由器。\n边界网关协议 边界网关协议（Border Gateway Protocol，BGP），BGP报文基于179端口的TCP连接。\nAS间的路由选择必须考虑相关政策，如政治，经济。\nBGP力求寻找一条能够到达目的网络且比较好的路由。主要进行可达性信息的传播。\n在BGP中，每对路由器[网关路由器]通过179端口的半永久TCP连接交换路由选择信息，即BGP连接（BGP connection）。\n跨越两个AS的BGP连接为外部BGP连接（eBGP），反之为内部BGP连接（iBGP）。\n可达性信息传递 AS3中一个网关路由器通过eBGP连接向其他路由器告知“AS3 x”，（x是AS3中一个网络）。则相当于告知x在AS3中，收到该可达性信息的路由器通过iBGP连接将信息转发给其所在AS的所有路由器，同时也通过eBGP连接向其它路由器告知\u0026quot;AS2 AS3 x\u0026quot;，这告知了x的位置，也告知了到达的路径。【TopDown的P263】\n确定最好的路由 到达目的子网可能有多条路径，那么如何进行路径的选择？\n可达性信息中告知的子网前缀中包含一些BGP属性（BGP attribute），比如AS-PATH和NEXT-HOP。\nAS-PATH告知当前可达性信息中到达该AS所经过的所有AS；当某个子网前缀通过某个AS时，该AS将ASName加入到该AS-PATH的现有列表中。\nNEXT-HOP是AS-PATH起始的路由器接口的IP地址。\n从一个简单的路由选择算法开始，即热土豆路由选择（hot potato routing），意思是对于一个路由器，希望尽可能快的把分组送出当前AS，而不用担心其AS外部到目的地的余下部分的开销。因此它通过AS内部协议来找到多个网关（或者到NEXT-HOP）所需要的开销，并选择具有最小开销的那个网关进行转发。\n实际上的路由选择算法较为复杂，路由器被指派一个本地偏好（local preference）作为其属性之一，路由选择优先选择属性值较高的，在余下具有相同最高本地偏好值的，将选择具有最短AS-PATH的路由，在余下的路由中（具有相同local preference和AS-PATH长度），使用hot potato，选择最靠近NEXT-HOP的路由进行跳转。\n3.路由器的基本结构 路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。\n路由选择部分：路由选择处理机[执行控制平面功能]，执行路由选择协议，计算路由表\n分组转发部分：输入端口、输出端口、交换结构，通过转发表进行转发\n路由表需要对网络拓扑变化的计算最优化，而转发表是从路由表得出的，转发表的结构应当使得查找过程最优化。\n输入端口 包含线路端接、数据链路拆封、查找、转发、排队\n输入端口查找目的IP地址（“匹配”），然后将该分组送入交换结构（“操作”）。[匹配+操作]\n输出端口 包含排队（缓存管理）、链路数据处理、线路端接\n交换结构 交换结构switching fabrics\n经总线交换 一次只有一个分组能够经过总线。\n工作过程大致为：输入端口为分组预先计划一个交换机内部标签，指示本地输出端口，使分组在总线上传送和传输到输出端口，所有端口都能收到该分组，但只有标签匹配的端口才能保存。\n经内存交换 在路由选择处理器的直接控制下完成。路由选择处理器从首部提取目的地址，在转发表中查找适当的输出端口，并将该分组复制到输出端口的缓存中。一个分组到达输入端口时，会通过中断方式向路由选择处理器发出信号。\n经互连网络交换 Crossbar，也成为交叉开关矩阵或者纵横式交换矩阵，能够并行转发多个分组。\n4.4 网际控制报文协议ICMP 网际控制报文协议（Internet Control Message Protocol，ICMP）\n被封装在IP数据报发送。包含终点不可达、源点抑制、时间超过、参数问题、改变路由（重定向）。\n1.差错报告报文 终点不可达 路由器发现无目的网络的转发条目则丢弃数据报并且往源主机发送ICMP差错报文，具体类型为终点不可达。\n具体也包含：目的网络不可达（Type3 Code0）；目的主机不可达（Type3 Code1）；目的协议不可达（Type3 Code2）；目的端口不可达（Type3 Code3）；目的网络未知（Type3 Code6）；目的主机未知（Type3 Code7）\n源点抑制 路由器由于网络拥塞而丢包，则往源主机发送该类型报文，以示减少发送速率。Type4。\n时间超过 路由器会将目的IP不为自己的IP数据报进行TTL减一，如果结果不为0，则转发，反之则丢弃并往回发送TTL过期，Type11.\n参数问题 路由器收到IP数据报后，进行checksum的检查，如果出现误码则丢弃并往回发送报文。Type12.\n改变路由 如果路由器发现更好的路由，则通过这种类型的ICMP报文告知主机变更路由。\n2.ICMP询问报文 回送请求和回答 即回显请求和回显回答（对ping的回答），收到回显请求的主机必须发送ICMP回显回答报文。可以用来判断目标是否可达。\n时间戳请求和回答 用来请求某个主机或路由器回答当前的时期和时间。用来时钟同步和测量时间。\n3.ICMP的应用 ping 分组网间探测（Packet InterNet Groper，PING），主机向目标发送四个回显请求报文。由于往返的ICMP报文上都有时间戳，容易计算出RTT。\ntraceroute 跟踪路由。windows版本的命令为tracert，UNIX版本的命令为traceroute。\n基本原理：主机给目的发送ICMP回显请求报文，IP数据报字段的TTL值被设置为1.TTL递减，当为0时像源主机发送ICMP差错报告报文，类型为超时。接下来继续发送TTL值为2、3、4的ICMP回显请求报文\n4.5 VPN与NAT 1. 虚拟专用网 虚拟专用网（Virtual Private Network，VPN），利用公用的因特网作为机构专用网之间的通信载体。\n由于很多机构所分配到的IP地址远小于其主机数目，可以进行专用地址（Private Address）的分配，不需要向因特网的管理机构申请。\n专用地址在机构内部使用，因特网中的所有路由器，其对目的地址是专用网络的IP数据报一律不转发。\n每个机构的专用网之中至少需要一个路由器具有合法的全球IP地址，这样经过VPN配置，各自的专用网才能利用公用因特网进行配置。\n专用网络 10.0.0.0~10.255.255.255（CIDR 10/8）\n172.16.0.0~172.31.255.255（CIDR 172.16/12）\n192.168.0.0~192.168.255.255（CIDR 192.168/16）\n工作过程 专用网内的主机向路由器发送IP数据报，路由器重新添加IP首部，将源和目的IP改为对应的专用网路由器的IP，同时加密原有IP报文。\n也被称为IP隧道技术\n同一机构不同部门的内部网络所构成的VPN称为内联网（Intranet或Intranet VPN，即内联网VPN）。\n有外部机构则为外联网（Extranet或Extranet VPN，即外联网VPN）。\n需要访问公司内部的专用网时，只需要在任何地点接入到因特网，运行VPN软件（进行IP的转换，否则专用网络的目标IP不会被转发），该PC和主机之间建立VPN隧道，可以访问到其中的资源。远程接入VPN（Remote Access VPN）。\n2. 网络地址转换 网络地址转换（Network Address Transition，NAT）。\nIPv4地址面临被耗尽的风险。NAT使得大量使用内部专用网络的用户共享少量外部全球地址来访问因特网上的主机和资源。\n通过网络地址和端口转换NAPT，维护一个NAT转换表。\n将专用网内的各专用地址映射成一个公网地址和唯一的端口号。当生成一个新的源端口号时，NAT可以任意选择一个当前未在NAT转换表中的源端口号。\n注意：专用地址不能充当服务器功能，即外网主机不能首先发起通信，这样当外网数据报到达NAT路由器时，在转换表中找不到对应的记录。需要网络应用自己使用一些特殊的NAT穿越技术。\n4.6 IP多播技术 1.基本概念 多播（Multicast）是实现“一对多”通信的技术。在因特网上进行的多播称为IP多播。\n和IP任播的区别 IP任播（anycast）：考虑CDN，是指一组具有相同IP地址的设备中实际只有一个接收数据包。在IP任播中，多个设备共享同一个IP地址，但是不同设备有不同的物理位置，因此数据包只被发送到最近的一个设备。\nIP多播（multicast）：在IP任播中，多个设备共享同一个IP地址，但是不同设备有不同的物理位置，因此数据包只被发送到最近的一个设备。\nIP任播是一种点对点的通信方式，而IP多播是一种点对多点的通信方式。\n2.多播地址 IPv4中，D类地址被作为多播地址。起始的四个比特固定为1110，剩余28比特任意变化。\n最小的IPv4多播地址为224.0.0.0；最大的为239.255.255.255。只能用作目的地址，而不能用作源地址。\n用每一个D类地址来标识一个多播组，使用同一个IP多播地址接收IP多播数据报的所有主机构成了一个多播组。\n每个多播组的成员是可以随时变动的，一台主机可以随时加入或者离开多播组。\n一台主机可以属于几个多播组。\n非多播组成员可以向多播组发送IP多播数据报。\nIP多播数据报也是best effort。\nIP多播地址可以分为预留的多播地址（永久多播地址）、全球范围可用的多播地址以及本地管理的多播地址。\n3.多播类型 分为两种：只在本局域网上进行的硬件多播和在因特网上进行的多播。\n而大部分主机都是通过局域网接入因特网，因此在多播的最后阶段一般都是局域网内的硬件多播。\n在局域网上进行硬件多播 由于MAC地址有多播MAC地址，只要将IPv4地址映射成局域网的硬件多播地址（即多播MAC地址）。MAC帧首部的MAC地址字段就设置为IPv4多播地址映射成的多播MAC地址。\n《深入浅出》P239\n在因特网上进行多播 必须考虑IP多播数据报经过多个多播路由器进行转发的问题。\n多播路由器必须根据IP多播数据报首部的IP多播地址将其转发到有该多播组成员的局域网。\n每个路由器则需要直到其接口所连局域网之中是否有某个多播组的成员。使用网际组管理协议（Internet Group Management Protocol，IGMP）。是网际层协议。作用是让连接在本地局域网上的多播路由器知道本局域网上的主机加入或者退出某个多播组。\nIGMP只在本网络中有效，IGMP并不能知道多播组所包含成员的数量，也不知道多播组的成员都分布在哪些网络。\n还需要使用多播路由选择协议。它建立了多播转发树。在多播转发树上进行洪泛，则所有多播组成员都能获取IP数据报。\n不同的多播组需要维护不同的多播转发树，必须动态的知晓多播组的变化。\n4.网际组管理协议 网际组管理协议（Internet Group Management Protocol，IGMP）。\n《深入浅出》P243\n5.多播路由选择协议 4.7 移动IP技术 1.基本概念 移动IP（Mobile IP）使得移动主机在各网络之间漫游时，仍能改变其原来的IP地址不变。也向非移动主机提供了相应机制，使得他们能够将IP数据报正确的发送到移动主机。\n归属代理接收外来的IP报文段，并向外地代理发送，外地代理收到信息后转发给移动主机。\n4.8 软件定义网络 1.核心思想 把网络的控制层面和数据层面分离，而让控制层面利用软件来控制数据层面中的许多设备。\n路由器中的路由表（匹配加操作表）由远程控制器计算、安装和更新。\n2.OpenFlow OpenFlow协议是一个得到高度认可的标准，可以被看成是SDN体系结构中控制层面与数据层面之间的通信接口。\nOpenFlow协议使得控制层面的控制器可以对数据层面中的物理设备进行直接访问和控制。\n3.泛化转发 转发分组可以分成以下两个步骤：\n1.进行匹配：查找转发表中的网络前缀，进行最长前缀匹配；\n2.执行动作：把分组从匹配结果指明的接口转发出去。\nSDN对转发过程进行了扩充，广义转发分为以下两个步骤：\n1.进行匹配：能够对网络体系结构中的各层首部中的字段进行匹配；\n2.执行动作：不仅转发分组，还可以负载均衡、重写IP首部（类似NAT）、人为的阻挡或丢弃一些分组（类似防火墙）。\n在SDN的广义转发中，完成”匹配+动作“的设备并不局限在网络层工作，因此不再称为路由器，而称为”OpenFlow交换机“或者”分组交换机“，或更简单地称为”交换机“。\n流表 在SDN中取代传统路由器中转发表（匹配加操作转发表）的是流表（Flow Table），[一个流就是穿过网络中的一种分组序列，而在此序列中的每个分组都共享分组首部某些字段的值]，OpenFlow交换机中的流表是由SDN远程控制器来管理的。SDN远程控制器通过一个安全信道，使用OpenFlow协议来管理OpenFlow交换机中的流表。\n每个OpenFlow交换机必须有一个或者多个流表。每个流表项包含：首部字段值、计数器、动作。\n首部字段值 其中包含一组字段，用来使如分组（Incoming Packet）的对应首部与之匹配，因此又称为匹配字段。匹配不上字段分组被丢弃，或者被送到SDN远程控制器做更多的处理。\n计数器 一个计数器记录已经与该流表项匹配的分组数量的计数器；另一个计数器记录流表项上一次更新的时间。\n动作 动作字段是指一组动作，当分组匹配某个流表项时，执行该流表项中动作字段指明的动作。包括：把分组转发到指明的端口、丢弃分组、把分组进行复制后再从多个端口转发出去、重写分组的首部字段（包括数据链路层、网际层和传输层的首部）。\n4.关键特征 1.基于流的转发\n2.数据层面与控制层面分离\n3.位于数据层面分组交换机之外的网络控制功能\n4.可编程的网络\nChapter5. 数据链路层 5.1 概述 1.相关概念 链路 Link，是从一个节点到相邻节点的一段物理链路，中间没有其它交换节点。\n数据链路 Data Link，是基于链路的，把实现控制数据传输的协议的硬件和软件加到链路上，就成了数据链路。\n帧 Frame，是数据链路层对等实体之间再水平方向进行逻辑通信的PDU。\n2. 提供服务 封装成帧 封装成帧（framing），就是网络层交付下来的分组添加一个首部和尾部。其中包含一些重要的控制信息，包括：帧首部有帧开始符、源地址、目的地址；尾部有帧校验序列和帧结束符。每一种数据链路层协议规定了帧的数据载荷的长度上限，即最大传输单元（Maximum Transfer Unit，MTU），例如以太网的MTU为1500字节。\n差错检测 可靠传输（可靠交付） 保障无差错地经过链路层移动每个网络层数据报文，但通常是通过确认和重传取得的，用于产生高差错率的链路，而对于低比特差错的链路，包括光纤，这种服务可能是不必要的开销，因此有些链路层协议不提供可靠交付服务。[考虑rdt]\n链路接入 介质访问控制（Medium Access Control，MAC）协议规定了帧在链路上的传输规则。对于点对点链路，MAC协议比较简单；对于多个节点共享单个广播电路，即所谓多路访问问题，MAC协议用于协调多个节点的帧传输。\n5.2 差错检测 1.奇偶校验 使用单个奇偶校验位（parity bit），如果信息D中有d比特，需要添加一个附加的比特（校验比特），满足d+1个比特中1的总数是偶数（偶校验）。\n2.checksum 同UDP的checksum\n3.CRC 循环冗余检验（Cyclic Redundancy Check，CRC）。\n发送方 给定最高次数为r的生成多项式G，共有r+1位。\n在待发送信息最后添加r位的0。\n进行除法运算，获得余数，余数个数需与r一致。\n将r位余数添加到待发送信息末尾。\n接收方 将接收信息直接进行除多项式操作，若余数不为0则发生了错误。\n5.3 多路访问链路和协议 0.点对点协议 由链路一端的单个发送方和链路的另一端的单个接收方组成。包括PPP和HDLC（high-level data link control，高级数据链路控制）\n点对点协议PPP（Point-to-Point Protocol）为在点对点链路传输各自协议数据报提供了一个标准方法，包括：\n1.对各种协议数据报的封装方法\n2.链路控制协议LCP，用于建立、配置以及测试数据链路的连接\n3.一套网络控制协议NCPs，其中的每一个协议支持不同的网络层协议\n使用PPP的数据链路层向上不提供可靠传输服务。\nPPP帧格式 其中FCS为Frame Check Sequence，取值为CRC计算出的校验位\n多路访问协议用于协调多个发送和接收节点对一个共享广播信道的访问（多路访问问题，multiple access problem）。防止碰撞collide\n包括信道划分协议（channel partitioning protocol）、随机接入协议（random access protocol）、轮流协议（taking-turns protocol）\n1.信道划分协议 时分多路复用TDM 将时间划分为时间帧（time frame），并进一步划分每一个时间帧为N个时隙（slot）。然后把每个时隙分配给N个节点中的一个。通常选择的时隙长度应使一个时隙内能够传输单个分组。但节点被限制R/N bps的平均速率。\n频分多路复用FDM 将信道划分为不同的频段，每个频段有R/N的带宽，并把每个频率分配给N个节点中的一个。\n码分多址CDMA 码分多址（Code Division Multiple Access，CDMA）对每个节点分配一种不同的编码，然后每一个节点用它唯一的编码来对将要发送的数据进行编码操作。\nCDMA将每个比特时间划分为m个更短的时间片，称为码片clip。每一个站点被指派一个唯一的码片序列，满足不同站点的码片序列正交，相同站点的码片内积为1，与自身反码的内积为-1.[以上内积均为规格化内积，即要除以码片长度m]\n各站点若要发送1则发送码片序列，要发送0则发送码片序列的反码（乘-1的结果）。\n各站点将接收到的码片向量与自身指派的码片序列进行规格化内积计算，为1则收到信息1，为-1则收到信息0，否则没有收到信息。\n2.随机接入协议 时隙ALOHA 每一个时隙等于传输一帧的时间，需要在每个时隙的起点进行帧的传输。\n若发送碰撞，则有p的概率在之后的每一个时隙进行重新发送，直到该帧被成功传输。\n时隙ALOHA是高度分散的，每个节点检测碰撞并独立地决定什么时候进行重传，需要在节点中对时隙进行同步。\n效率为Np(1-p)^(N-1)，可计算最大效率为1/e=0.37 [效率定义为长期运行中有效发送时隙占总时隙的份额]\nALOHA 时隙ALOHA要求节点同步从每个时隙开始时进行传输，第一个ALOHA协议实际上是一个非时隙、完全分散的协议。\n即在从上层接收到帧后，立即发送该帧，如果碰撞了，则立即在它完整的传输完该碰撞帧后重新以概率p再次传一次，1-p的概率等待一个帧传输时间。\n最大效率仅为1/2e，是时隙ALOHA的一半。·\n载波侦听多路访问CSMA 对于ALOHA，一个节点的传输独立于广播信道上的其他节点的活动。\n载波侦听多路访问（Carrier Sense Multiple Access，CSMA）的关键在于载波侦听（carrier sensing），即一个节点在传输前先听信道，在信道空闲时再开始传输。\n碰撞检测CD 具有碰撞检测的载波监听多路访问（CSMA/CD，CSMA with Collision Detection）\n当某节点执行碰撞检测时，一旦检测到碰撞将立即停止传播。[减少了无用的帧的干扰，提高性能]\n由于站点必须”边发送帧边检测碰撞“，因此站点不可能同时发送和接收，即不可能进行全双工通信，只能进行半双工通信（双向交替通信）。\n协议过程：\n1.从网络层获取数据报，装帧，并置于缓存中；\n2.如果听到信道空闲，则开始传输，如果信道忙，则等待，直到侦听到没有能量信号才开始传输；\n3.传输过程中，适配器监视来自其它使用该广播信道的适配器的信号能量的存在；\n4.如果检测到其它适配器的能量，则终止传输（碰撞发生，停止传输帧）；\n5.终止传输后，等待一个随机时间量，返回步骤2[其实这里需要等待一个96比特时间的空闲信道]。\n当碰撞节点数量较小时。间隔时间较短，反之应较长。\n对于随机时间量的选择，采用二进制指数后退算法（binary exponential backoff）\n随机时间量的选择\n当传输一个帧，其连续经历了n次碰撞，则节点随机从[0,1,2,\u0026hellip;,2^n-1]中选择一个K值，连续碰撞越多，K的选择范围越大。\n对于以太网，一个节点等待的实际时间量为512K比特时间，即发送512比特进入以太网所需时间量的K倍，n能够取得最大值为10\n强化碰撞\n发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32b或者48b的人为干扰信号（Jamming Signal），以便有更多的碰撞信号使得所有站点都能够检测出碰撞。\n碰撞避免CA 3.轮流协议 轮流协议(taking-turns protocol)，包含轮询协议（polling protocol）和令牌传递协议（token-passing protocol）等。\n轮询协议 要求这些节点之一被指定为主节点。主节点以循环的方式轮询每个节点，并告知其能发送的帧的最多数量。以此进行循环\n令牌传递协议 这种协议中没有主节点。一个称为令牌（token）的小的特殊的帧在节点之间以某种固定的次序进行交换。\n当一个节点收到令牌时，仅当他有一个帧要发送时，它才持有该令牌，否则将向下一个节点传递令牌。\n缺点就是一个节点的故障或者占用令牌可能会导致整个信道崩溃，需要某些恢复步骤来保障令牌返回到循环中。\n5.4 交换局域网 1.MAC地址 要将计算机连接到局域网，需要使用相应的网络适配器（Adapter），简称为网卡NIC。\nMAC（Medium Access Control，媒体接入控制）地址是数据链路层地址，作为唯一标志，由于广播信道天然的广播特性，需要通过MAC地址来进行判断帧是否发送给自己。\nMAC地址也称为LAN地址、物理地址等。被固化在NIC的EEPROM中。\nMAC地址格式 MAC地址长度6字节，共48比特。\n前24比特为组织统一标识符（Organization Unique Identifier，OUI），也成为公司标识符，后24位为网络接口标识符，由获得OUI的厂商自行分配。\n处理方式 如果是广播地址，接收\n如果目的MAC与NIC上固化的MAC相同，则接收\n如果目的MAC是NIC支持的多播地址，则接收。\n安全问题 用户应确保自己拥有的全球单播MAC地址不被泄露，为了避免WIF连接时的MAC泄露问题，大多数移动设备已经采用了随机MAC技术。\n2.以太网 以太网技术 以太网是到目前为止最流行的有线局域网技术。是第一个广泛部署的高速局域网。\n初始的以太局域网使用同轴电缆总线来互联节点，使用总线拓扑的以太网是一种广播局域网，即所有传输的帧传输到与该总线连接的所有适配器都会被处理。\n20世纪90年代后期，大多数机构使用一种基于集线器（Hub）的星形拓扑以太网结构。[集线器工作在物理层]\n集线器作用于各个比特而不作用于帧，当比特到达接口时，集线器重新生成这个比特，将其能量放大并从所有接口传输出去，因此该星型拓扑结构也为广播局域网。\n21世纪处，以太网继续使用星型拓扑，但是位于中心的集线器被交换机（switch）所替代。[交换式以太网]\nIEEE于1990年指定了10BASE-T星型以太网的标准802.3i，为以太网在局域网中的统治地位奠定了牢固的基础。\n[每个站点到集线器的距离不超过100m，由于距离太远可能导致信号衰减到相关协议无法工作，例如CSMA/CD，在IEEE802.3标准中，两个网段可以使用转发器（repeater）进行连接，从而获得更长的运行距离]\n标准中：10、100、1000、10G或40G分别代表该标准中的传输速率（Mbps）；BASE指的是基带以太网（意味着物理媒介仅承载以太网流量）；T代表物理媒介双绞铜线，F代表光纤。\n以太网帧 格式 其中类型标志着数据载荷中的网络层协议，0x0800代表了IPv4协议、0x0806代表了ARP分组\nFCS中为四字节的CRC字段\n此外，以太网帧以一个8字节的前同步码（Preamble）字段开始，该字段的前七个字节为10101010，最后一个字节是10101011，前七个字节用于唤醒接收适配器，并且将它们的时钟和发送方进行同步。[这里可以理解成数据链路层帧在下放到物理层时还要加上一个前导码]\n最小帧长和最大帧长 最小帧长：若发送的帧过小，则可能检测不到实际产生的碰撞；为了能够检测出碰撞，帧的发送时延就不能少于端到端的往返时延，即一个争用期2t。对于10Mb/s的共享总线以太网，最小帧长为512b，即64B。[如果遭遇碰撞，一定在帧的前64B之前，在这个时间内，发送方一定能够检测出碰撞，而停止发送，因而接收端接收到的帧长会小于64，由此判断收到了因碰撞而损坏的帧]\n就是在2t争用期中传输的比特长度：最小帧长=数据传输速率×争用期（往返时延）\n最长帧长：帧太长而过度占用信道，还可能使得接收方溢出。因此以太网V2的MAC帧的最大长度规定为1518B（数据载荷1500B）。此时数据载荷最小为46B，为了满足帧长大于64B。\n3.链路层交换机 交换机的任务就是接收入链路层帧并将它们转发到出链路\n过滤和转发 过滤（filtering）是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。\n转发（forwarding）是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。\n交换机的过滤和转发借助于交换机表\n交换机表中包含某局域网上某些主机和路由器的表项，但不必是全部。\n表项包含：MAC地址 通向该MAC地址的交换机接口 表项被放置在表中的时间\n对于表项的处理\n表中没有对于目的地址的表项，交换机则广播该帧\n表中存在相关联的表项，则转发到对应的接口即可\n若表中存在的表项的对应接口为传入接口， 则无需进行转发，丢弃该帧执行过滤功能即可。\n自学习 交换机表是通过自学习（self-learning）进行自动、动态和自治地建立的。\n对于每一个接口收到的入帧，该交换机在表中存储：1.该帧的源地址字段中的MAC地址；2.到达的接口；3.当前时间\n如果在一段时间（老化期aging time）后，交换机没有收到以某个地址为源的帧，则在表中删除，以处理PC被替代的问题。\n交换机是即插即用的设备（plug-and-play device）\n特点 消除碰撞\n将异质的链路互连\n易于进行网络的管理\n全双工工作，在自身内部同时连通多对接口\n也使用生成树协议STP，来产生能够连通全网而不产生环路的通信路径 [路由器没有生成树限制，允许丰富的网络拓扑，活跃链路可能有多条]\n[交换机不会进行广播风暴的处理]\n对比：\n集线器 路由器 交换机 流量隔离 无 有 有 即插即用 有 无 有 优化路由 无 有 无 4.虚拟局域网VLAN 虚拟局域网（Virtual Local Area Network，VLAN）是一种将局域网内的设备划分成和物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。\n同一个VLAN内可以广播通信，不同VLAN之间不能广播通信。\nIEEE 802.1Q帧 VLAN标记的最后12个比特称为VLAN标识符VID，它唯一地标识了以太网帧属于哪一个VLAN。取值范围为1~4094（0和4095不表示）\n802.1Q帧由交换机处理而非用户主机。\n当交换机收到普通的以太网帧时，会将其插入四字节的VLAN标记，转变为802.1Q帧。[打标签]\n当交换机转发802.1Q帧时，可能会删除VLAN标记，转变为普通帧，[去标签]\n交换机的端口类型 交换机的端口类型有三种：Access、Trunk、Hybrid\n对于缺省的VLAN ID[端口上]：思科交换机上称为本征VLAN，华为交换机称为Port VLAN ID，即端口VLAN ID，简称为PVID。[默认VLAN]\nAccess端口 一般用于连接用户计算机、只能属于一个VLAN\nAccess端口的PVID值于端口所属的VLAN的ID相同，默认为1\n对于接收的处理方法\n一般只接受”未打标签“的普通以太网MAC帧。根据接收帧的端口的PVID给帧”打标签“，即插入四个字节的VLAN标记字段，字段中的VID取值与端口的PVID相等\n对于发送的处理方法\n若帧中的VID与端口的PVID相等，则”去标签“并转发该帧；否则不转发\nTrunk端口 Trunk端口一般用于交换机之间或者交换机和路由器之间的互连。\nTrunk可以属于多个VLAN\n用户可以设置Trunk端口的PVID值，默认为1。\n对于接收的处理方法\n接收未打标签的帧，根据接收帧的端口的PVID给帧”打标签“\n或者直接接收已打标签的帧\n对于发送的处理方法\n对于VID等于PVID的帧，”去标签“再转发。\n对于VID不等于PVID的帧，直接转发。\nHybrid标签 接收方面与Trunk端口一致\n发送方面可以视作端口有多个PVID，查看帧的VID是否在”去标签“列表中再考虑是否进行去标签操作。\n5.5 数据中心网络 1.用途 1.他向用户提供网页、搜索结果、电子邮件或流媒体视频；\n2.用于特定数据处理任务的大规模并行计算基础设施，比如搜索引擎的分布式索引计算；\n3.为其它公司提供云计算服务\n2.体系结构 数据中心的主机称为刀片（blade），一般是包括CPU、内存和磁盘存储的商用主机。\n每个机架包含20~40台刀片，机架顶部有一个交换机，被称为机架顶部（Top of Rack，TOR）交换机，与主机互连。\n数据中心网络支持两种类型的流量：在外部客户和内部主机之间流动的流量，主机之间流动的流量。包含多个边界路由器（border router），与公共因特网相连。\n数据中心网络设计（data center network design）是互联网络和协议设计的艺术，专注于机架彼此连接和边界路由器相连。\n负载均衡 为了支持来自外部客户的请求，每一个应用都与一个公开可见的IP地址关联。\n数据中心内部，外部请求首先被定向到一个负载均衡器（load balancer），其任务是向主机分发请求，以主机当前的负载作为函数来在主机之间实现负载均衡。\n一个大型的数据中心通常会有几台负载均衡器，每台服务于一组特定的云应用。\n负载均衡器不仅平衡主机之间的工作负载，而且还提供类似NAT的功能，将外部IP地址转换为内部适当主机的IP地址。防止客户直接接触主机\n等级体系结构 数据中心通常使用路由器和交换机等级结构（hierarchy of router and switch）\n三层交换机结构，边界路由器和接入路由器相连，随后连接三层交换机（TOPDOWN P332 图6-30）\n每台接入路由器下的主机构成了单一子网。为了使得ARP广播流量本地化，这些子网都被进一步划分为更小的VLAN，每个VLAN包含数百个主机。\n依然存在主机到主机容量受限问题。解决方法包括：1.部署更高速率的交换机和路由器；2.将相关服务和数据放在尽可能近的位置，以减少通过第二层或者第一层交换机的机架间通信。3，增强TOR交换机和第二层交换机之间以及第二层交换机和第一层交换机之间的选择[多增加一些互连通路，增大可能带宽]\n3.发展趋势 1.降低成本\n2.集中式SDN控制和管理\n3.虚拟化：虚拟机（VM）将运行应用程序的软件和物理硬件解耦\n4.物理约束：数据中心的网络运行环境有极高的容量和极低的时延，拥塞控制协议会导致极低的效率，目前已经提出和部署了几种解决这个问题的方法，例如直接内存访问技术（RDMA）\n5.硬件模块化和定制化：采用基于航运集装箱的模块化数据中心（Modular Data Center，MDC）。\nChapter6. 无线网络和移动网络 6.1 概述 1.相关要素 无线主机 wireless host\n无线链路 wireless communication link 主要特性：链路速率和覆盖区域\n基站base station 负责向与之关联的无限主机发送数据，并从主机那里接收数据 [例如蜂窝网络中的蜂窝塔（cell tower）和802.11无线局域网中的接入点AP]\n与基站关联的主机通常被称为以基础设施模式（infrastructure mode）运行，所有的传统网络服务（地址分配、路由选择）由网络向通过基站向量的主机提供\n自组织网络中（ad hoc network），无线主机没有这样的基础设施，主机本身必须提供相关服务（地址分配、路由选择、DNS等）\n从一个基站转移到另一个基站，这一过程为切换（handoff或者handover）\n6.2 无线链路和网络特征 1.相关特性 递减的信号强度、来自其它源的干扰、多路径传播（multipath propagation）\n无线链路协议不仅采用有效的CRC错误检测码，还采用了链路层可靠的数据传输协议来重传受损的帧。\n2.信号特征 SNR：信噪比 BER：比特差错率\n对于给定的调制方案，SNR越高，BER越低；\n对于给定的SNR，有高比特传输率的调制技术将有较高的BER；\n隐藏终端问题（hidden terminal problem）：由于信号的衰减（fading），导致信号强度不足以至于一些终端无法检测对方的传输。\n6.3 802.11无线局域网 802.11n（WiFi 4） 2.4GHz、5GHz 600Mbps\n802.11ac（WiFi 5）5GHz\t3.47Gbps\n802.11ax（WiFi 6）2.4GHz、5GHz 14Gbps\n1.体系结构 802.11体系结构的基本构建模块是基本服务集（Basic Service Set，BSS）。\nBSS包含一个或者多个无限站点以及一个接入点（Access Point，AP）[中央基站base station]\n部署AP的无线局域网经常被称作基础设施无线局域网（infrastructure wireless LAN），其中的“基础设施”是指AP连通互联AP和一台路由器的有线以太网。\n信道和关联 每个无线站点在能够发送和接收网络层数据之前，必须和一个AP相关联。\n每个AP都有被分配一个单字或者双字的服务集标识符（Service Set Identifier，SSID）。还必须被分配一个信道号。\n802.11定义了11个部分重叠的信道号，当且仅当两个信道由4个或者更多信道隔开时它们才无重叠。\nWiFi丛林（jungle）是一个任意位置，无限站点能从两个或者多个AP中受到强信号。需要与其中一个AP相关联（associate）\n如何进行关联？\n每个AP周期性地发送信标帧（Beacon Frame），包括该AP的SSID和MAC地址。无线主机扫描11个信道，找到位于该区域的AP所发出的信标帧。\n扫描信道和监听信标帧的过程被称为被动扫描（passive scanning）\n无线主机也能完成主动扫描（active scanning），通过向位于无线主机范围内的所有AP广播探测帧[发送探测请求帧Probe Request Frame]完成的。[AP会发回探测响应帧Probe Request Frame]\n选定关联的AP后，无线主机发送关联请求帧，并且AP以一个关联响应帧进行响应。\n2.802.11MAC协议 802.11无线局域网选择的一种随机接入协议，为带碰撞避免的CSMA（CSMA with collision avoidance），即CSMA/CA。\n对于802.11，使用碰撞避免而非碰撞检测，其次，对于无线信道相对高的比特差错率，使用链路层确认/重传（ARQ）方案。\n原因在于：\n接收信号的强度通常远远小于发送信号的强度，构建具有检测碰撞能力的硬件代价较大。\n适配器会由于隐藏终端问题和衰减问题而无法检测到所有的碰撞。\n802.11不再使用碰撞检测，一旦站点开始发送一个帧，就完全发送，为了降低碰撞的可能性，采用了几种碰撞避免技术。\n链路层确认方案 链路层确认（link-layer acknowledgment）\n无线局域网发送帧时，会因为多种原因不能无损的到达目的站点，为了处理这种故障，使用链路层确认方案。\n目的站点收到一个CRC检验的帧后，等待一个短帧间间隔（Short Inter-Frame Spacing，SIFS）后发回一个确认帧。\n如果发送站点在给定的时间内未能收到确认帧，则假定出现了错误并重传该帧，使用CSMA/CA协议访问该信道。\nCSMA/CA 1.某站点最初监听到信道空闲，将在一个被称为分布式帧间间隔（Distributed Inter-frame Space，DIFS）的短时间后发送帧。\n2.否则，选择一个随机回退值，并且在信道空闲时递减该值。在侦听到信道忙时反而不递减\n3.计数该值若减为0，即侦听信道空闲，站点发送整个数据帧并等待确认\n4.如果收到确认，则OK，如果还要发送其他帧，从第二步继续开始。若未收到确认，传输站将重新进入第二步中的回退阶段，在更大范围内选取随机值\n为什么信道忙时也要等待？\n考虑：如果两个站点都要发送数据帧，而此时第三个站点已经开始了传输，双方都未立即发送。\n如果像CSMA/CD一般，两个站点检测到第三方发送完毕后立马则开始发送，则会导致碰撞，在CSMA/CD中会因为检测碰撞而放弃发送，因此避免帧的无用部分继续被发送，而对于802.11，它不会检测碰撞和放弃发送，受损帧会继续传输。因此对于802.11，无论如何都要进行碰撞避免。\n处理隐藏终端问题 802.11包含一个不错的预约方案，帮助在隐藏终端的情况下进行避免碰撞。\n为了避免由于隐藏终端问题导致的互相隐藏的两个终端之间的碰撞问题，允许站点使用短**请求发送（Request to Send，RTS）控制帧和允许发送（Clear to Send，CTS）**控制帧来预约对信道的访问。\n过程\n当发送方要发送一个DATA帧时，首先向AP发送一个RTS帧，指示传输DATA帧和确认ACK帧的总时间。当AP受到RTS帧时，广播一个CTS作为响应，该CTS帧有两个目的：给发送方明确发送许可，指示其它站点在预约期内不要发送。完成传输后广播ACK帧。\n优势\n1.缓解了隐藏终端的问题\n2.RTS和CTS帧很短，设计它们的碰撞将仅持续短RTS和CTS的持续续期，一旦它们被正确发送，后面DATA和ACK就能无碰撞。\n3.IEEE 802.11帧 分为数据帧、控制帧、管理帧\n帧格式 帧控制：\n类型：区别数据帧、控制帧、管理帧\n子类型：每个类型又有多个子类型\n持续期：\n实现CSMA/CA的虚拟载波侦听和信道预约。在数据帧、RTS、CTS帧中指出信道占用时间\n序号控制：\n用来实现802.11的可靠传输，对数据帧进行编号 [回想TCP报文段的编号]\n地址：\n【图中去往DS和来自DS同TopDown教材中的到AP和从AP】\n[对于01 和 10 ，地址1均为当前帧的发送目标地址，地址2均为当前帧的发送源地址【单段】]\n[对于以太网来说，AP透明]\n4.同IP子网的移动性 在同一个子网下的不同BSS之间的移动\n过程：\n随着H1逐步远离AP1，H1检测到来自AP1的信号减弱，开始扫描一个更强的信号。H1收到来自AP2的信标帧，H1与AP1解除关联，并与AP2进行关联，保持其IP地址和正在进行的TCP会话。\n在交换机角度来说，交换机是“自学习的”，新关联形成后，新AP会以主机为源发送以太网广播帧，同子网内的相关交换机对此进行学习。\n5.高级特色 速率适应\n功率管理：明确在睡眠和唤醒状态之间交替，通过定时器的设置保障节点在AP发送信标帧[100ms一次]前进行唤醒[唤醒只要250ns]。如果AP发送的帧[非信标帧]的目的节点在睡眠，则缓存。\n6.蓝牙 6.4 蜂窝网络 蜂窝网络的组成：\n1. 4G LTE蜂窝网络 移动设备 具有全球唯一的64位标识符，称为国际移动用户身份（IMSI），存储在其SIM（用户身份模块）卡上。在4G LTE中，这种设备称为UE（用户设备）。\n基站 位于运营商网络的“边缘”，负责管理无线电资源和其覆盖区域内的移动设备。基站协助无线电接入网中的设备认证和资源分配（信道接入）。\n2. LTE协议栈 TOPDOWN375\n3. LTE无线电接入网 LTE在下行信道上使用FDM和TDM的组合，称为正交频分复用（OFDM）。\n4. LTE附加功能 网络连接 三个阶段：\n1.连接到基站\n2.互相鉴别\n3.数据路径配置\n功率管理：睡眠模式 又有深度睡眠，在不传输或者接收数据时进入睡眠状态\n5. 全球蜂窝网络 网络的网络\n有许多归属蜂窝运营商网络，它们也组成网络，通过公共因特网或者互联网协议分组交换IPX进行互连。[IPX是一种专门用于互连蜂窝运营商的被管网络]\n6. 5G蜂窝网络 5G核心网络是管理所有5G移动语音、数据和因特网连接的数据网络。\n6.5 移动性管理原则 [4.7 移动IP技术]\n实践中的移动性 Chapter7. 网络安全 7.1 基本概念 安全通信（secure communication）具有以下若干性质\n保密性（confidentiality）、报文完整性（message integrity）、端点鉴别（end-point authentication）、运行安全性（operational security）\n7.2 密码学原理 明文（plaintext，cleartext） 密文（ciphertext）\n加密算法（encryption algorithm） 解密算法（decryption algorithm）\n在对称密钥系统（symmetric key system）中，密钥相同且秘密\n在公开密钥系统（public key system，也称为公钥系统）中，使用一对密钥，一个密钥公开，另一个密钥单方知晓\n1.对称密钥密码体制 单码代替密码 单码代替密码（monoalphabetic cipher），使用字母表中国的一个字母替换另一个字母。并非按照规则的模式进行替换，而是由偏移量k决定。\n即一对一，有26！种配对\n多码代替密码 多码代替密码（polyalphabetic encryption），使用多个单码代替密码，并按照某种次序进行交替选择。\n攻击类别 唯密文攻击 只能截取密文，不了解明文\n已知明文攻击 确定明文中存在的一些字符，确定明文和密文种的某些匹配\n选择明文攻击 入侵者能够选择某一明文报文并且得到其对应的密文形式。\n块密码 分块，分成大小为k的块\n块和块之间通过映射表进行转换，映射表为key\n通过公开置乱函数，获得加密结果\n一些流行的块密码包括，DES（Data Encryption Standard，数据加密标准），3DES和AES（Advanced Encryption Standard，高级加密标准）\nDES使用了具有56bit密钥的64比特块\n3DES相当于三次DES，使用不同的密钥\nAES使用了128比特块，能够使用128、192、256比特长的密钥进行操作。\n密码块链接 当对报文进行分块时，可能存在一些相同的密文块，容易被识别，为了解决这个问题，可以在密文中混合一些随机性，通过产生随机的异或数即可解决。\n这样的话传输方必须多传输一倍的长度用于传输该随机异或数。因此产生了一种密码块链接（Cipher Block Chaining，CBC）的技术。即第一块使用随机的异或数，后面的每一块所异或的数为前一块的结果。\n2.公开密钥加密 公钥（public key）是公开的，接收方B知道私钥（private key）。\n步骤：发送方通过公开的公钥进行加密操作，接收方使用一个众所周知的解密算法，使用密钥进行解密。\n公钥密码体制不仅用于加密，也可以很方便的应用于鉴别和数字签名。\n由于公钥密码算法效率较低，一般用于会话密钥的建立，对称密钥密码体制被用于其它大多数情况下的加密。\nRSA 公钥私钥生成 1.选取两个大素数p,q\n2.计算n=pq、z=(p-1)(q-1)\n3.选取e，使得gcd(e,z)=1，e\u0026lt;n\n4.求取d ，ed mod z =1\n5.公钥（n,e）私钥（n,d）\n加密过程 对于一个比特组合，表示成十进制的正数m，m\u0026lt;n\n则对于m的加密值c为 c = m^e mod n ，使用公钥\n解密过程 对c进行解密：m = c^d mod n，使用私钥\n会话密钥 会话密钥（session key），即通过公开密钥加密对一个对称密钥进行加密，随后发送后双方获取该对称密钥，最后通过对称密钥密码体制对大量数据进行加密传输。\nRSA工作原理 TOPDOWN409\n7.3 报文完整性和数字签名 1. 密码散列函数 散列函数以m为输入，得到一个称为散列的定长字符串。checksum和CRC都满足这个定义。\n密码散列函数（cryptographic hash function）具有一种性质：找到任意两个不同的报文x和y使得H(x)和H(y)相等在计算上是不可能的。\nMD5 SHA-1 SHA-1输出160比特的报文摘要，但计算要比MD5慢一些，但实际安全性也没有达到设计目标，很快被SHA-2和SHA-3替代。\n2. 报文鉴别码 1.对报文m计算散列H(m)，比如利用SHA-1\n2.将H(m)附在m后面发送，形成扩展报文(m,H(m))\n3.接收方收到(m,h)后，如果计算H(m)=h，则正常。\n但这种方法只能检测报文是否受损，对实际的报文来源无法判断。\n因此需要通信双方共享一个鉴别密钥s\n1.发送方级联m+s，计算H(m+s)，形成拓展报文(m,H(m+s))，发送。 [这个H(m+s)被称为散列报文鉴别码HMAC（Message Authentication Code,MAC）]\n2.接收方接收(m,h)，计算H(m+s)，如果等于h则正常。\n3. 数字签名 数字签名（digital signature）应当是可以鉴别的、不可伪造的。\n采用公钥密码可以实现。签署方通过私钥进行加密，保障了数字签名不可伪造。\n核验方通过公钥进行核实。\n而一般不直接对报文进行签署，这样会带来极大的计算量，可以使用散列算法计算该报文的一个固定长度的数据”指纹“，表示为H(m)，再对散列函数进行签名操作。\n4.公钥认证 数字签名的一个重要应用就是公钥认证（public key certification），即证实一个公钥属于某个特定的实体。\n将公钥和特定实体进行绑定通常是由认证中心（certification Authority，CA）完成的。\n一旦验证，CA会生成一个将其身份和实体的公钥绑定起来的证书（certificate）\nTOPDOWN 415\n7.4 端点鉴别 1.基本概念 通信双方验证另一方身份的一种技术。\n最简单的方法就是使用用户名和口令。\n为了避免用户名和口令在传输过程中被截获，因此要对其进行加密。但也有漏洞，攻击者可以直接截获该加密报文，之后直接发送即可使接收方误判。（重放攻击，Replay Attack，或为playback attack），需要使用不重数nonce，即不重复使用的大随机数。\n不重数可以使用户把重复的实体鉴别请求和新的实体鉴别请求区分开来。\n双方各会发送一个不重数，并等待对方使用对称密钥进行加密操作，随后接收到对方的报文进行解密，获取不重数，若相等即可判定对方的身份。[能够正确加密解密的只有知道对称密钥的加密双方，并且也知道对方是活跃的]\n7.5 安全电子邮件 1.概述 需要保障机密性、完整性、以及对发送方、接收方的鉴别\n2.PGP PGP（Pretty Good Privacy）是电子邮件加密方案的一个范例，如TOPDOWN422图8-21\nPGP软件的不同版本使用MD5或SHA来计算报文摘要，使用CAST、三重DES或IDEA进行对称密钥加密，使用RSA进行公开密钥加密。\n7.6 TLS 传输层安全性（Transport Layer Security，TLS），使TCP连接安全。\n1.宏观描述 握手 创建TCP连接 三次握手\n验证端点真实性 一方发送TLS Hello报文，另一方回答证书，证书已由CA证实过\n发送主密钥MS 用于生成TLS会话所需要的对称密钥。\n该主密钥通过对方的公钥进行加密得到加密后的主密钥（EMS）并发送给对方。\n至此只有通信双方知道了该主密钥\n密钥导出 双方都使用MS产生四个密钥，TOPDOWN425.\n密钥导出阶段结束，双方都有了四个密钥，两个加密密钥用于数据加密 ，两个HMAC用于完整性鉴别\n数据传输 双方共享四个相同的会话密钥，能够进行TCP安全传输。\n2.TLS记录 由类型字段、版本字段、长度字段、数据字段和HMAC字段组成。\n7.7 IPSec和虚拟专用网 IP安全（IP Security）协议称为IPSec，为网络层提供了安全性。\n为任意两个网络层实体之间的IP数据报提供了安全。\n许多机构使用IPSec创建了运行在公共因特网上的虚拟专用网（Virtual Private Network，VPN）\n对于VPN，其中流量经过因特网之前进行加密。\n在IPSec协议族中，由两个主要协议：鉴别首部（Authentication Header，AH）协议和封装安全性载荷（Encapsulation Security Payload，ESP）协议。\n7.8 防火墙和入侵检测系统 防火墙（firewall）是一个硬件和软件的结合体，它将一个机构内部网络与整个因特网隔离开，允许一些数据分组通过而阻止另一些分组。\n防火墙具有三个目标：\n1.从外部到内部和从内部到外部的所有流量都通过防火墙\n2.仅被授权的流量（由本地安全策略定义）允许通过\n3.防火墙自身免于渗透\nCisco和Check Point使当今两个领先的 防火墙厂商。\n防火墙现在经常在路由器中实现并使用SDN进行远程控制\n防火墙分为三类：传统分组过滤器（traditional packet filter）、状态过滤器（stateful filter）和应用程序网关（application gateway）\nChapter8. 多媒体网络 8.1 音频 比特率=采样频率✖量化位数\n举例：\nCD: 1.411 Mbps\nMP3: 96, 128, 160 kbps\nInternet telephony: 5.3 kbps and up\n8.2 视频 CBR（constant bit rate）：视频编码固定速率\nVBR:(可变比特率):视频编码速率随空间、时间编码量的变化而变化\n例如：\nMPEG 1 (CD-ROM) 1.5 Mbps\nMPEG2 (DVD) 3-6 Mbps\nMPEG4 (often used in Internet, \u0026lt; 1 Mbps)\n8.3 多媒体网络 三种应用类型\n流媒体，存储音频、视频\nstreaming: can begin playout before downloading entire file\n流媒体:可以在下载整个文件之前开始播放\nstored (at server): can transmit faster than audio/video will be rendered (implies storing/buffering at client)\n存储(在服务器端):传输速度比音频/视频呈现速度快(意味着在客户端存储/缓冲)\n例如：YouTube，Netflix，Hulu\nIP会话语音/视频\n人与人之间对话的互动性限制了对延迟的容忍\n例如 Skype\n直播音频，视频\n1.流式存储视频 "},{"section":"Blog","slug":"/en/blog/reversible-steganography/","title":"【学习笔记】基于差值拓展的可逆隐写方法","description":"this is meta description","date":"September 12, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"学习笔记","tags":"信息安全","content":"【学习笔记】基于差值拓展的可逆隐写方法 一、步骤概览 加密 将图像划分为多个像素对$(x,y)$，其中$x,y \\in Z, 0 \\le x,y \\le 255$。 取像素对的均值$l$和差值$h$，具体如下。 $$ \\left \\{ \\begin{aligned} \u0026amp;l = floor(\\frac{x+y}{2}) \\\\ \u0026amp;h = x-y \\end{aligned} \\right. \\tag{1} $$\n对于待嵌入的秘密信息$m$，以差值拓展的方式进行嵌入，步骤为$h\u0026rsquo; = h \\times 2 + m$。 将得到的嵌入信息的差值$h\u0026rsquo;$通过(2)式进行计算，得到新的像素对$(x\u0026rsquo;,y\u0026rsquo;)$。 $$ \\left \\{ \\begin{aligned} \u0026amp;x\u0026rsquo;=l+floor(\\frac{h\u0026rsquo;+1}{2}) \\\\ \u0026amp;y\u0026rsquo;=l-floor(\\frac{h\u0026rsquo;}{2}) \\end{aligned} \\right. $$\n增加限制条件，保证数据不会溢出，可描述为以下条件。 $$ |2\\times h + m| \\le min(2\\times(255-l), 2\\times l+1) $$\n解密 对于加密后的像素对$(x\u0026rsquo;,y\u0026rsquo;)$，根据(1)式计算差值$h\u0026rsquo;$和均值$l\u0026rsquo;$。 对于得到的差值$h’$取LSB，即为密文$m$。 计算$floor(\\frac{h\u0026rsquo;}{2})$即为原有的差值$h$。 通过均值$l\u0026rsquo;$（这个值与原有均值一致）和还原出来的原有差值$h$，通过式(2)计算像素对$(x,y)$，即为原有的像素对。 二、例子 加密 选取图像像素对(126, 96)，则为$x=126, y=96$。 计算差值和均值 $$ \\left \\{ \\begin{aligned} \u0026amp;l = floor(\\frac{x+y}{2}) =floor(\\frac{126+96}{2})=111\\ \u0026amp;h = x-y = 126-96 = 30 \\end{aligned} \\right. \\tag{1} $$\n差值30的二进制表示为11110。 假设嵌入秘密信息$m=1$，将1加入到LSB上，即执行$h\u0026rsquo; = h \\times 2 + m$，结果为111101，十进制即为61。 将$h\u0026rsquo;=61$代入到(2)，得到加密后的像素对为$(142,81)$。 $$ \\left \\{ \\begin{aligned} \u0026amp;x\u0026rsquo;=l+floor(\\frac{h\u0026rsquo;+1}{2}) = 111+floor(\\frac{61+1}{2}) = 142\\\\ \u0026amp;y\u0026rsquo;=l-floor(\\frac{h\u0026rsquo;}{2}) = 111-floor(\\frac{61}{2})=81 \\end{aligned} \\right. $$\n解密 已知$(x\u0026rsquo;,y\u0026rsquo;)=(142,81)$。 计算$l\u0026rsquo;$和$h\u0026rsquo;$，过程如下： $$ \\left \\{ \\begin{aligned} \u0026amp;l\u0026rsquo; = floor(\\frac{x\u0026rsquo;+y\u0026rsquo;}{2}) =floor(\\frac{142+81}{2})=111\\ \u0026amp;h\u0026rsquo; = x\u0026rsquo;-y\u0026rsquo; = 142-81 = 61 \\end{aligned} \\right. \\tag{1} $$\n取密文$m=LSB(h\u0026rsquo;)=LSB(111101)=1$。 计算原有差值$h=floor(\\frac{h\u0026rsquo;}{2})=floor(\\frac{61}{2})=30$。 得到原有像素对，过程如下，最后还原出原有的像素对$(126,96)$。 $$ \\left \\{ \\begin{aligned} \u0026amp;x=l\u0026rsquo;+floor(\\frac{h+1}{2})=111+15=126 \\\\ \u0026amp;y=l\u0026rsquo;-floor(\\frac{h}{2}) = 111-15 = 96 \\end{aligned} \\right. $$\n三、代码 主要实现式子（1）和式子（2）。\n对于式子（2），通过均值和差值计算对应的像素对，函数如下。\ndef convHL(h, l): if h \u0026gt;= 0: x = l + int((h + 1) / 2) y = l - int(h / 2) else: x = l + int(h / 2) y = l - int((h - 1) / 2) return x, y 对于嵌入过程，函数如下：\ndef embed_msg(img, msg): ori_img = img.copy() H, W = img.shape[:2] img_data = img.reshape(-1) loc_1 = [] loc_2 = [] lsb_2 = {} len_msg = len(msg) for i in range(len_msg): # 取像素对，相邻两个即可 x = img_data[2 * i] * 1.0 y = img_data[2 * i + 1] * 1.0 # 计算均值和差值 h = x - y l = int((x + y) / 2) # 正常情况下可进行差值拓展后的结果 hs_1 = 2 * h + msg[i] # 若不可拓展则考虑直接覆盖LSB，则需要记录原有的LSB了 hs_2 = 2 * int(h / 2) + msg[i] # 优先拓展 if abs(hs_1) \u0026lt;= min(2 * (255 - l), 2 * l + 1): # 均值一直不变，使用拓展后的差值计算对应的像素对 xs, ys = convHL(hs_1, l) loc_1.append(2 * i) elif abs(hs_2) \u0026lt;= min(2 * (255 - l), 2 * l + 1): xs, ys = convHL(hs_2, l) loc_2.append(2 * i) lsb_2[2 * i] = int(h) % 2 # 原来的LSB内容 else: print(\u0026#34;no_type\u0026#34;) img_data[2 * i] = xs img_data[2 * i + 1] = ys new_img = img_data.reshape(H, W) return loc_1, loc_2, lsb_2, new_img, ori_img 对于解密过程，函数如下：\ndef extractMsg(loc_1, loc_2, lsb_2, img_emd): H, W = img_emd.shape[:2] img_data = img_emd.copy().reshape(-1) n = len(loc_1 + loc_2) p_ext = [] for i in range(n): loc = 2 * i xs = img_data[2 * i] * 1.0 ys = img_data[2 * i + 1] * 1.0 hs = xs - ys # 均值不变 ls = int((xs + ys) / 2) # 取出的信息 b = int(hs % 2) # 属于可扩展情况 if loc in loc_1: # 恢复真正差值 hs = (hs - b) / 2 x, y = convHL(hs, ls) # 属于可改变，强行改变了LSB的情况 elif loc in loc_2: # 恢复真正差值 hs = (hs - b) + lsb_2[loc] x, y = convHL(hs, ls) p_ext.append(b) img_data[2 * i] = x img_data[2 * i + 1] = y res = img_data.reshape(H, W) return p_ext, res "},{"section":"Blog","slug":"/en/blog/java/","title":"【课程笔记】Java程序设计","description":"this is meta description","date":"September 12, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"Java程序设计","content":"1.Introductory Java Language Features（Java语言特性介绍） Packages And Classes（包和类）P66 1.一个Java程序包含一个及以上的类。\n2.一个Java应用程序只能包含一个主类（含有main函数的程序入口类），这个主类只能包含一个主方法。\n3.包含编写的代码的Java文件被称为源文件，编译器将源代码编译为机器可读的字节码文件。\nTypes And Identifiers（数据类型和标识符）P68 1.基本数据类型（built-in types或者primitive types）有8个，分别为int,long,float,double,boolean,byte,short,char。\n2.数值型存储容量P69。从byte到long分别为1、2、4、8字节。\n3.数据类型的转换P69。将double转换为int类型需要进行显式转换（explicit），否则会引起编译错误，int到double多为自动转换。\n4.浮点数相关机制P70。NaN出现情况为0/0，非0数除0会造成inf。\n5.常量的初始化可以不在定义时进行P71Note2。\nOperator（运算符）P71 1.双目运算符两端有double出现，则会自动将int转换为double。\n2.浮点取模结果也为余数。如4.2%2.0结果为0.2。\n3.关系运算符仅用于基本数据类型之间的比较，对于各种类，有compareTo方法进行，String类有equals。\nControl Structures（控制结构）P77 1.若没有大括号进行强行配对，else总是和跟其最近的未配对的if进行配对。例子见书本P78。\n2.增强for-each循环只能够进行元素的遍历，无法修改序列元素的值。\n2.Classes and Objects（类和对象） Objects（对象）P100 1.一个对象通过其状态（state或attributes）和行为（behavior）进行描述。\n2.将对象的数据和方法整合成类单元，即为封装（encapsulation）。\n3.用变量表示对象，该变量为对象引用（object reference），并不是对象本身，相当于一个地址指向了该对象。\n4.类是某种对象的蓝图。\nPublic，Private，and Static（公私有、静态）P101 1.静态变量，即类变量，被一个类的所有实例共享，内存分配仅发生一次。\nMethod（方法）P102 1.类中方法大致分为构造器（Constructer）、访问器（Accessors）、赋值修改方法（Mutators）。即常说的构造函数，get及set方法。\n2.构造器无返回类型，在实例化对象时，构造器返回的是对象实例的地址，供引用指向。\n3.静态方法（static method）只能调用静态成员。实例成员方法作用与对象实例，静态方法作用于整个类。只有当实例存在时，实例成员方法才能够被调用，而在实例化之前，其成员不存在，而此时静态方法存在。因此类静态方法在类存在时就已经存在并且能够被调用，但实例成员有不存在的可能性，故只能调用静态成员（类成员），即类方法早于实例方法存在，晚于实例方法消亡。\n4.main函数为何是静态的解释。P106\n5.主程序中的所有方法必须是静态的，对于主程序来说，没有对象的存在。\nMethod Overloading（方法重载）P107 1.定义：同一个类中的多个方法，其方法名相同，但参数类型列表（参数的数量、顺序、类型）不同。与返回类型无关。\n2.若方法标记（method\u0026rsquo;s signature）相同，则会产生重复定义方法的错误（duplicate method）。\nScope（调用范围）P107 1.类范围是类名后的{}，在其中直接通过类名或者方法名来调用。\n2.局部变量（local variable）在方法体内被定义，在方法结束调用后，对应的代码块删除，此时该部分局部变量被自动回收。\n3.局部变量和实例变量同名时，局部变量覆盖。若同名最好使用this关键字来指明该变量为实例变量。\nThe this Keyword（this关键字相关）P108 1.一个实例方法总是针对某个特定的对象调用的，这个对象成为该方法的一个隐性参数（implicit parameter），用this表示，因此所有的实例变量都可以加前缀this进行显示表示。P108（可结合python中的self进行理解）\nReference（引用）P109 1.未被初始化的变量对象（引用），也被称为空指针，尝试用空引用访问实例对象会抛出空指针异常（NullPointerException）。\n2.调用一个未被初始化的局部变量导致编译错误。调用一个未被初始化的实例变量，该实例变量获得默认的初值。\n3.Inheritance and Polymorphism（继承和多态） Method Overriding（方法重写）P143 1.继承意味着可访问。子类不能继承基类中的私有变量，但是在其内存空间中是包含了这个变量的，只是不能够直接访问，只能够通过基类的接口方法进行访问。\n2.在基类和子类中的方法如果具有相同的返回类型和标记（方法名与参数列表），则为方法重写（覆盖）。\n3.部分重写（partial overriding），在子类重写过程中依然通过super关键字调用了基类中的方法，同时子类中仍有对于该部分方法的补充，则为部分重写。\n4.私有方法无法被重写。\nConstructor and super（构造器和super关键字）P143 1.如果子类没有构造器，编译器自动生成子类构造器，第一行代码是super()表示调用超类无参数构造器。\n2.如果超类只有有参数构造器，没有无参构造器，则编译器报错。\n3.如果超类有无参构造器，被继承的变量用和超类一样的方式被初始化，子类中新定义的实例变量被默认初始化。\n4.如果super被用来执行基类的构造函数，那么它必须出现在子类构造器中的第一行。\nPolymorphism（多态）P146 1.方法的调用是由对象实例本身所决定的，而非指向该对象的引用的类型。\n2.静态绑定：对于同一个类中重载的方法，在编译时便根据其具体标记确定了调用哪一个方法，也称为early-binding。\n3.动态绑定：对于类间重写的方法，在运行时基类引用的指向发生改变，具体的调用根据其指向的对象实例类型决定，即late-binding。\n4.不同类的对象可以对相同的请求做出不同的相应方式，而该不同类的对象的集合则被成为异质类的集合（Heterogeneous Collection），集合中的对象不属于同一个类，但是其对应的类继承了同一个超类。\nDowncasting（向下转型）P149 1.“编译看左边，运行看右边”，引用变量调用的方法或变量需要在其所属的类中出现，否则会造成编译错误。\n2.可以通过向下转型的方法将基类引用转成子类引用，从而能够避免编译错误访问到子类特有的成员。\n3.向下转型时，应是从基类转向子类，若转换的类之间没有继承关系，则会抛出类型转换异常（ClassCastException）。\nAbstract Classes（抽象类）打印页 1.一个抽象类可能包含抽象方法。但是如果一个类中包含了抽象方法，那么这个类必须为抽象类。\n2.一个抽象类的子类需要重写该抽象类中的所有抽象方法。否则产生编译错误。\n3.一个抽象类可以拥有一系列实例变量或者方法（非抽象），如一个shape类可以拥有非抽象（concrete具体的）的Name变量。\n4.一个抽象类可以拥有构造方法，也可以没有构造方法。\n5.抽象类不能够进行对象的实例化。\n6.抽象类的引用可以指向其子类的对象，即多态模式在抽象类及其派生类中是适用的。\nInterfaces（接口）打印页 1.Java禁止多重继承，可以使用接口来缓解这一局限，接口可以多重实现。\n2.Java8中接口可以同时包含抽象方法和非抽象方法。\n3.一个非抽象类如果实现了某一个接口，那么该类必须重写接口中的所有抽象方法。\n4.在一个类的定义时，extends继承语句必须在接口implements语句之前。\n5.Comparable接口：其中包含了CompareTo方法，每一个实现该接口的类需要重写该方法，该方法的返回值定义了对于该类的比较规则，具体见打印页P146举例代码。\n6.一个类A实现了接口B，那么可以将B作为方法形参（和基类一样），因为A与B直线的实现关系也可以被称为“A是一个会B的对象”。\n7.打印页P147-P148的note较为重要。\n8.基本数据类型并没有被抽象成类，因此不能实现Comparable接口，但是可以使用包装类（wrapper class）来将其转变为可以实现接口的具体的类。\n9.接口中不能包含实例变量，但是抽象类中可以。接口可以包含常量。\n10.若基类实现了某个接口，则其派生类自动实现该接口。\n11.接口之间可以有继承关系，一个接口可以有子接口。\n4.Some Standard Classes（一些标准类） The object class（Object类）P167 1.每个类都自动继承了Object类。Object类是其他类的直接或者间接的超类。\n2.Object并不是抽象类，它包含toString方法和equals方法，但其默认实现代码可能不合理，可以在任何类中对其进行覆盖。\n3.对于toString方法，其默认形式是以“类名@内存地址”的字符串形式返回当前实例信息。\n4.数组对象没有toString方法。\n5.对于equals方法，其默认的比较方式与“==”一致，即比较是否是同一个对象（地址是否一致）。\n6.被判定为equal的对象一定有相同的哈希码,但是不能反过来说。\nThe String Class（String类）P169 1.对于+操作，如果两边都不是字符串，那么会报错，如果有一边是字符串，另一边不是，那么不是字符串的一边会自动调用toString方法将其转换为字符串，随后进行连接。\n2.对于同一个字符串常量，有不同的字符串引用指向它，其地址是一致的。P172。由于为了节省空间，提高效率，Java对相同的字符串常量仅生成一个字符串对象实例。但是如果是new出来一个一模一样的字符串，其地址值是不一致的。\nWrapper Classes（包装类）P175 1.包装类的大部分方法是静态方法，即类方法，通过类名直接调用。\n2.Integer和Double类的对象是不可变的，这就意味着这些类不存在修改方法。\n3.String和Integer之间的转换可以通过parseInt，toString方法实现，见书本P175手写代码部分。\n4.在使用运算符进行数据大小的比较时。如果是“==”，两边都是包装类的话，会比较地址，若存在一个基本数据类型，则另一个包装类会自动拆包，若为不等号，则无论是否存在基本数据类型，包装类都会优先进行自动拆包操作。\n5.对于char的包装类character，有一系列有用的方法。如下。\ntoUpperCase(); toLowerCase(); Char firstChar = ‘A’; Char secondChar=Character.toLowerCase(firstChar) isLetter(); isDigit(); isLowerCase(); isUpperCase(); isWhitespace();//空格 Character.isDigit(response); Character.isLowerCase(response); Character.isWhitespace(response); The Math Class（标准数学类）P176 1.Math类作为工具类，其中所有的方法都是静态的。\n5.Arrays and Array Lists（数组和ArrayList相关） One-Dimensional arrays（一维数组）P226 1.一个数组是一个对象，但特殊的是，它没有toString方法。\n2.对于一个数组引用，当它引向了另一个数组对象，那么根据Java的垃圾回收机制，为前一个数组分配的内存空间将被回收。\n3.当一个数组被确定声明后，会自动地将其中的元素赋值为默认值。\n4.通过大括号的形式生成数组实例，可以不用new进行。如int[] a={1,2,3};\n5.对于数组来说，length是一个公有的成员变量，它没有length方法，这与String类有所不同。\n6.对于类的引用数组来说，被声明后其值都是null的默认值，需要指定其指向具体的对象实例。\n7.对于引用数组，可以通过for-each语句对于其具体的指向的实例属性进行改变，只是for-each无法改变其地址值本身，但还是可以通过地址值改变到具体实例的内容。\n"},{"section":"Blog","slug":"/en/blog/python/","title":"【课程笔记】Python程序设计","description":"this is meta description","date":"September 12, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"课程笔记","tags":"Python程序设计","content":"1. Python语言介绍 1.1 基本概念 Python语言是一种解释型、面向对象、动态数据类型的高级程序设计语言。\n1.2 语言特点 优点： 1.优雅、简单、明确\n2.强大的标准库\n3.良好的可拓展性\n4.免费、开源\n缺点 1.运行速度慢\n2.加密难\n3.缩进规则\n4.多线程灾难\n1.3 异常 1.3.1 六种典型的异常 1.除零错误（ZeroDivisionError）：除数为0\n2.名称错误（NameError）：变量使用前未进行申明或者初始化\n3.类型错误（TypeError）：某些函数或者方法只适用于特定的数据类型，如果 对数据类型的操作不当，就会产生类型错误（如数值＋字符串操作）\n4.数值错误（ValueError）：在输入类型正确的情况下，具体输入值错误（如对字符串进行float操作）\n5.索引错误（IndexError）：超出序列长度的索引操作\n6.属性错误（AttributeError）：方法或者属性不适用该对象\n1.3.2 异常抛出 raise语句，类似java中的throw\n1.3.3 异常捕获 try: #正常代码 except(Exception1,Exception2),e: #异常发生时的处理代码 else: #正确时执行 finally: #无论对错都执行 x,y=map(int,input().split()) try: ans=x/y except ZeroDivisionError: print(\u0026#34;Error\u0026#34;) else: print(ans) #没有任何异常抛出并捕获时才执行这一语句块 finally: print(\u0026#34;TEST!\u0026#34;) 1.3.4 with语句 with open() as f: content = f.readlines() #等价于 f=open() content=f.readlines() f.close() 2. Python语法基础 2.1 Python数据类型 2.1.1 数值类型 1.长整型在整数后面带L（python3没有了）\n2.浮点科学计数法 1e9之类的\n3.复数：a+bj 或者 complex(a,b)\n2.1.2 字符串 1.切片 s[a:b]，取[a,b)的字符\n2.字符串格式化，与C的语法规则类似\nprint(\u0026#34;%s,%d\u0026#34;%(\u0026#39;Hellowrold\u0026#39;,123)) #format格式 print(\u0026#34;{},{}\u0026#34;.format(\u0026#39;hellworld\u0026#39;,123)) 3.空值None，与其他任何数据比较返回恒为False。未指定返回值的函数会返回None。\n4.join，s1.join(s2),s2为字符串列表，通过s1串将s2给串联起来，最后返回一个字符串。\n5.字符串中的数据（字符）是不可修改的。可以通过新的字符串进行整体赋值。\n6.find函数。s.find(s1,st,ed),从s[st,ed),中查找s1是否存在，不存在则返回-1。\n7.大小写修改。调用title函数进行首字母大写。upper与lower进行整体大小写转换。\n8.删去空格。rstrip与lstrip函数分别删除左右边的空格，strip删除两侧空格。\n9.替换。s1=s.replace(k1,k2)，将字符串s中的所有k1变成k2，返回改变后的串，原串不动。\n2.1.3 类型转换 1.eval(str)函数，计算str中有效表达式的结果并返回。\nans=eval(\u0026#34;1+2\u0026#34;) ans#结果为3 2.chr(x) ASCII转字符 ord(x) 字符转ASCII，汉字为Unicode\n3.bin(x)、oct(x)、hex(x) 分别为x转二、八、十六进制字符串，含前缀0b,0o,0x。\n4.exec函数：将字符串中的有效语句进行运行。\n2.2 变量与常量 1.同一个变量可以多次赋值，变量本身类型不固定，即为动态语言。\n2.变量类似指针，指向对象实例。\n3.当变量不再需要时，python会自动回收内存空间，也可以用del语句进行删除。\n2.3 运算符与表达式 1.数值0被视为False，非0数值被视为True。空字符串、空字典、空集合、空列表也被视作False。\n2.or为从左到右运算，返回第一个为真的值。0 or 3 or 0 or 4 结果为3。\n3.位运算。与C一致。\n4.成员运算符。 in和not in，判别某个成员是否在序列中。\n2.4 序列数据结构 2.4.1 列表 1.删除列表元素。\ndel list1[x] 即删除list1列表中索引为x的元素。\nlist1.remove(x) 即删除其中值为x的元素。\nlist1.pop(x) 和del一致，当参数为空pop列表尾部。\n2.索引取值。若为负数则从后边开始数，最后一个为-1，倒数第二个为-2，以此类推。\n3.切片步长为负时。表示逆向切片。\na=[2,3,5,7,11,13] b=a[-2:0:-1] #结果为[11,7,5,3] 从-2（包括）切到0（不包括） 4.a[::-1]返回翻转序列\n5.序列的复制\n直接=赋值相当于两个变量指向了同一个序列。若要重新生成一个一样的序列，可以采用[:]全切片后赋值。\n6.列表操作符。[1,2,3]+[4,5,6]结果为[1,2,3,4,5,6]; [1,2,3]*3结果为[1,2,3,1,2,3,1,2,3]\n7.排序。list1.sort()直接排序原列表，返回None；sorted(list1)，不排序原列表，返回排序后的列表。\n8.insert(tar,x)在指定的索引处插入x。\n2.4.2 元组 1.元组生成。括号，逗号隔开，若只有一个元素，也要加逗号，如tup=(1,)。\n2.元组不可修改，也不能用del删除个别元素。\n3.操作符与列表类似，如重复、元组连接。\n4.tuple(list)，将列表转化为元组。\n5.多变量赋值，x,y,z=1,2,3.\n2.4.3 字典 1.字典值可以是任何Python对象。大括号创建。\n2.不允许同一个键出现2次，后一个出现的会覆盖前一个。\n3.键必须不可变，因此不能用列表作为键，可以用数字、字符串、元组。\n4.删除。可以用del删除整个字典；clear函数将字典清空。del dict[x]或者dict.pop(x)，将某一个键为x的键值对删除。\n5.in操作，判断某一个键是否存在，与has_key函数作用相似，对value不适用。\n6.keys函数返回键列表，values返回值列表，items返回键值对元组列表。\n7.zip()函数。将两个列表(元组)进行组合，返回一个配对后的元组列表。键值互换：d1=dict(zip(d.values(),d.keys()))\n8.可直接通过中括号进行键查值，也可以用get函数，若键不存在get函数返回None，而中括号会报错。\n2.4.4 集合 1.通过大括号创建，与字典需区别。空集合需要用set()函数进行创建。直接{}创建的为空字典。\n2.集合为无序不重复的序列。\n3.-|\u0026amp;分别计算集合差集、并集、交集，^处理不同时存在于两集合中的元素。也可以用difference、union、intersection、symmetric_difference函数进行操作。\n4.add添加，remove删除，\n3.Python控制语句 3.1 列表生成式 1.基本格式: [f(x)for x in list_x if g(x)]，即遍历list_x，并将所有满足g(x)的元素x进行f(x)操作，生成一个新的列表。\nlist_x=list(range(30)) def f(x): return x*x def g(x): return x%2==0 new_list=[f(x) for x in list_x if g(x)] #相当于i为外层for，j为内层for [(i,j)for i in range(4) for j in range(3)] #相当于先进行左侧操作（i从0到2，每次j都从0到2） [[i+j for i in range(3)] for j in range(3)] 2.字典的生成式：{f for k,v in dict.items()}\n3.集合的生成式，和列表生成式一致。\n4.enumerate函数。在遍历列表时返回元素索引和元素值。\nfor i,j in enumerate([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;])： print i,j #0 a #1 b #2 c 4.数据文件的读写操作 4.1 打开文件 1.open函数打开，返回文件对象\n2.打开模式：第一个字母：r只读，w覆盖写，a追加；第二个字母：t文本类型，b二进制类型。\n4.2 文件读写 1.read(size)函数，读取长度为size的字符串，若未给定或者为负则读取所有内容。\n2.readline，读取整行，返回字符串。\n3.readlines，读取所有行并返回字符串列表，此时并没有将字符串后的换行符去掉，可以用strip函数去掉换行符。\n4.对于文件写操作，需要将打开文件的模式改为w\\a，通过write函数进行写操作。writelines将一个列表中的所有数据一次性写入。\n5.csv模块读写数据\npath=\u0026#39;X.csv\u0026#39; f=open(path,\u0026#39;r\u0026#39;)#以只读模式打开文件 reader=csv.reader(f)#生成reader对象 content=[] for con in reader: #for循环遍历reader content.append(con) #一次添加一行（条） f.close() f=open(path,\u0026#39;w\u0026#39;)#以只写模式打开文件 writer=csv.writer(f)#生成writer对象 for con in content: writer.writerow(con) #一次写入一行（条） f.close() 4.3 文件夹操作 1.os.getcwd()返回工作目录\n2.os.makedir(path)创建文件夹，其中path中有的文件夹都会被创建\n3.os.rmdir(path)删除文件夹，当且仅当目标文件夹为空。\n4.os.listdir(path)返回给出下的所有文件与文件夹名。\n5.os.path.dirname(path)返回路径名称，basename(path)返回目标文件名称，split(path)将路径和文件名分割返回元组。\n5.Python函数与模块 5.1 lambda表达式 f=lambda x,y,z:x+y+z #一般格式 print(f(1,2,3)) #将多个lambda表达式作为元素组成列表，即为转换表 F=[(lambda x:x**2),(lambda x:x**3),(lambda x:x**4)] print(F[0](1),F[1](2),F[2](3)) lambda表达式可以作为函数返回值。\n5.2 函数的定义与使用 1.参数传递：值传递。\ndef f1(x,K): #值传递，形参x,K指向原对象，即100与[1,1,1] x=2\t#改变形参的指向，不影响原对象内容 K=[2,3,4] return def f2(x,K): x=2 K[2]=3\t#改变了原对象中的某一个元素的指向，因此原对象会发生改变，同理在其中用append操作也会发生改变。 return n=100 K=[1,1,1] f1(n,K) print(n,K) f2(n,K) print(n,K) 2.参数设定：\n顺序传递：按照顺序\n关键字传递：按照关键字，可以不按照顺序，但是在混合使用时，需要保证关键字传递后面没有位置参数了。\nf(1,2,z=3,u=4)#正确 f(1,y=2,3,u=4)#错误 默认参数：必须放到参数列表的末尾。\n不定长参数：例如def f(*args)：最终传入的参数会被打包为元组进入函数体内。且在传入该部分时若用关键词传入则会出错。\ndef pf(x,*args): print(x) print(args) return k=[1,2,3] pf(1,*k) #手动拆包，print的结果为(1,2,3) pf(1,k) #print的结果为([1,2,3],) pf(1,*k,k) #结果为(1,2,3,[1,2,3]) 对于**，则会将多余的含有变量名的参数\ndef pf(x,**args): print(args) return pf(2,a=1,b=2,c=3) #结果为{\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} 混合使用时，要按照顺序进行，如\ndef pf(x,*k1,**k2): print(x) print(k1) print(k2) return pf(2,2,3,3,a=1,b=2,c=3)#此时k1为(2,2,3),k2为对应字典 #若pf(2,2,a=1,b=2,c=3,3,3)则会报错 5.3 all和any函数举例 all表示参数的列表中全为1时则返回1，反之返回0，any表示有一个1时结果则为1，反之为0\nall([1 if n%k!=0 else 0 for k in range(2,n)]) #该段代码进行素数判定，首先通过列表生成式，生成一个01序列，当序列为全1时，表示全部的k都满足n%k!=0，因此为素数。 5.4 sys模块-命令行参数 import sys print(sys.argv[0]) #程序的文件名 print(sys.argv[1]) #被乘数 print(sys.argv[2]) #乘数 print(int(sys.argv[1])*int(sys.argv[2])) #运行：mul.py 2 6 #结果: mul.py 2 6 12 6.字符编码问题处理 1.中文字符集：GB2312 扩充：GBK， 标准编码集：Unicode\n2.Python3有两种表示字符串的类型：bytes和str，str包含了unicode字符，使用encode函数可以将字符串转化为bytes，反之通过decode函数可以将bytes转化为unicode的str字符。\ns=\u0026#34;你好\u0026#34; print(type(s),s) s=s.encode() #可以传参，如\u0026#39;gbk\u0026#39;,\u0026#39;utf-8\u0026#39;等参数 print(type(s),s) s=s.decode() print(type(s),s) \u0026#39;\u0026#39;\u0026#39; 结果如下： \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 你好 \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; b\u0026#39;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\u0026#39; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 你好 \u0026#39;\u0026#39;\u0026#39; 3.sys.getdefaultencoding()函数可以获取python解释器的默认编码模式。\n4.chardet包中的detect函数可以实现对编码方法的一个估计。\n7.面向对象程序设计 7.1 类的名字空间 1.每个类有自己的名字空间，类名是空间名。\n2.每个对象也有自己的名字空间，其中包含一些对象实例属性名，但其类中不包含。\n3.存储在类名称空间中的名称是类的成员。\n4.instance.method()等价于class.method(instance)，其中class时instance的类型。\n5.可以通过isinstance来判断某个对象是不是某个类的实例。\n7.2 类的定义 7.2.1 成员函数相关（self） 1.对象本身作为成员函数的第一个参数进行传递，即self。\n2.类的成员函数必须包含一个参数self，且位于参数列表的第一位。\n3.在类的成员函数体中访问其它类成员时需要以self作为前缀。\n4.在类外通过对象访问成员时，不需要传递self。\n5.在类外通过类名调用成员函数时，需要显式为self的参数传递。\n7.2.2 构造函数与析构函数 class A: def __init__(self,sa,sb):#若构造函数中存在self以外的参数，那么在创建实例时需要传入具体的参数值。 self.a=sa self.b=sb def __del__(self): #析构函数 pass 7.2.3 实例属性与类属性 1.实例属性属于对象实例，是在构造函数中被定义的，定义时以self作为前缀，调用时只能通过对象进行调用。类属性是在方法之外被定义的，可以通过类或者实例对象进行调用，且被所有类对象实例所共享。\n2.python可以动态的为类和对象增加成员。见书本P122。\n7.2.4 公有、私有成员 class A: def __init__(self,sa,sb): self.a=sa\t#公有成员变量 self.__b=sb #私有成员变量 只能在类间调用，但可以通过：实例名._类名+私有成员名 的方法在类外进行访问。 def __Q1(): pass #属于私有的成员方法 def Q2(): pass #属于公有的成员方法 1.对于类的方法，可分为公有方法、私有方法、静态方法。具体示例见P125。\n2.静态方法可以通过类或者对象进行访问，但在方法体中只能访问属于类的类属性，而不能具体地访问到某一个对象的属性。\n7.3 类的继承和多态 7.3.1 类的继承 1.在继承中的基类的构造函数__init__()不会被直接调用，需要在派生类的构造函数中亲自专门调用。\n2.在派生类中调用基类方法的两种形式。“基类名.方法名(self,)”和super语句。\nclass A(object): def __init__(self,x): self.AX=x def showA(self): print(self.AX) class B(A): def __init__(self,x,y): A.__init__(self,x) #super(A,self).__init__(x) 也行 self.BY=y def showB(self): A.showA(self) #super(A,self).showA() #从派生类中调用基类成员的两种方法 3.python支持类的多继承。\n7.3.2 方法重写 1.当基类和派生类都存在相同的方法时，可以在派生类中对方法进行重写，即覆盖。这样通过派生类或者其对象实例访问该方法时，总能够访问到被覆盖后的方法。\n7.3.3 多态 1.举例：一方法以基类作为形参，则可将该基类的所有派生类对象作为实参，并顺利地进行调用。\n7.3.4 运算符重载 对于python来说，所有加减乘除的运算符（+,-\u0026hellip;）都有函数方法与之对应，见书本P131，需要重载运算符，则需要重写对应的函数方法即可。\ndef A: def __init__ (self,a): self.a=a def __add__(self,other): return ....#自定义的加法操作 8.命名空间和作用域 1.对于同名变量，若不声明global，则函数内的被认定为局部变量\nx=100 def f(): #global x y=x x=0 print(x) return f() print(x) 上述代码会报错，因为x为局部变量，在第一个语句y=x中，x并未被声明，加上对x的声明即可，这里通过global声明x为全局的。\n9.Tkinter图形界面设计 "},{"section":"Blog","slug":"/en/blog/geometricanalysis-hdu7205/","title":"【算法笔记】几何分析+巴纳赫不动点-HDU7205","description":"this is meta description","date":"August 14, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"计算几何, 几何证明","content":"链接：Problem - 7205 相当奇怪的解决方法，可能是一些常规解法的衍生品，比较容易理解。\n题意 给定两张不同尺寸的相同地图，小地图放在大地图上，请确定一个点坐标，该点在小地图和大地图上指代的是同一个地点。\n分析 考虑两个矩形对应边平行的情况\n易知所求点位于两个矩形的重心连线所在直线上，位置与缩放比有关。\n考虑两个矩形对应边不平行的情况\n令$AB$与$ab$交于$E$，$CD$与$cd$交于$F$，$AD$与$ad$交于$G$，$BC$与$bc$交于$H$，则$P$为$EF$与$GH$的交点。\n证明：\n假定线段$EF$上的任意一点$P$满足以下性质：过$P$分别做大矩形长边与小矩形长边的垂线，大矩形上垂足所处位置与小矩形上所处位置比例一致（相对位置一致）。\n即 $PH⊥BC,PI⊥bc$，则有： $$ \\frac{BH}{CH}=\\frac{bI}{cI} \\tag{1} $$ 即如下图所示。\n若以上假设成立，对于图（1）中$GH$直线同样有类似性质，即线上的点到对应边的投影点满足在大小矩形的边上的相对位置一致。\n因此对于直线$EF$与直线$GH$的交点$P$，满足了对于大小矩形长边上投影点的相对位置一致，也满足了在短边上投影点相对位置一致，即可确定该交点$P$即为所求点。\n目前需要证明原假定成立，即式子（1）成立。\n现证一组成立即可，即证$EF$上点的性质。\n取$EF$上任一点$P$，如图（2），在图（2）基础上过$P$点做两个矩形的长边的平行线，如图（3）。\n容易证明：$bI=KP,cI=JP,MP=BH,LP=CH$\n有$ΔEPK$与$ΔFPJ$相似，则$\\frac{KP}{JP}=\\frac{EP}{PF}$。\n有$ΔEPM$与$ΔFPL$相似，则$\\frac{MP}{PL}=\\frac{EP}{FP}$。\n则$\\frac{KP}{JP}=\\frac{MP}{PL}$， 故$\\frac{bI}{cI}=\\frac{BH}{CH}$。\n即原假设得证。\n故原操作方法合理性得证。\n奇怪的思路及其容易，很好理解。\n其实就是巴纳赫不动点。可以自行了解。\nAC代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const double pi=acos(-1.0); const double eps=1e-8; int sgn(double x) { if(fabs(x)\u0026lt;eps) return 0; else return x\u0026lt;0?-1:1; } int Dcmp(double x,double y) { if(fabs(x-y)\u0026lt;eps) return 0; else return x\u0026lt;y?-1:1; } struct Point { double x,y; Point() {} Point(double x,double y):x(x),y(y) {} Point operator +(Point B) { return Point(x+B.x,y+B.y); } Point operator -(Point B) { return Point(x-B.x,y-B.y); } Point operator *(double k) { return Point(x*k,y*k); } Point operator /(double k) { return Point(x/k,y/k); } }; typedef Point Vector; double Cross(Vector A,Vector B) { return A.x*B.y-A.y*B.x; } struct Line { Point p1,p2; Line() {} Line(Point p1,Point p2):p1(p1),p2(p2) {} }; Point Cross_point(Point a,Point b,Point c,Point d) { double s1=Cross(b-a,c-a); double s2=Cross(b-a,d-a); return Point(c.x*s2-d.x*s1,c.y*s2-d.y*s1)/(s2-s1); } bool Line_px(Line v1,Line v2) { if(sgn(Cross(v1.p2-v1.p1,v2.p2-v2.p1))==0) { return 1; } else { return 0; } } double Distance(Point A,Point B) { return hypot(A.x-B.x,A.y-B.y); } void solve() { Point A1,A2,A3,A4,B1,B2,B3,B4; scanf(\u0026#34;%lf%lf\u0026#34;,\u0026amp;A1.x,\u0026amp;A1.y); scanf(\u0026#34;%lf%lf\u0026#34;,\u0026amp;A2.x,\u0026amp;A2.y); scanf(\u0026#34;%lf%lf\u0026#34;,\u0026amp;A3.x,\u0026amp;A3.y); scanf(\u0026#34;%lf%lf\u0026#34;,\u0026amp;A4.x,\u0026amp;A4.y); scanf(\u0026#34;%lf%lf\u0026#34;,\u0026amp;B1.x,\u0026amp;B1.y); scanf(\u0026#34;%lf%lf\u0026#34;,\u0026amp;B2.x,\u0026amp;B2.y); scanf(\u0026#34;%lf%lf\u0026#34;,\u0026amp;B3.x,\u0026amp;B3.y); scanf(\u0026#34;%lf%lf\u0026#34;,\u0026amp;B4.x,\u0026amp;B4.y); if(Line_px(Line(A1,A4),Line(B1,B4))) { //特判平行情况 //两个矩形的重心 Point m1((A1.x+A4.x)/2,(A1.y+A4.y)/2); Point m2((B1.x+B4.x)/2,(B1.y+B4.y)/2); if(Dcmp(m1.x,m2.x)==0\u0026amp;\u0026amp;Dcmp(m1.y,m2.y)==0) { printf(\u0026#34;%.6f %.6f\\n\u0026#34;,m1.x,m1.y); } else { double k=Distance(A1,A2)/Distance(B1,B2); //缩放比 double ansx=(k*m2.x-m1.x)/(k-1); double ansy=(k*m2.y-m1.y)/(k-1); printf(\u0026#34;%.6f %.6f\\n\u0026#34;,ansx,ansy); } } else { Point ans1=Cross_point(A1,A4,B1,B4); Point ans2=Cross_point(A2,A3,B2,B3); Point ans3=Cross_point(A1,A2,B1,B2); Point ans4=Cross_point(A3,A4,B3,B4); Point ans=Cross_point(ans1,ans2,ans3,ans4); printf(\u0026#34;%.6f %.6f\\n\u0026#34;,ans.x ,ans.y); } return; } int main() { //freopen(\u0026#34;t.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); int t;scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); while(t--) solve(); } "},{"section":"Blog","slug":"/en/blog/differenceconstraint-hdu7176/","title":"【算法笔记】差分约束分析+SPFA-HDU7176","description":"this is meta description","date":"July 28, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"差分约束, 最短路","content":"链接：Problem - 7176 题意 给定$n$个魔法塔和一个作用半径$k$，所有魔法塔的初始魔法值为0，同时给定每个魔法塔的目标魔法值，需完成若干次操作使得每个魔法塔的魔法值大于等于目标魔法值。一次操作选择一个魔法塔注入1点魔法成分，以该魔法塔为中心的作用半径内的所有塔的魔法值加1(若半径$k=1$，选定魔法塔2，则塔1、2、3的魔法值加一)，同时给定$q$组约束条件，每组约束条件中给定一个区间$[L,R]$和区间和$B$，要求该区间内的魔法塔的魔法成分不得大于$B$。求最少操作次数，若无法实现则输出-1\n（Tips:需注意魔法值与魔法成分的区别。）\n简言之：约束若干个区间内的操作次数，每次操作收益总数为以操作目标为中心的$2\\times k-1$个操作点，求给定收益目标下的最小操作次数。\n分析 分析一个样例\n5 2\n2 2 0 10 3\n1\n2 3 0\n结果为12：约束条件要求不能在区间$[2,3]$上进行操作，则可在点1进行两次操作，由于$k=2$，则点1、2的收益达到目标，随后在点4或者点5上进行10次操作，使得点4达到收益目标10，总共产生操作次数为12，且无法找到更小的可能操作次数。\n由于$q$组约束是对于某个区间内操作次数的限制，且目标收益给定了每个点的半径$k$范围内的最小操作总数和，且有操作数大于等于$0$等信息，能够罗列出若干不等式，故可考虑进行差分约束模型的建立。\n那么以什么作为建图的节点呢？\n考虑到我们所求的值为区间$[1,n]$的总操作数，且给出的约束条件都与区间操作数有关。故可设$s$为对于所有操作点的操作数的前缀和数组的元素。有前缀和数组才能更便捷地表示出区间操作数。\n则有三个约束条件：\n操作数大于等于0 区间i操作总数小于等于$B_i$ 某点i的半径内的操作总数大于等于$p_i$。 故可写出差分约束不等式，其中$U_i$表示以$i$为中心的半径内的操作总数。\n$$ \\left \\{ \\begin{aligned} \u0026amp;a[i]=s[i]-s[i-1]\\ge0 \\\\ \u0026amp;U_i = s[i+k-1]-s[i-k+1-1]\\ge p_i \\\\ \u0026amp;s[R_i]-s[L_i-1]\\le B_i \\end{aligned} \\right. $$\n化简至标准形式。\n$$ \\left \\{ \\begin{aligned} \u0026amp;s[i-1]-s[i]\\le0 \\\\ \u0026amp;s[max(0,i-k)]-s[min(i+k-1,n)] \\le p_i \\\\ \u0026amp;s[R_i]-s[L_i-1]\\le B_i \\end{aligned} \\right. $$\n根据差分约束模型，形如$v-u\\le p$的式子可视作从$u$到$v$的有向边，边权为$p$，最后所求值为$s[n]-s[0]$的可能最小值$M$，即为区间$[1,n]$的总操作数，而考虑到节点0本没有实际含义，且$s[n]-s[0]$满足式子$s[n]-s[0]\\ge M$,化为标准形式则为$s[0]-s[n]\\le -M$，显而易见需要求以$n$为起点到节点$0$的最小路径，该值的相反数则为所求答案。\n而什么时候不会出现答案呢？即所给定的约束条件无法正确的约束出所需要的最短路径，换言之有负环存在，使得能够无止尽的进行松弛，约束条件失去其有效性。故可用SPFA在求以节点$n$为源点的单源最短路径的同时记录每个节点被访问的次数，若次数超过$n+1$（考虑到虚节点0）,则可判定产生负环，约束条件无效，无正确答案产生。\n解题过程 初始化 采用前向星存图，忘了初始化head数组和cnt值导致一遍遍莫名其妙的WA。\n建图 读入每个节点的目标能量值\n$min(i+k-1,n)$至$max(0,i-k)$，权值为$-P_i$； $i$至$i-1$，权值为$0$； $L-1$至$R$，权值为$B$。 跑图找最短路和负环 最老套的SPFA判负环模板就可以了，运行时间约为700ms,标程采用了手写双端队列，运行时间约为300ms。\n判断结果 若产生负环，则直接输出-1，若没有负环产生，则输出$dis[0]$的相反数即可，即为$s[n]-s[0]$，差分一下就是区间$[1,n]$的最小操作数。\nAC代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=100005; struct Edge { int to,next,w; } edge[6*N]; //开大不超就行，考虑到边多 int cnt,head[N],neg[N],inq[N]; int n,k,tmp,q,L,R,B; void init() { cnt=0; for(int i=0;i\u0026lt;=n+3;i++) { head[i]=-1; } } ll dis[N]; void addedge(int u,int v,int w) { edge[cnt].w=w; edge[cnt].to=v; edge[cnt].next=head[u]; head[u]=cnt; cnt++; return; } bool spfa(int s) { for(int i=0;i\u0026lt;=n;i++) { dis[i]=1e18; inq[i]=neg[i]=0; } inq[s]=1; neg[s]=1; dis[s]=0; queue\u0026lt;int\u0026gt; q; q.push(s); while(!q.empty()) { int u=q.front();q.pop();inq[u]=0; for(int i=head[u];~i;i=edge[i].next) { int v=edge[i].to,w=edge[i].w; if(dis[u]+w\u0026lt;dis[v]) { dis[v]=dis[u]+w; if(!inq[v]) { inq[v]=1; q.push(v); neg[v]++; if(neg[v]\u0026gt;n+1) return 0; } } } } return 1; } void solve() { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); init(); for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;tmp); int u,v; //u-v\u0026gt;=p v-u\u0026lt;=-p u=min(n,i+k-1); v=max(0,i-k); addedge(u,v,-1*tmp); u=i; v=i-1; addedge(u,v,0); } scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); while(q--) { scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;L,\u0026amp;R,\u0026amp;B); addedge(L-1,R,B); }\tif(spfa(n)) { printf(\u0026#34;%lld\\n\u0026#34;,-1*dis[0]); } else { printf(\u0026#34;-1\\n\u0026#34;); } return ; } int main() { //freopen(\u0026#34;t.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); while(t--) { solve(); } } "},{"section":"Blog","slug":"/en/blog/dijkstra-poj1860/","title":"【算法笔记】正环判断+Dijkstra-POJ1860","description":"this is meta description","date":"July 28, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"最短路, 正环判断","content":"上链接：1860 \u0026ndash; Currency Exchange 大部分题解都是Bellmean_Ford和SPFA，最近在练Dijkstra的板，就放在这道题上写一写叭。\n题意 给定$n$种货币，且存在$m$种交易方式，对于每一种交易方式，有税率与佣金等参数。例如现存在一种交易方式:从货币A到货币B，原有货币A的数量为$S_a$,税率为$rate$,佣金为$dec$，则可得货币B的数量为$S_b=(S_a-dec)*rate$。问经过交易能否使原有货币价格升高。\n分析 由于允许的货币交易次数是无限的，故不能将视野局限于某几次交易能否使手中资本得到升高，而是去判断是否存在一种交易圈能够使得手中的资金不断升高。\n对于这些货币以及货币间的交易方式，可以抽象成图的节点和边，每一条边连接两个节点，且存在税率与佣金等参数。那么要寻找到能使手中资金不断升高的交易圈，即在当前图中找到一个最大正环。这个概念其实是就和学习最短路算法时所提到的负圈判断一模一样，即在完成目前可进行的松弛操作（本题中是找到更长路）后，仍存在一些边（交易方式），使得手中资金仍然能够产生更大的价值。\n解题过程 存图 采用邻接表存图（真的感觉邻接表好好用，但是这一题数据量小到用邻接矩阵就可以存下？）注意本题实际上是给出一个有向图。\n优先队列+Dijkstra 定义节点结构体，记录节点编号以及当前节点下能获得的最大货币价值，重载运算符使得优先队列优先弹出当前最大价值节点。（题板，不做赘述）\n检查正环 检查所有边，若存在一条边使得经过这条边的交易方式后货币价值仍能够提高，则返回真，输出YES，反之即输出NO。\nAC代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; typedef long long int ll; const int INF=0x3f3f3f3f; const int N=500; struct edge { int u,v; double rate,dec; edge(int a,int b,double c,double d) { u=a;v=b;rate=c;dec=d; } }; vector\u0026lt;edge\u0026gt; G[N];//邻接表存图 struct s_node { int id; double val; s_node(int a,double b) { id=a;val=b; } //重载运算符 bool operator\u0026lt;(const s_node \u0026amp;a) const { return val\u0026lt;a.val; } }; int n,m,s; double V; bool dijkstra() { double dis[N];//记录所有点到起点能够产生的最大价值 bool vis[N]; for(int i=1;i\u0026lt;=n;i++) { //与最短路相反，初始化定义为0，即当前无价值 dis[i]=0; vis[i]=false; } //对于起点，本存在有价值V dis[s]=V; priority_queue\u0026lt;s_node\u0026gt; q; q.push(s_node(s,dis[s])); while(!q.empty()) { //优先弹出目前已产生价值中有最大价值的节点 s_node u=q.top(); q.pop(); if(vis[u.id]) continue; vis[u.id]=true; //检查从该节点出发的所有交易方式 for(int i=0;i\u0026lt;G[u.id].size();i++) { //交易方式y edge y=G[u.id][i]; if(vis[y.v]) continue; //通过y的交易之后若得到更大价值，则拓展新邻居 if(dis[y.v]\u0026lt;(u.val-y.dec)*y.rate) { dis[y.v]=(u.val-y.dec)*y.rate; q.push(s_node(y.v,dis[y.v])); } } } //非常暴力地查每一条边，但应该只是看起来暴力，毕竟边数不变。 for(int i=1;i\u0026lt;=n;i++) { for(int j=0;j\u0026lt;G[i].size();j++) { edge x=G[i][j]; //若仍存在一种交易方式x，能够扩大价值，则返回true. if((dis[x.u]-x.dec)*x.rate\u0026gt;dis[x.v]) return true; } } return false; } void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s\u0026gt;\u0026gt;V; for(int i=1;i\u0026lt;=m;i++) { int u,v;cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; double x,y;cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[u].push_back(edge(u,v,x,y)); cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[v].push_back(edge(v,u,x,y)); } if(dijkstra()) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; } } int main() { //#define mytest #ifdef mytest freopen(\u0026#34;test.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;test.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #endif solve(); return 0; } "},{"section":"Blog","slug":"/en/blog/fastmatpow-poj3070/","title":"【算法笔记】矩阵快速幂数列递推-POJ3070&amp;HDU3117","description":"this is meta description","date":"April 19, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"矩阵快速幂, 数学推导","content":"矩阵快速幂 给定一个$m\\times m$的矩阵$A$，定义一个结构体以实现矩阵，同时重载矩阵的乘法操作。注意有时需进行取模操作。\nconst int N=2;//矩阵(方阵)大小 struct Matrix { ll m[N][N]; Matrix() { memset(m,0,sizeof m); } Matrix operator*(Matrix \u0026amp;a) { Matrix ans; memset(ans.m,0,sizeof(ans.m)); for(int i=0;i\u0026lt;N;i++) { for(int j=0;j\u0026lt;N;j++) { for(int k=0;k\u0026lt;N;k++) { ans.m[i][j]+=(m[i][k]*a.m[k][j])%p; ans.m[i][j]%=p; } } } return ans; } }; 对于矩阵的快速幂操作，即在幂$n$很大的时候求$A^n$，前面已经重载了矩阵的乘法运算符，那么快速幂操作便和普通变量的快速幂操作极为相似。需注意初始化矩阵变量为单位矩阵。\nMatrix fp(Matrix a,ll n) { Matrix res; for(int i=0;i\u0026lt;N;i++) { res.m[i][i]=1; } while(n) { if(n\u0026amp;1) res=res*a; a=a*a; n\u0026gt;\u0026gt;=1; } return res; } 矩阵在数列递推中的应用 如例题POJ3070：3070 \u0026ndash; Fibonacci 题干中也详细给出了Fibonacci数列的矩阵递推式：\n$$ \\begin{bmatrix} F_{n+1} \u0026amp; F_n \\\\ F_n \u0026amp; F_{n-1} \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} ^{n} $$\n称矩阵Base为转移矩阵，如下：\n$$ Base= \\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix} $$\n从递推式中即可看出，该式子能够将求数列的第n项转化为求转移矩阵的n次幂。\n不仅是Fibonacci数列，任何有递推式的数列皆可尝试找到转移矩阵，从而将问题转化为矩阵的幂，以降低时间复杂度。\n举例，不做分析，有以下数列\n$$ f(x)=\\left\\{ \\begin{aligned} \u0026amp;0 \\quad ,x=0\\\\ \u0026amp;1 \\quad ,x=1\\\\ \u0026amp;2 \\quad ,x=2\\\\ \u0026amp;3 \\quad ,x=3\\\\ \u0026amp;f(x-1)+f(x-3) \\quad ,x\u0026gt;3\\\\ \\end{aligned} \\right . $$\n递推式为$f(x)=f(x-1)+f(x-3)$，可以写成以下矩阵转移式子：\n$$ \\begin{bmatrix} f(x-1) \u0026amp; f(x-2) \u0026amp; f(x-3) \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix}=\\begin{bmatrix} f(x) \u0026amp; f(x-1) \u0026amp; f(x-2) \\end{bmatrix} $$\n则可以写成矩阵通项表达式：\n$$ \\begin{bmatrix} f(x) \u0026amp; f(x-1) \u0026amp; f(x-2) \\end{bmatrix}=\\begin{bmatrix} 3 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} ^{x-3}, x\\ge 4 $$\nPOJ3070 AC代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;climits\u0026gt; #define pb(x) push_back(x) #define mk(x,y) make_pair(x,y) #define pii pair\u0026lt;int,int\u0026gt; #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; typedef long long int ll; typedef unsigned long long int ull; const int INF=0x3f3f3f3f; const int N=2; const int p=10000; struct Matrix { ll m[N][N]; Matrix() { memset(m,0,sizeof m); } Matrix operator*(Matrix \u0026amp;a) { Matrix ans; for(int i=0;i\u0026lt;N;i++) { for(int j=0;j\u0026lt;N;j++) { for(int k=0;k\u0026lt;N;k++) { ans.m[i][j]+=(m[i][k]*a.m[k][j])%p; ans.m[i][j]%=p; } } } return ans; } }; Matrix fp(Matrix a,ll n) { Matrix res; for(int i=0;i\u0026lt;N;i++) { res.m[i][i]=1; } while(n) { if(n\u0026amp;1) res=res*a; a=a*a; n\u0026gt;\u0026gt;=1; } return res; } void solve() { Matrix base; base.m[0][0]=base.m[0][1]=base.m[1][0]=1; ll n; while(cin\u0026gt;\u0026gt;n\u0026amp;\u0026amp;n!=-1) { Matrix ans=fp(base,n); ans.m[0][1]%=p; printf(\u0026#34;%d\\n\u0026#34;,ans.m[0][1]); } } int main() { solve(); return 0; } 例题HDU3117:Problem - 3117\n本题中数列长度也到了$10^{8}$的数量级，故考虑进行矩阵加速。\n题中说明，对于结果位数大于8位的数，仅输出前四位与后四位。\n稍打表可知，当n\u0026gt;=40时，结果位数大于八位，故可在n\u0026lt;40时打表输出，之后的采用矩阵加速求解\n对于后四位，可在递推求数的过程中不断对10000进行取模，需注意这里要补齐前导零至四位\n而对于前四位，似乎就没有那么容易求得了。\n这里采用一些玄学的数学方法。\n对于任何一个大数x,都可写成科学计数法，即$x=a\\times 10 ^{b}$，两边同取对数，则有$log_{10}x=log_{10}(a\\times 10 ^b)$，举个具体的例子，即$log_{10}1234567=log_{10}(1.234567\\times 10^6)=log_{10}(1.234567)+6$，其中6可以看作为$log_{10}1234567$的整数部分。\n可设$log_{10}1.234567=t$，则$1.234567=10^t$。\n对于1234567的前四位，即可表达为$\\lfloor 10^{t+3} \\rfloor$。\n那么对于Fibonacci数列，有通项公式$F_n=\\frac{1}{\\sqrt{5}}[(\\frac{1+\\sqrt{5}}{2})^n-(\\frac{1-\\sqrt{5}}{2})^n]$，稍作化简就可以表达出$log_{10}F_n$的值，在这里不做赘述，即为$log_{10}F_n=log_{10}\\frac{1}{\\sqrt{5}}+n\\times log_{10}\\frac{1+\\sqrt{5}}{2}$，对于$log_{10}F_n$的值，减去其整数部分，剩余部分加3后作为10的幂求得结果，最后向下取整即可得到$F_n$的前四位值。\n代码如下：\nint head(ll n){ double t=-0.5*log10(5.0)+(double)n*log10((1+pow(5.0,0.5))/2); t=t-floor(t); double x=pow(10,t+3); return (ll)floor(x); } HDU3117AC代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define pb(x) push_back(x) #define mk(x,y) make_pair(x,y) #define pii pair\u0026lt;int,int\u0026gt; #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; typedef long long int ll; typedef unsigned long long int ull; const int INF=0x3f3f3f3f; const int N=2; const int p=10000; struct Matrix { ll m[N][N]; Matrix() { memset(m,0,sizeof m); } Matrix operator*(Matrix \u0026amp;a) { Matrix ans; memset(ans.m,0,sizeof(ans.m)); for(int i=0;i\u0026lt;N;i++) { for(int j=0;j\u0026lt;N;j++) { for(int k=0;k\u0026lt;N;k++) { ans.m[i][j]+=(m[i][k]*a.m[k][j])%p; ans.m[i][j]%=p; } } } return ans; } }; Matrix fp(Matrix a,ll n) { Matrix res; for(int i=0;i\u0026lt;N;i++) { res.m[i][i]=1; } while(n) { if(n\u0026amp;1) res=res*a; a=a*a; n\u0026gt;\u0026gt;=1; } return res; } ll u[50]; void init() { u[0]=0; u[1]=u[2]=1; for(int i=3;i\u0026lt;40;i++) { u[i]=u[i-1]+u[i-2]; } return; } int head(ll n){ double t=-0.5*log10(5.0)+(double)n*log10((1+pow(5.0,0.5))/2); t=t-floor(t); double x=pow(10,t+3); return (ll)floor(x); } void solve() { init(); ll n; Matrix base; base.m[0][0]=base.m[0][1]=base.m[1][0]=1; while(cin\u0026gt;\u0026gt;n) { if(n\u0026lt;40) { cout\u0026lt;\u0026lt;u[n]\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;head(n)\u0026lt;\u0026lt;\u0026#34;...\u0026#34;; Matrix ans=fp(base,n); printf(\u0026#34;%04d\\n\u0026#34;,ans.m[0][1]%p); } } } int main() { solve(); return 0; } "},{"section":"Blog","slug":"/en/blog/exgcd-poj1061/","title":"【算法笔记】拓展欧几里得-POJ1061","description":"this is meta description","date":"April 14, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"数论, 拓展欧几里得","content":"题意 两只青蛙在循环坐标轴上朝着同一方向跳跃，其中两只青蛙的起始位置和单次跳跃距离给定，以及坐标轴的长度给定，求使得两只青蛙相遇的跳跃次数。\n分析 坐标轴，跳跃，模拟！NO！不可能！\n数学题嘛\u0026hellip;起始位置分别为$x$和$y$，单次跳跃距离分别为$m,n$，一条坐标轴的长度为$L$，把这条循环的坐标轴看成无限延伸的，长度为$L$的倍数的坐标轴，很容易想到以下表达式\n设青蛙A的起始坐标为$x$，单次跳跃距离为$m$，B青蛙起始坐标为$y$，单次跳跃距离为$n$，则有\n$$ (x+pa)-(y+pb)=qL \\tag{1} $$\n其中$P$代表跳跃的次数。\n可以证明，在两只青蛙跳跃间距出现$L$的整数倍数时（在无限坐标轴上），在循环坐标轴上即为相遇。\n对于上式，$x,y,a,b,L$皆为已知量，$p,q$为变量，故可稍化简该式子，得到:\n$$ (n-m)p+Lq=x-y \\tag{2} $$\n观察式子，很容易看到这是标准的二元一次方程$ax+by=n$的形式，若方程（2）存在整数解，青蛙就有可能相遇，同时本题要求的是$p$的最小整数解。\n至于如何判断$ax+by=n$形式的二元一次方程是否有解，在有解的情况下如何求解，求出解之后如何得到最小正整数解，考虑拓展欧几里得算法。\n拓展欧几里得 对于方程二元一次方程$ax+by=n$，有解的充要条件是$gcd(a,b)$可以整除$n$。\n稍作解释即：令$a=gcd(a,b)a\u0026rsquo;，b=gcd(a,b)b\u0026rsquo;$，有$ax+by=gcd(a,b)(a\u0026rsquo;x+b\u0026rsquo;y)=n$，如果$x,y,a\u0026rsquo;,b\u0026rsquo;$都是整数，那么$c$必须是$gcd(a,b)$的倍数才能使得方程有解。\n在有解的情况下，若能够确定该方程的一个特解$(x_0,y_0)$，那么则能够求得通解，在此不做赘述，对于最小非负整数解则有:\n$$ x_0\u0026rsquo;=(x_0\\mod \\frac{b}{gcd(a,b)}+\\frac{b}{gcd(a,b)})\\mod \\frac{b}{gcd(a,b)} \\\\ y_0\u0026rsquo;=(y_0\\mod \\frac{a}{gcd(a,b)}+\\frac{a}{gcd(a,b)})\\mod \\frac{a}{gcd(a,b)} $$\n那么如何求这个特解$(x_0,y_0)$呢？\n引入拓展欧几里得算法\n当方程符合$ax+by=gcd(a,b)$时，可用拓展欧几里得求得特解$(x_0,y_0)$，代码如下\nll exgcd(ll a,ll b,ll \u0026amp;x,ll \u0026amp;y) { if(b==0) { x=1; y=0; return a; } ans=exgcd(b,a%b,x,y); ll tmp=x; x=y; y=tmp-(a/b)*y; return ans; //顺便返回a,b的公约数 } 但这仅求得的是方程$ax+by=gcd(a,b)$的一个特解，而非我们所要的$ax+by=n$的特解\n由于方程满足$gcd(a,b)$可以整除$n$，则可将方程两边共乘$\\frac{n}{gcd(a,b)}$，得到以下式子\n$$ \\frac{ax_0 n}{gcd(a,b)}+\\frac{by_0 n}{gcd(a,b)}=n $$\n故可知，若求得方程$ax+by=gcd(a,b)$的特解为$(x_0,y_0)$,则对应的$ax+by=n$方程的特解就在原特解上乘上对应的系数$\\frac{n}{gcd(a,b)}$即可。\n随后可根据题目要求套之前的求最小非负整数解的公式。\n提示 本题中容易出错的是，保证方程求得非负解，要求a\u0026gt;=0,即n-m\u0026gt;=0，故应当注意在输出之后处理系数。\nAC代码 #include\u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; ll ans; ll exgcd(ll a,ll b,ll \u0026amp;x,ll \u0026amp;y) { if(b==0) { x=1; y=0; return a; } ans=exgcd(b,a%b,x,y); ll tmp=x; x=y; y=tmp-(a/b)*y; return ans; } int main() { ios::sync_with_stdio(false); ll x,y,n,m,l; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;m\u0026gt;\u0026gt;n\u0026gt;\u0026gt;l; ll a=n-m,b=l,c=x-y; if(a\u0026lt;0) { a=-a; c=-c; } ll x0,y0; exgcd(a,b,x0,y0); ll g=ans; if(c%g) { cout\u0026lt;\u0026lt;\u0026#34;Impossible\\n\u0026#34;; }else { ll u=((x0*(c/g))%(b/g)+(b/g))%(b/g); cout\u0026lt;\u0026lt;u\u0026lt;\u0026lt;endl; } } "},{"section":"Blog","slug":"/en/blog/barycentre-2019ccpc-jiangxi-a/","title":"【算法笔记】树的重心-CCPC2019江西-A","description":"this is meta description","date":"April 11, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"树论, 树的重心","content":"题意 给定两棵不连通的树，分别在其上选定两个节点并连接，使得$\\sum_{i-1}^{n}\\sum_{j=i+1}^{n} dis(i,j)$的值最小，其中$dis(i,j)$代表从节点i到节点j之间的距离。（2\u0026lt;=n\u0026lt;=100000)\n分析 举个例子，给出以下一组数据\n8 1 2 1 3 3 4 3 5 6 7 6 8 3 6 如图，很明显，需要连接节点3与节点6，能够使得两两节点之间的距离和最小。\n顺便提一提，为什么输入数据是n个节点与n-2条边呢？因为要两棵独立树，根据树的性质，n节点的树有n-1条树支，那么两棵独立树就对应有n-2条树支。对于本题中，很显然需要找到两棵树的中心，再将其相连，求出新树的每两点的间距和，即是所求答案。\n那么何为树的重心呢？\n定义 对于权值为1的树，树的重心即为到其余节点的距离和最短的节点。\n如何找重心 稍作思考，重心到其余节点的距离和最短，那么可以证明与重心相连的所有子树的最大节点数最小。可以思考这个过程，从重心走向其相邻节点，定会使与新节点相邻的某一子树T的节点数增加，同时相比原节点，新节点离子树T的每一个节点的距离都增加，从而导致到所有节点的距离和增加。\n为找到一个节点，使得与其相连的子树最大节点数最小，可以先预处理出每个节点的所有子树节点数之和（包括其本身）的值，存于sum数组中。再遍历所有的节点，依次计算出与当前节点相连的子树最大节点数。对于树型结构，其子儿子（深度比当前节点要深的子树）所包含的节点数即为之前预处理的值，至于另一侧，即与深搜方向相反的那一棵子树T的节点数，可以通过总节点数减去当前节点（包括本身）的儿子数sum得到。遍历所有子儿子（包括子树T），在这个过程中记录使得最大节点数最小的节点，即为所求树的重心。 如图例\n知道相关概念之后，接着对本题数据进行操作。\n解题过程 存树 考虑到存入的是两棵树，直接按照正常的存图方法即可，本次采用邻接表存图，但为了找出处于不同的两棵树上的不同节点（为了随后更方便地找到树的重心），可采用并查集，将属于同一棵树的节点放在同一个集合，这样就可以很方便的找到原树根（遍历节点，满足s[i]==i的定位初始根）。\n预处理儿子数 dfs即可实现，在处理返回值时顺带记录于sum数组中，最终的返回值也可作为节点数，代码如下\nll dfs(ll x,ll pre) { ll ans=1; for(ll i=0;i\u0026lt;G[x].size();i++) { if(G[x][i]==pre) continue; ans+=dfs(G[x][i],x); } return sum[x]=ans; } 寻找重心 定义函数，引用方式传入重心记录变量，注意相邻最大子树节点数的记录，dfs遍历每一个节点\n代码如下\nvoid dfs_1(ll x,ll ss,ll \u0026amp;newN,ll pre) { ll x1=ss-sum[x]; //子树T的节点数 for(ll i=0;i\u0026lt;G[x].size();i++) { //遍历儿子 if(G[x][i]==pre) continue; x1=max(x1,sum[G[x][i]]); //找最大节点数 } if(x1\u0026lt;maxn) { //寻所有节点中最大节点数最小的节点 maxn=x1; newN=x; } for(ll i=0;i\u0026lt;G[x].size();i++) { if(G[x][i]==pre) continue; dfs_1(G[x][i],ss,newN,x); //递归深搜 } } 连接树 将两棵树所求得的重心相连，再跑一次查询sum的dfs，计算新树的sum数组值。\n跑图出结果 现在离成功仅剩下求出题目所求表达式的值，即所有节点到其余节点的距离和。可通过sum数组计算每条树支被走过的次数，再将这个次数累加。具体实现方法即：对于每一个节点N遍历其相邻子节点Nx，对于当前节点N到子节点Nx的这条连通树支L1，会在从Nx及其子节点出发经过N并到达N的其它子节点时被走过$(n-sum[Nx])*sum[Nx]$次，（理解成sum[Nx]个节点去走剩下的n-sum[Nx]个节点的时候都会经过L1一次），然后，递归深搜，说是遍历每一个节点，但是也遍历了每一条树支L1，然后累加就好啦！\nAC代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=0x3f3f3f3f; const ll N=100005; ll s[N]; ll n; ll r1=-1,r2=-1; vector\u0026lt;ll\u0026gt; G[N]; ll sum[N]; ll sss; ll maxn; void init() { for(ll i=1;i\u0026lt;=n;i++) { s[i]=i; } } int find_s(ll x) { if(x!=s[x]) s[x]=find_s(s[x]); return s[x]; } void union_s(ll x,ll y) { x=find_s(x); y=find_s(y); if(x!=y) s[x]=s[y]; } ll dfs(ll x,ll pre) { ll ans=1; for(ll i=0;i\u0026lt;G[x].size();i++) { if(G[x][i]==pre) continue; ans+=dfs(G[x][i],x); } return sum[x]=ans; } void dfs_1(ll x,ll ss,ll \u0026amp;newN,ll pre) { ll x1=ss-sum[x]; //记录最大子树的节点数 for(ll i=0;i\u0026lt;G[x].size();i++) { if(G[x][i]==pre) continue; x1=max(x1,sum[G[x][i]]); } if(x1\u0026lt;maxn) { maxn=x1; newN=x; } for(ll i=0;i\u0026lt;G[x].size();i++) { if(G[x][i]==pre) continue; dfs_1(G[x][i],ss,newN,x); } } ll dfs_2(ll x,ll pre) { ll ans=0; for(ll i=0;i\u0026lt;G[x].size();i++) { if(G[x][i]==pre) continue; //对于每一条树支，被走过的次数就是两边节点数的乘积 ans+=sum[G[x][i]]*(sss-sum[G[x][i]]); ans+=dfs_2(G[x][i],x); } return ans; } int main() { ios::sync_with_stdio(false); cin\u0026gt;\u0026gt;n; init(); for(ll i=1;i\u0026lt;=n-2;i++) { ll u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; union_s(u,v); G[u].push_back(v); G[v].push_back(u); } for(ll i=1;i\u0026lt;=n;i++) { if(s[i]==i) { if(r1==-1) r1=i; else r2=i; } } //预处理sum数组 ll s1=dfs(r1,-1); ll s2=dfs(r2,-1); sss=s1+s2; ll nr1=r1,nr2=r2; //对两棵树分别找重心 maxn=INF; dfs_1(r1,s1,nr1,-1); maxn=INF; dfs_1(r2,s2,nr2,-1); //连树 G[nr1].push_back(nr2); G[nr2].push_back(nr1); union_s(nr1,nr2); //再处理新sum数组 dfs(nr1,-1); //计算输出 cout\u0026lt;\u0026lt;dfs_2(nr1,-1)\u0026lt;\u0026lt;endl; return 0; } "},{"section":"Blog","slug":"/en/blog/2d-variation-2017asia-hongkong-b/","title":"【算法笔记】二维差分-ICPC2017HongKong-B","description":"this is meta description","date":"April 10, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"二维差分","content":"题意及分析 给定一个大小为$N\\times N(N\u0026lt;10000)$的方格阵，起初每一个格子为白色，现给定K次操作机会，对于每一次操作机会，给定区间$[x1,x2]$与$[y1,y2]$，使所有坐标处于该区间内的格子颜色做一次翻转，求在完成$K$次操作后，为黑色的格子个数。\n在VP这道题的时候，看到通过当时现场通过人数仅为2，果断选择先开别的题，最后回过来再看这道题的时候，发现其实很简单，其实就是二维差分的模板题，但题目存在一个坑点，我也是第一次遇到这样的坑法，我想这也是这道题过题很少的原因，不然应该是一道纯签到题。\n进行若干翻转操作后为黑还是白可以简化成求当前格子被操作次数的奇偶性，若被操作了奇数次，当前格子必定为黑色，反之则为白色。\n对于某个区间范围的数据集体做操作，暴力肯定会超时，故直接考虑差分，本题中为二维差分。\n二维差分及前缀和 前缀和 定义原二维数组为$a[N][N]$，与其对应的前缀和数组为$s[N][N]$，则$s[i][j]$代表$i$行之前，$j$列之前（包括$i$行与$j$列）的所有元素之和。则有预处理公式\n$$ s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]。 $$\n若已知前缀和数组，则查询$(x1,y1)$到$(x2,y2)$的所有元素之和表达式即为\n$$ s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1] $$\n差分 差分即为前缀和的逆运算，若已知数组为$s[N][N]$，则之前讲的$a[N][N]$即为$s[N][N]$对应的差分数组。即差分数组$a[N][N]$求前缀和操作得到前缀和数组$s[N][N]$，前缀和数组$s[N][N]$求差分操作得到差分数组$a[N][N]$。\n则由前缀和数组得到差分数组的预处理公式\n$$ a[i][j]=s[i][j]-s[i-1][j]-s[i][j-1]+s[i-1][j-1]; $$\n区间加操作 对于差分与前缀和，用于多组较大规模的数据统一加减，可对原数组进行求差分操作得到差分数组，在差分数组上进行边界操作，再进行求前缀和操作，即可得到处理后的数组。\n对于二维数组，若要在区间$[x1,y1]$到$[x2,y2]$之间的所有元素加上$c$，则需对其对应的差分数组做以下四步操作即可。\n$$ a[x1][y1]+=c; a[x1][y2+1]-=c; a[x2+1][y1]-=c; a[x2+1][y2+1]+=c; $$\n本题中的应用 本题很明显的给出了做区间统一加的范围，即$[x1,y1]$到$[x2,y2]$，但重点就在于数据规模达到了$10000\\times 10000$，显然开两个二维数组有爆内存的风险，考虑到本题不存在初始数组，因为所有数组元素都是0，故可考虑直接在原差分数组的基础上做前缀和操作，得到最终所求的数组。公式即为\n$$ a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1] $$\n但本题开$10000\\times 10000$的int二维数组仍然爆内存了，但可以考虑到操作次数小于10000，即最终得到的前缀和数组元素值一定小于10000，故可尝试将int改为short，结果AC了。\n代码 #include\u0026lt;bits/stdc++.h\u0026gt; #define pb(x) push_back(x) #define pii pair\u0026lt;int,int\u0026gt; #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int INF=0x3f3f3f3f; const int N=10001; int n,k; short C[N][N]; int lowx,lowy,highx,highy; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; memset(C,0,sizeof(C)); for(int i=1;i\u0026lt;=k;i++) { cin\u0026gt;\u0026gt;lowx\u0026gt;\u0026gt;highx\u0026gt;\u0026gt;lowy\u0026gt;\u0026gt;highy; C[lowx][lowy]++; C[lowx][highy+1]--; C[highx+1][lowy]--; C[highx+1][highy+1]++; } C[0][0]=0; int ans=0; for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) { C[i][j]+=C[i-1][j]+C[i][j-1]-C[i-1][j-1]; if((C[i][j])%2==1) ans++; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(false); int t; cin\u0026gt;\u0026gt;t; while(t--) solve(); } "},{"section":"Blog","slug":"/en/blog/binarysearch-2017asia-hongkong-e/","title":"【算法笔记】二分答案-ICPC2017HongKong-E","description":"this is meta description","date":"April 9, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"262\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/SVD/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/SVD\\/image-1_hu290b89f70dc6c3b2f1bbb651d4c0a37d_201229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"二分答案","content":"大致题意 为保证各个5G基站之间信号的干扰最小，公司希望最大限度地拉开基站之间的距离，现给出L个候选的基站建设位置，并希望在这L个候选位置中选出K个位置建设基站，从而保证所有基站之间的最小距离最大。\n稍作整理翻译后可以很明显地看出来是一道板题——L个元素中选K个元素保证被选元素之间的最小距离最大。\n看到诸如最小值的最大值、最大值的最小值，直接想到二分答案的几个模板，直接上板。\n二分模板 求最大值的最小值 while(l\u0026lt;r) { int mid=l+r\u0026gt;\u0026gt;1; if(check(mid)) { r=mid; } else { l=mid+1; } } 求最小值的最大值 while(l\u0026lt;r) { int mid=l+r+1\u0026gt;\u0026gt;1; if(check(mid)) { l=mid; } else { r=mid-1; } } 最后答案定格于变量l当中\n基本结构一致，注意中值的选取和边界的变换，随后重点就在于check函数了。\n中值判断 每一个产生的mid值都有概率成为最终的答案，只需要在check函数中检验当前答案的合理性。\n以本题为例，\n由于本题需要求最小距离的最大值，故当前被检测的mid值应作为一个可能的最小距离，故可将其放回原数组中判断合理性。\n故可遍历原数组（排序后的），统计距离大于mid的区间个数（顶点个数-1），若当前统计的顶点个数大于k,则说明当前mid值过小（这个最小距离太小了，导致产生的比这个最小距离要大的区间数太多了，所以可以适量增大这个最小距离mid），同理，若小于k，则说明当前mid值过大，若等于k，则正好说明当前mid值可行，但为了求得最大的最小距离，故将其与mid值过小的情况共同处理，处理好不同统计情况与返回值的关系之后即可。\n至于如何查找当前mid所决定的区间（顶点）个数，可通过双指针移动实现，具体方法见代码。\n更一般地，对于不同情况的题目，关键就在于在check函数检测当前mid作为最终答案的合理性。\nAC代码 #include\u0026lt;bits/stdc++.h\u0026gt; #define pb(x) push_back(x) #define pii pair\u0026lt;int,int\u0026gt; #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=100005; const int INF=0x3f3f3f3f; int a[N]; int n,k; bool check(int mid) { int cnt=1; int num=1; for(int i=2;i\u0026lt;=n;i++) { if(a[i]-a[cnt]\u0026gt;=mid) { cnt=i; num++; } } if(num\u0026gt;=k) return true; else return false; } void solve() { for(int i=1;i\u0026lt;=n;i++) { cin\u0026gt;\u0026gt;a[i]; } sort(a+1,a+n+1); int l=0,r=1e9; while(l\u0026lt;r) { int mid=l+r+1\u0026gt;\u0026gt;1; if(check(mid)) { l=mid; } else { r=mid-1; } } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(false); while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026amp;\u0026amp;n\u0026amp;\u0026amp;k) solve(); } "},{"section":"Blog","slug":"/en/blog/cfvp/","title":"【算法笔记】Codeforces训练部分记录","description":"this is meta description","date":"February 11, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"181\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/CFVP\\/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/CFVP\\/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"训练记录","content":"Codeforces Virtual participation Record By Coisini_LHF Contest1200 #578(Div2) A 模拟 水题。\nB 模拟+贪心 注意数据非负性的处理。\nC 推式子+分组 推有关LCM的式子，对于分式的LCM，可以同时乘上分母的LCM。即： $$ \\frac{lcm(\\frac{1}{n},\\frac{1}{m})}{\\frac{1}{n}}=\\frac{lcm(\\frac{lcm(n.m)}{n},\\frac{lcm(n.m)}{m})}{\\frac{lcm(n.m)}{n}}=\\frac{lcm(\\frac{m}{gcd(n,m)},\\frac{n}{gcd(n,m)})}{\\frac{n}{gcd(n,m)}}=\\frac{\\frac{m}{gcd(n,m)}}{gcd(\\frac{m}{gcd(n,m)},\\frac{n}{gcd(n,m)})} $$ 分组，通过ceil完成，n个为1组时，当编号为x的元素位于ceil(1.0L*x/n)组，x为ll故使用long double。\nD 思维+二维差分 题意：给定一块n*n的黑白棋盘，可以选定一个规格为k的子棋盘，将其设为白色，问一次操作后最多有几行几列全白。\n预处理每行每列，差分的方式记录可能使其变得全白的子棋盘端点，最后前缀和回来找最大收益的端点。\nE KMP 题意：找最长公共前后缀，依次将字符串拼接。\n利用KMP找字串过程中模式串指针的移动最远位置以确定最长公共区域所在的位置。substr拼接即可。\n同时要限制匹配范围要在主串的最后一个长度等于模式串的子串中，最优情况即该子串被完全匹配。\nContest1201 #577(Div2) A 贪心 题意：给定一系列选择题的作答结果以及每题的分数，就最大可能获得的总分。\n贪心分配每一题的答案，将每题答案设为该题出现最多的那个选项。\nB 思维 题意：给定一系列数，一次操作可以选定两个不同索引的数并将它们同时减一，问是否可能将数组全置零。\n考虑一次操作后，总和减少2，若原数组总和为奇数，必无法全置零。若总和的一半以上都在最大的那个数上，则无法将这数消去，无法置零，若满足max\u0026lt;=sum/2，则可以通过选取最大值所在索引和其余别的索引的方法逐步将最大值消去。\nC 贪心＋模拟 题意：给定一组数，每次可以选择一个数将其加一，给定在k次操作下，求该数组的中位数的最大可能值。\n考虑到将数组排序后，将操作置于较小一半部分并不会对答案造成贡献，因此只考虑将中后部分数据进行加一操作。此时考虑贪心，每一系列操作下尽可能的在不改变原顺序下将中位数改变，当且仅当相邻两数不一样时进行操作，计算操作数及创造的收益。若将所有可能的操作执行完了，此时必定满足中位数与最大值一至，再考虑将未进行的操作执行，从后往前尝试靠近中位数，即再在答案上加上k/mid，其中k为剩余操作数，mid为后半部分的数字个数。\nD 贪心+类DP 题意：给定一个方格，其中有若干宝藏，角色初始位于左下角，每次移动可选择向上、左、右，但向上移动只能在给定的“安全列”中进行，求收集所有宝藏的最小步数。\n记录每一行的端点宝藏位置，只考虑取到端点宝藏即可。 考虑到每次取完一层的宝藏后，所处的位置仅有两种情况，即最左与最右，此时再次往上走的策略有8种情况，即：停在最左时，从其左边最近的安全列向上，到上一行最左或最右，从其右边最近的安全列向上，到上一行最左或最优，停在最右时同理，此时记录每一行位于最左或者最右端情况下的移动距离，进行DP递推即可。最后答案需加上纵向长度。\nTips: long long的无穷大还是用0x3f3f3f3f3f3f3f3f为妙。\nContest1202 Educational Round 70 (Div2) A 二进制+贪心 题意：给定两个二进制数A与B，求一个整数K，使得A+B*(2^K)所对应的二进制字符的翻转字典序最小。\n考虑乘上2的幂相当于将二进制数整体左移，翻转后字典序最小，则考虑将翻转后的二进制串的最靠前的1给消除即可，因此寻找第二个串翻转后的第一个1的位置pos，并找到第一个串翻转后再pos之后的第一个1的位置，考虑将这两个1放在同一位即可相加相消，移动的距离即为两个1的距离，即最终的K值。\nB 暴力预处理+最短路 题意：给定两个数x,y，并对一个数z进行操作，z初始为0，一轮操作时，将z的个位数输出，并将x和y中的任意一个数加到z上，反复操作可以生成一个输出序列。现给定一个输出序列，该序列可能被抹去一些数据，现需输出一个10*10的矩阵，第x行y列的元素代表当给定数为x,y时，其可能输出序列距离给定的输出序列的最小差距。\n考虑暴力预处理各x,y下两数之间的最小间隔操作次数，如x,y分别为2,3时，从0到5需要的操作次数为2，由于只要考虑0到9各数之间的转换次数，则建立最短路模型，从u到(u+x)%10以及从u到(u+y)%10之间的距离为1，随后通过简单Floyd算法得到各数之间的最小操作间隔。\n随后遍历原序列，判断两个相邻数之间的最小操作次数为多少，若无法到达则该x,y下无法生成该序列，反之将距离-1累加即可。\n需注意在构造最短路时，一个数到其本身的操作次数不为0，不能初始距离为0。\nC D 构造+贪心+二分 题意：给定一个数n，构造一个含1、3、7的串，要求其中子序列“1337”的个数恰好为n。\n考虑到3对答案的贡献最大，若3的个数为k，对答案的贡献为k*(k-1)/2，记该贡献为d，则考虑找到一个最大的d满足d\u0026lt;=n，可通过二分查找，此时剩余需求答案为n-d，则考虑将答案构造为\u0026quot;133\u0026quot;+(n-d)个\u0026quot;7\u0026quot;+(d-2)个\u0026quot;3\u0026quot;+\u0026ldquo;7\u0026rdquo;，这样“133”+n-d个“7”对答案产生贡献仅为n-d，前部分的“133”与后续d-2个“3”与最后的“7”，产生贡献d，最终满足子序列个数为n-d+d=n。\nContest1203 #579 (Div3) A 模拟 题意：给定一个序列，判定其是否能按照顺时针或者逆时针成环。\n找出最小值所在位置，向前向后构建数组，判定是否存在顺序情况即可。\nB 特判 题意：给定一个数n，以及4*n根木棍，判定是否能恰好组成n个面积相同的矩阵。\n考虑矩形对边边长相等，因此可将原4n个木棍长度进行排序，并两两配对，若存在无法配对的情况则无法组成矩形。经过配对后，依次将最小、最大的木棍组成矩形的长宽，计算面积，最后判定所有存在的面积是否一致即可。\nC 整除 题意：给定一个数字序列，求能够整除所有的元素的数的个数。\n求所有数的公约数，最后判定存该公约数存在多少个因数即可，包括本身及1。\nD1 暴力枚举 题意：给定一个主串与模式串，要求在主串中截取一个区间后，剩余的字符串仍能够匹配模式串，求该区间的最大值。\nEasy version数据范围较小，可枚举区间，判断截取后是否能够形成匹配，并记录最大区间宽度即可。\nD2 预处理+思维 题意：如D1，数据范围增至2e5。\n考虑截取情况有三：一是截取开头若干部分，剩余能够匹配，二是截取结尾若干部分，剩余能够匹配，三是截取中间部分，求以上三者的最大值即可。故可预处理模式串中每一个字符最早被匹配的位置以及最迟被匹配的位置。随后答案先在last[1]-1，lens-pre[lent]当中取最大值，分别代表截取开头部分至模式串首字符最迟被匹配的位置，以及截取结尾部分至模式串结尾字符最早被匹配位置。随后遍历模式串，枚举区间存在于模式串的哪两个字符之间，求前一个字符最早被匹配的位置到后一个字符最迟被匹配的位置之间的距离，统计答案即可。\n其中最早匹配位置可顺序遍历进行匹配查找，最迟匹配位置可以倒序遍历匹配即可。\nE 贪心 题意：给定一个数字序列，对于每一个数字可以执行加一、减一操作中的其中一个，但不能减至0，求如何操作使得序列中数字个数最大，即有最多不同的数字。\n排序序列，通过map或者开桶记录某一个数是否有生成，若降序排序，优先考虑+1操作，若能不重复地进行则进行，否则后续考虑不变以及减少，并不断通过map记录数据产生即可。\nContest1204 #581 (Div2) A 二进制 题意：给定一个二进制数，求小于该数的4的幂的个数。\n考虑到4的幂对应的二进制的1出现在奇数位，直接统计在该二进制数长度下最多能在奇数位放下几个1即可，需特判若最高位为奇数位，且较低位没有出现1的话，不能将这个最高奇数位计入答案。\nB 贪心 题意：给定一个数n，和一个区间[l,.r]，生成一个长度为n的序列，其中不同的元素个数在该区间内，且对于每一个元素，要么为1，要么为偶数且满足其二分之一也在序列中，求最大与最小序列元素和。\n考虑到元素性质，数的生成必定满足1，2，4，8\u0026hellip;进行，考虑最小元素和，按照2的幂生成出l个元素，随后剩余长度用1填充，对于最大元素和，同理按照2的幂生成出r个元素，剩余用最大元素填充，生成过程中统计答案即可。\nC 最短路+思维 题意：给定一张图G，和一个序列P，求一个P的最小子序列D，满足在路径D下，所经过的最短路径仍为P。\n考虑一个序列ABC，若A到C中存在一个更短的路径，则B必须被包含在答案中，否则在最短路径下，路径为AC，不满足与原序列ABC一致，反之若AC之间的最短路径必定等于2，即需要走路径ABC，则B可以被去除，去除后A到C的最短路为ABC，仍与原序列一致。因此考虑对原图求最短路后，其中起点和终点需要被加入答案序列，依次遍历序列元素X，若满足答案序列的最后一个元素cnt到X的距离加上X到X+1的距离等于2，即最短路唯一，元素X可不被加入答案序列，反之若存在cnt到X+1的更短路，则X必须被加入答案序列。\nD 思维+LIS 题意：给定一个01序列s，求另一个01序列t，满足对于任意区间[l,r]，s与t在该区间中的最长LIS长度一样。且保障t序列中的0是最多的。\n考虑将原序列s中的1变成0，若在该位后面的最长LIS是以1开头的，则改变后对LIS长度变化无影响，若最长LIS为0开头的，则将1变成0则对LIS的长度产生了一个贡献，因此考虑对每一个1进行操作抉择时，其后面的最长LIS必定是1开头的。对于最长LIS开头必为1，其充要条件为后面的1的个数大于等于0的个数，若0的个数较大，则该部分0就能组成最长LIS。故倒序统计01个数，在遍历到1时，若1的个数大于等于0的个数则将该1变为0即可。\nContest1206 #580 (Div2) A 暴力枚举 题意：给定两个数组A，B，问A与B是否存在元素a，b，使得a+b即不出现在A中也不出现在B中。\nmap记录各数组的数字出现情况，暴力枚举各种组合，判断是否同时不出现即可。\nB 贪心 题意：给定一个数组，可对每个元素进行加一减一的操作，问最小操作次数使得所有元素的乘积为1。\n考虑将其变成全1或者其中包含偶数个-1。对原数组进行升序排序，遍历数组，若元素值为0，则进行一次加一操作，若元素为负数，则考虑将其本身与其下一个元素也变成-1，这样比到1的距离要小，若最后一个元素也为负数，只能变成1了，若为正数则直接变成1，过程中记录操作次数即可。\nC 思维+构造 题意：给定一个数n，求是否存在一个长度为2*n的环，将环上所有连续n个数的和组成一个集合，该集合元素的最大最小值之差不超过1。\n考虑n为环的长度的一半，每次将连续长度为n的序列进行1位偏移，生成的新序列和与原序列和之间的差值不超过1，则考虑两端元素差值不超过1，即为相邻元素，且距离最远，因此考虑相邻元素按照最远距离分配，手动构造若干样例易知，当n为偶数时无法完成构造，当n为奇数时，考虑将相邻元素按照最远距离分配，可分奇偶进行分配，代码如下\nfor(int i=1;i\u0026lt;=n;i++) { if(i\u0026amp;1) { //保证2*i-1与2*i之间距离最大 ans[i]=2*i-1; ans[i+n]=2*i; } else { ans[i]=2*i;\t//通过模拟可知这样的操作能够保证序列和的平衡，将本组较小与上组较大靠近 ans[i+n]=2*i-1; } } //生成过程：1xx2xx -\u0026gt; 14x23x -\u0026gt; 145236 分奇偶一正一反 D 鸽巢思维+最小环 题意：给定一个长度为n数组，若存在两个数组元素满足其按位与的结果不为0，则在他们之间连接一个长度为1的边，求最终组成的图上的最小环。\n关键需考虑到，如果对于某一位，有大于等于3个元素该位为1，则最小环必为3，这样的特性能够降低许多情况的判定，考虑极限情况，63位中每一位为1的数都有两个，此时已有126个数，若再多一个数，根据容斥原理，此时必能够产生某一位有大于等于3个元素该位为1，因此当非0数的个数大于126时，直接判定结果为3即可。\n反之进行最小环求解，问题规模仅有126，可用Floyd求解最小环。\n对于Floyd求解最小环，当遍历到中间点k时，此时所有点之间的最短路G(i,j)的具体路径都不包含k，此时求一下G(i,j)+dis(j,k)+dis(k,i)即当前环，记录最小值即可。其中G(i,j)代表i,j之间不经过k的最短路，dis(j,k)与dis(k,i)代表原来的距离，相当于求路径i-\u0026gt;j-\u0026gt;k-\u0026gt;i这样一个环的长度。代码如下：\nll ans=INF; for(int k=1;k\u0026lt;=n;k++) { for(int i=1;i\u0026lt;k;i++) {\t//枚举范围[1,k) 先记忆 后续可逐步理解 for(int j=i+1;j\u0026lt;k;j++) { ans=min(ans,1ll*G[i][j]+dis[j][k]+dis[k][i]); //防爆加上1ll* } } for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) { G[i][j]=min(G[i][j],G[i][k]+G[k][j]); } } } if(ans==INF) ans=-1; Contest1207 Educational Round 71 (Div2) A 枚举 题意：给定面包的数量b，牛肉p，鸡肉f，并给出牛肉堡和鸡肉堡的价格，求最大收益。\n暴力枚举制作的个数，注意枚举范围要从0开始，记录最大值即可。\nB 模拟 题意：给定一个n行m列的01矩阵，定义一次操作可以选定一个2*2的子矩阵并将其全置为1，问是否存在一种操作方案使得一个n行m列的全0矩阵变成输入的01矩阵。\n遍历原矩阵，若以枚举点为左上角的子矩阵为全1，记录该点，随后根据记录的点，将一个全0矩阵进行操作，最后判断操作后矩阵与原输入矩阵是否一致，若一致则输出记录点即可。\nC DP/贪心 题意：给定一个数轴0~n，一共有n个区间[x,x+1]，其中x为整数，范围为0~n-1，每一个区间有一个01值，若为1，则代表该位有一个十字路口，现需要在整个数轴上搭建管道，若区间为十字路口，必须将管道抬升至2，否则高度可以是1，但高度从1到0或者从0到1都需要1个单位的多余管道，且在每个整数点都需要搭建支柱来支撑管道，且每个单位的支柱个管道都有单独的花费，求最小的花费。如下图为例。\nDP解决，定义dp数组dp[x][u]，其中u取值为0，1，dp[x][1]代表第x个节点下抬高水管的最小花费，dp[x][0]代表在第x个节点下不抬高水管的最小花费，初始状态为dp[0][0]=b,dp[0][1]=INF，代表在第0个节点下，只能够不抬高，此时花费为一个单位的支柱，抬高花费为INF。随后遍历01序列，若为0则将对应节点下的抬高与不抬高的情况都考虑，反之则只考虑抬高情况，将不抬高情况设置为INF，具体转移方程如代码。\ndp[0][0]=b; //a为单位水管的价格 b为单位支柱的价格 dp[0][1]=1e15; for(int i=0;i\u0026lt;n;i++) { if(s[i]==\u0026#39;0\u0026#39;) { //若为0，则两种都考虑 dp[i+1][0]=min(dp[i][0]+a+b,dp[i][1]+2*a+b); //0-\u0026gt;0考虑一单位支柱和一单位水管 1-\u0026gt;0考虑一单位支柱和两单位水管 dp[i+1][1]=min(dp[i][0]+2*a+2*b,dp[i][1]+a+2*b); //0-\u0026gt;1考虑两单位水管和两单位支柱 1-\u0026gt;1考虑两单位支柱和一单位水管 } else { //若为1，必须抬高 且从前一个支柱开始就应当抬高 如图可看出 dp[i+1][1]=dp[i][1]+a+2*b; //只从1转移到1 dp[i+1][0]=1e15; //对应的0直接设置为无穷大 } } cout\u0026lt;\u0026lt;dp[n][0]\u0026lt;\u0026lt;endl; D 容斥+组合 题意：给定一个数对序列(ai,bi)，可对该序列进行随意排序，并定义一个序列中所有数对的第一个元素单调不减或者第二个元素单调不减，则称该序列为bad序列，求所有非bad序列的排列情况数。\n正难则反，非bad序列数=总排列数-bad序列数=总排列数-(第一个元素单调不减序列数+第二个元素单调不减序列数-两个元素均单调不减序列数)。预处理到n的阶乘，总排列数位n的阶乘。随后将序列按照第一个元素进行升序排序，遍历序列，统计可能产生的序列数（不断乘上连续相同的数的个数的阶乘，即将连续相同的数进行排列的情况），同理按照第二个元素进行升序统计可能的序列数。最后按照主次排序进行升序排序，判断是否满足都为单调不减序列，若不是，则两个元素均单调不减序列数为0，反之按照以上手法（乘上两个数都相同的个数的阶乘），统计可能产生的序列数。最后计算答案即可，注意减法减后要加上模数(a-b)%mod=(a-b+mod)%mod。\nContest1213 #582 (Div3) A 枚举 题意：给定一个序列，对每个元素可进行加减1操作，花费为1，加减2操作，花费为0，求最少花费使得所有元素相等。\n暴力枚举达到点，相距奇数则记花费，统计最小花费即可。\nB 模拟 题意：给定一个序列，求满足在其之后存在更小值的元素个数。\n倒序遍历数组，记录最小值，若满足元素大于所记录的最小值则答案加一。\nC 简单计数 题意：给定一本n页的书，每翻m页记录一次页码，求所有页码的个位数之和。\n考虑到页码的个位数每十次必有一次循环，先记录一次循环的贡献sig，总共有d=n/m个被记录的页码，答案则为sig*d，再加上剩余不成一次循环的个位数贡献。\nD 预处理 题意：给定一个序列，对每个元素可进行除二下取整操作，求最小操作次数，使得该序列中有k个相同的元素。\n简单版本枚举终点暴力计算即可。\n预处理每一个数到其能到达的所有数的操作次数并记录，该复杂度为log级别，对于每一个可能的数到达的数，使用vector记录序列元素到它的距离。随后遍历终点，若对应的vector规格小于k则跳过，反之取vector中最小的k个元素的和，记录最小值作为答案。该复杂度为O(nlogW)+O(W)。\nE 字符串构造？ G 离线+Kruskal思想 题意：给定一颗有n个节点的树，每条边有边权，给定m次询问，每次询问给定一个w，求点对(u,v)的个数，使得该点对的路径上的最大值小于等于w。\n对询问离线计算。记录所有询问以及边的信息，按照询问的权值以及边的权值进行排序，遍历询问，对于一次询问w，遍历所有小于该w的边，（此时需记录边的遍历开头位置，下一个询问时不能从头开始遍历边），对边连接的两个节点进行判定，若不为同一个集合，则将其对应的集合的集合元素个数siz相乘记录于答案中，并将其合并即可。\n需注意合并过程中需要将记录集合元素个数的数组siz更新。即为s[v]=u;siz[u]+=siz[v];siz[v]=0; 即将v接到u上，将信息记录在u上面。\n数据结构 1791F 区间记录+操作性质判定 1500 题意 给定一个长度为n的数组，进行q次操作，操作1为将区间[l,r]中的数变成其数位和，操作2为求第x个数的值。\n分析 对于任意一个数，进行至少三次求数位和操作后便保持不变，因此考虑使用线段树记录每个数的操作次数，该操作次数不会超过三次，对于操作2，单点查询目标的操作次数，直接暴力求结果即可。\n补充 对于线段树维护区间某一操作结果的时候，通常考虑该操作本身具有的性质，一般会有收敛。\n构造 1806C 分类讨论+构造 1600 题意 给定一个数m以及一个长度为2*m的数组，取其中m个元素，使得其乘积与剩下m个元素之和相等，则称该数组为good，求原数组到一个good数组的最短距离。\n分析 考虑到对于任意的m，[0,0,\u0026hellip;,0]一定是一个good数组。当m等于1时，[x,x]也为一个good数组，当m等于2时，[2,2,2,2]和[-1,-1,-1,2]也为good数组，当m为偶数时，对于任意的m，都存在一个good数组为[-1,-1,-1\u0026hellip;.,m]，而m为奇数时则无另外解。\ngood数组的解仅有以上若干种情况，依次讨论计算原数组与其的距离即可。\n1758D 分奇偶构造 1800 题意 构造一个长度为n的序列，使得序列最大最小值之差等于序列和的根号\n分析 构造方法：对于偶数，取最大值最小值的差为n，两边关于n对称即可。如n=6时，3，4，5，7，8，9，即为[n-n/2,n-1],[n+1,n+n/2].\n对于奇数，不妨取最大最小值的差为n+1，分为两段[n+2-(n+1)/2,n],[n+3,n+2+(n+1)/2]。\n数学 1766D 整数性质+gcd分析 1600 题意 对于两个数x，y，找到一个最小的自然数k使得gcd(x+k,y+k)！=1，若找不到则输出-1。\n分析 不妨设k存在，则存在一个m\u0026gt;=2，使得m|(x+k)，m|(y+k)。\n由整除的性质可得m|(x+k-y-k)，即m|(x-y)，设x-y＝d，即m|d。\n问题转化为在d的因子中找一个m使得k最小。\n则遍历d的质因子即可，对于一个质因子w，满足w|(x+k)，则对应的一个k可以表示为w-x%w，记录最小的k即可。\n补充 对于快速遍历一个数的质因子，可以考虑在埃氏筛中将vis数组赋值为其对应的最小质因子，即vis[x]代表x的最小质因子，每次不断除vis[x]即可。\n满足w|(x+k)，则对应的一个k可以表示为w-x%w。（w-x%w+x）整除w恒成立。\n图 1362D 拓扑序验证 1700 题意 给定n个博客以及m条引用关系，给定n个数，代表每条博客的期望主题号p，且需满足对于每一个博客发布时，所有小于它的主题号p均要被发布，请给出一个博客发出顺序，若无法发出则-1。\n分析 即拓扑序的验证，对于每一个节点，遍历其邻居，若邻居中没有所有小于他的权值的节点则-1，若存在一样的权值也是-1。完成验证后，仅需要根据主题号p进行排序输出id即可。\n1805D 树的直径 题意 给定一颗树以及一张图G，对于树上两个节点u，v，如果其距离大于等于k，则这两个节点在图中有一条连边，求不同的k下，图上的连通块个数。\n分析 对于树的直径d，如果k大于d，即树上最远的距离都比k小，则对应的图无连边，所有节点孤立。设该直径的起始点为st和ed，对于树上任意一点，其到直径两个端点的距离如果都小于k，证明该点肯定无法进行连边，属于一个孤立节点，因此只需要计算所有点到两个直径端点的最大值dis，将其升序排序。随后遍历k，对于每一个k，找到所有dis小于k的个数，加一后即为当前的连通块数目。\n补充 对于树的直径求法，从任意一点dfs找到最大深度点，再从该点进行dfs找到另一最大深度点，这两点之间的距离即为树的直径。\n搜索 1365D BFS+预先处理 1700 题意 给定一张地图，其中包含好人和坏人以及障碍，问是否存在一种放置障碍的方式，使得所有好人能到终点但是坏人不行。\n分析 简单BFS，将所有坏人围起来然后从终点跑BFS，看看能不能跑到所有好人即可。\n位运算 1775C \u0026amp;的性质+位模拟 1600 题意 给出两个正整数n，x，找出一个最小的整数m使得n\u0026amp;(n+1)\u0026amp;(n+2)\u0026hellip;\u0026amp;m==x。\n分析 模拟分析即可。对于x-\u0026gt;y，若y的某一位是1但是x的某一位是0，则必定无法完成操作。对于某一位x，y都是1的，找最高位都是1的，将它的高一位变成1，后面全变成0即可。如果在x，y都是1的位的再高位还有x为1，y为0的位，则必然不能完成操作，反之也记录该最高位即可。\n杂项 1792C 双指针 1500 题意 给定一个排列，每次操作可以任取其中两个数，将较小者放到第一位，将较大者放到最后一位，求将排列变得递增的最小操作次数。\n分析 考虑使用双指针操作，一开始将头指针指向第一个数，将尾指针指向最后一个数，每一次循环时，若数已经出现过则将指针进行移动，同时记录一个全局的now，若头指针指向的数不为now或者尾指针指向的数不为n-now+1，则代表now和n-now+1并未配对或者不在位置，需要进行一次操作并进行标记，同时now加一。仅需要考虑now和n-now+1是否配对即可，具体每对的顺序可以进行独立调整。\n代码 //2 1 4 3 while (l \u0026lt; r) { while (vis[a[l]]) l++; while (vis[a[r]]) r--; if (l \u0026gt;= r) break; if (a[l] != now || a[r] != n - now + 1) ans = now; vis[now] = vis[n - now + 1] = 1; now++; } 1779C 前缀和分析+优先队列 1600 题意 给定一个长度为n的数组a，对于每一次操作，可以选择其中一个数将其置反，同时给定一个m，要求前缀和sum[1,m]为所有前缀和中最小的，求最小的操作次数。\n分析 对于式子sum[1,m]\u0026lt;=sum[1,1]，sum[1,m]\u0026lt;=sum[1,2]，sum[1,m]\u0026lt;=sum[1,3]\u0026hellip;sum[1,m]\u0026lt;=sum[1,m-1]，可以将其转化为以下形式，\nsum[2,m]\u0026lt;=0,sum[3,m]\u0026lt;=0,sum[m,m]\u0026lt;=0，同理有sum[m+1,n]\u0026gt;=0,sum[m+2,n]\u0026gt;=0,sum[n,n]\u0026gt;=0。\n则分别从m+1到n运算前缀和，若前缀和出现小于0，则在优先队列中弹出最小的负数将其置反；从m到2运算前缀和，即m向左开始累加，若出现大于0，则从优先队列中弹出最大的正数取反。\n1781C 字符串+暴力枚举 1600 题意 给出一个长度为n的字符串(1\u0026lt;=n\u0026lt;=1e5)，每个字符都是小写字母。你可以多次对其进行操作：选择任意一个位置的字母将其变为另一个任意字母，要求最终字符串中所有出现过的字母的出现次数相同。求满足条件所需要的最小操作数。\n分析 出现次数越多的字符越容易被留下，考虑对字符的出现次数进行即降序排序，且最终出现次数一定是字符串长度n的因子，考虑枚举最终答案，对于最终每个字符出现次数x，遍历数量最多的n/x个字符，记录其比最终答案的差距，剩余字符全部记录于多余字符部分，随后不断将多了字符分配到较小字符处即可。\n1783C 排序+贪心 1700 题意 有n个选手，编号从1到n，大编号者本身能战胜小编号者，现给定时间m，若要打败选手i，需要花费时间a[i]，在循环赛后，即两两打斗，依据胜场数来排名次，求最小名次。\n分析 考虑贪心，能战胜的场数越多越好，因此考虑将花费时间a进行排序，循环在m的时限内最多能够战胜的人数，倘若能够战胜x个人了（按照a升序的前x个人），如果不打前面那个第x个人，但是能够战胜第x+1人（原顺序的第x+1人），则可以考虑将前面最后一个打的人转移到打这个人，如果能打过，名次还能够继续上升。\n"},{"section":"Blog","slug":"/en/blog/template/","title":"【算法笔记】XCPC模板-常用自用","description":"this is meta description","date":"February 11, 2022","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_420x0_resize_q80_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"181\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/CFVP\\/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/CFVP/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_100x100_fill_q80_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/CFVP\\/1207C_hu2345cc13b904a674c9d32e1a4785c0a8_39264_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"算法竞赛","tags":"竞赛模板","content":"数据结构 DSU 种类并查集 if (op == 1) { //u,v同类 //如果 u的猎物是v 或者 u的天敌是v ，则矛盾 if (find_s(u + n) == find_s(v) || find_s(u + n + n) == find_s(v)) { ans++; continue; } union_s(u, v); union_s(u + n, v + n);\tunion_s(u + n + n, v + n + n); } else { //u的猎物为v //如果 u,v同类 或者 u的天敌为v，则矛盾 if (find_s(u) == find_s(v) || find_s(u + 2 * n) == find_s(v)) { ans++; continue; } union_s(u, v + n + n); union_s(u + n, v); union_s(u + n + n, v + n); } 带权并查集 int find_s(int x) { if (s[x] != x) { int fa = s[x]; s[x] = find_s(s[x]); val[x] += val[fa]; //更新到根的距离 siz[x] = siz[s[x]];\t//更新集合的大小 } return s[x]; } void union_s(int x, int y) { int u = find_s(x); int v = find_s(y); //将u集合挂载到v上 s[u] = v; val[u] += siz[v]; siz[u] += siz[v]; siz[v] = siz[u]; return; } 树状数组 //a[x]+=k; void add(int x, int k) { while (x \u0026lt;= n) { tr[x] += k; x += lowbit(x); } } //a[1]+a[2]+...+a[x] int sum(int x) { int ans = 0; while (x) { ans += tr[x]; x -= lowbit(x); } return ans; } 二维树状数组 int n, m, q; int a[N][N]; int tr[N][N][N]; //多了一个维度记录不同的颜色数目 int lowbit(int x) {return x \u0026amp; (-x);} void add(int x, int y, int k, int color) { for (int i = x; i \u0026lt;= n; i += lowbit(i)) { for (int j = y; j \u0026lt;= m; j += lowbit(j)) { tr[i][j][color] += k; } } return; } int sum(int x, int y, int color) { int ans = 0; for (int i = x; i; i -= lowbit(i)) { for (int j = y; j; j -= lowbit(j)) { ans += tr[i][j][color]; } } return ans; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); add(i, j, 1, a[i][j]); } } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if (op == 1) { int x, y, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;c); add(x, y, -1, a[x][y]); //原来这个位置的除去 a[x][y] = c;\t//更换颜色 add(x, y, 1, c);\t//新的更新记录 } else { int x1, x2, y1, y2, c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;x2, \u0026amp;y1, \u0026amp;y2, \u0026amp;c); //考虑已知二维前缀和求区间和的公式 int ans = sum(x2, y2, c) - sum(x1 - 1, y2, c) - sum(x2, y1 - 1, c) + sum(x1 - 1, y1 - 1, c); printf(\u0026#34;%d\\n\u0026#34;, ans); } } } 线段树-区间加 struct SegmentTree { int l, r; int sum, tag; } tr[N \u0026lt;\u0026lt; 2]; void add_tag(int k, int d) { tr[k].tag += d; tr[k].sum += d * (tr[k].r - tr[k].l + 1); return; } void push_up(int k) { tr[k].sum = tr[ls].sum + tr[rs].sum; return; } void push_down(int k) { if (tr[k].tag) { add_tag(ls, tr[k].tag); add_tag(rs, tr[k].tag); tr[k].tag = 0; } return; } void build(int k, int l, int r) { tr[k].tag = 0; tr[k].l = l; tr[k].r = r; if (l == r) { tr[k].sum = a[l]; return; } int m = mid; build(ls, l, m); build(rs, m + 1, r); push_up(k); return; } void update(int k, int s, int t, int d) { if (s \u0026lt;= tr[k].l \u0026amp;\u0026amp; tr[k].r \u0026lt;= t) { add_tag(k, d); return; } push_down(k); if (tr[ls].r \u0026gt;= s) update(ls, s, t, d); if (tr[rs].l \u0026lt;= t) update(rs, s, t, d); push_up(k); return; } int query(int k, int s, int t) { if (s \u0026lt;= tr[k].l \u0026amp;\u0026amp; tr[k].r \u0026lt;= t) { return tr[k].sum; } push_down(k); int res = 0; if (tr[ls].r \u0026gt;= s) res += query(ls, s, t); if (tr[rs].l \u0026lt;= t) res += query(rs, s, t); return res; } 线段树-区间加乘 #include\u0026lt;bits/stdc++.h\u0026gt; #define ls (k\u0026lt;\u0026lt;1) #define rs (k\u0026lt;\u0026lt;1|1) using namespace std; typedef long long ll; const int N = 1e5 + 10; ll n, q, p; ll a[N]; struct node { ll l, r; ll sum, tag_mul, tag_add; } tr[N * 4]; void push_up(ll k) { tr[k].sum = (tr[ls].sum + tr[rs].sum) % p; } void push_down(ll k) { tr[ls].sum = ((tr[k].tag_mul * tr[ls].sum) % p + ((tr[ls].r - tr[ls].l + 1) * tr[k].tag_add) % p) % p; tr[rs].sum = ((tr[k].tag_mul * tr[rs].sum) % p + ((tr[rs].r - tr[rs].l + 1) * tr[k].tag_add) % p) % p; tr[ls].tag_mul = (tr[ls].tag_mul * tr[k].tag_mul) % p; tr[rs].tag_mul = (tr[rs].tag_mul * tr[k].tag_mul) % p; tr[ls].tag_add = (tr[ls].tag_add * tr[k].tag_mul + tr[k].tag_add) % p; tr[rs].tag_add = (tr[rs].tag_add * tr[k].tag_mul + tr[k].tag_add) % p; tr[k].tag_mul = 1; tr[k].tag_add = 0; return; } void build(ll k, ll l, ll r) { tr[k].tag_add = 0; tr[k].tag_mul = 1; tr[k].l = l; tr[k].r = r; if (l == r) { tr[k].sum = a[l] % p; return; } ll m = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, m); build(rs, m + 1, r); push_up(k); return; } void update_add(ll k, ll s, ll t, ll d) { if (s \u0026lt;= tr[k].l \u0026amp;\u0026amp; tr[k].r \u0026lt;= t) { tr[k].tag_add = (tr[k].tag_add + d) % p; tr[k].sum = (tr[k].sum + (tr[k].r - tr[k].l + 1) * d) % p; return; } push_down(k); if (tr[ls].r \u0026gt;= s) { update_add(ls, s, t, d); } if (tr[rs].l \u0026lt;= t) { update_add(rs, s, t, d); } push_up(k); return; } void update_mul(ll k, ll s, ll t, ll d) { if (s \u0026lt;= tr[k].l \u0026amp;\u0026amp; tr[k].r \u0026lt;= t) { tr[k].tag_mul = (tr[k].tag_mul * d) % p; tr[k].tag_add = (tr[k].tag_add * d) % p; tr[k].sum = (tr[k].sum * d) % p; return; } push_down(k); if (tr[ls].r \u0026gt;= s) { update_mul(ls, s, t, d); } if (tr[rs].l \u0026lt;= t) { update_mul(rs, s, t, d); } push_up(k); return; } ll query(ll k, ll s, ll t) { if (s \u0026lt;= tr[k].l \u0026amp;\u0026amp; tr[k].r \u0026lt;= t) { return tr[k].sum; } push_down(k); ll ans = 0; if (tr[ls].r \u0026gt;= s) { ans = (ans + query(ls, s, t)) % p; } if (tr[rs].l \u0026lt;= t) { ans = (ans + query(rs, s, t)) % p; } return ans; } int main() { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;q, \u0026amp;p); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld\u0026#34;, a + i); } build(1, 1, n); for (int i = 1; i \u0026lt;= q; i++) { ll op, x, y, k; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;op); if (op == 1) { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;k); update_mul(1, x, y, k); } else if (op == 2) { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;k); update_add(1, x, y, k); } else if (op == 3) { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;x, \u0026amp;y); printf(\u0026#34;%lld\\n\u0026#34;, query(1, x, y)); } } } 树论 LCA const int N = 500005; std::vector\u0026lt;int\u0026gt; G[N]; int n, m, s; int dep[N], fa[N][22]; int Lca(int x, int y) { if (dep[x] \u0026lt; dep[y]) swap(x, y); for (int i = 20; i \u0026gt;= 0; i--) { if (dep[fa[x][i]] \u0026gt;= dep[y]) { x = fa[x][i]; } } if (x == y) return x; for (int i = 20; i \u0026gt;= 0; i--) { if (fa[x][i] != fa[y][i]) { x = fa[x][i]; y = fa[y][i]; } } return fa[x][0]; } void dfs(int u, int pre) { fa[u][0] = pre; dep[u] = dep[pre] + 1; for (auto v : G[u]) { if (v == pre) continue; dfs(v, u); } } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;s); for (int i = 1; i \u0026lt;= n - 1; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(s, 0); for (int i = 1; i \u0026lt;= 21; i++) { for (int j = 1; j \u0026lt;= n; j++) { fa[j][i] = fa[fa[j][i - 1]][i - 1]; } } for (int i = 1; i \u0026lt;= m; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); printf(\u0026#34;%d\\n\u0026#34;, Lca(u, v)); } } 图论 Tarjan 缩点 //可追溯最早时间戳、时间戳 int low[N] = {0}, dfn[N] = {0}; bool vis[N] = {0}; int tim = 0; //栈 int st[N] = {0}, top = 0; //记录所在的分量 int sd[N] = {0}; void tarjan(int u) { low[u] = dfn[u] = ++tim; st[++top] = u; vis[u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (vis[v]) { low[u] = min(low[u], dfn[v]); } } //组成一个分量 if (dfn[u] == low[u]) { int v; //出栈 while (v = st[top--]) { sd[v] = u; vis[v] = 0; if (u == v) break; //累加权值 val[u] += val[v]; } } } 求割点 void tarjan(int u, int root) { low[u] = dfn[u] = ++tim; int ck = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (!dfn[v]) { tarjan(v, root); low[u] = min(low[u], low[v]); //若非根且其儿子无法追溯到更早的节点，可判断为割点 if (low[v] \u0026gt;= dfn[u] \u0026amp;\u0026amp; u != root) { cut[u] = true; } if (u == root) ck++; } else low[u] = min(low[u], dfn[v]); } //若为根且有两个子树及以上则为割点 if (u == root \u0026amp;\u0026amp; ck \u0026gt;= 2) cut[u] = true; } 网络流 Dinic const ll INF = 0x7fffffff; const int N = 60015, M = 500010; int n, m, s = N - 2, t = N - 1; int head[N], cnt = 1; struct node { int to, next, w; } edge[M]; void add(int u, int v, int w, int W = 0) { cnt++; edge[cnt].w = w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt; cnt++; edge[cnt].w = W; edge[cnt].to = u; edge[cnt].next = head[v]; head[v] = cnt; } int now[N], dep[N]; int bfs() { for (int i = 0; i \u0026lt;= t; i++) dep[i] = INF; dep[s] = 0; now[s] = head[s]; queue\u0026lt;int\u0026gt; q; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; if (edge[i].w \u0026gt; 0 \u0026amp;\u0026amp; dep[v] == INF) { q.push(v); now[v] = head[v]; dep[v] = dep[u] + 1; if (v == t) return 1; } } } return 0; } int dfs(int u, ll sum) { if (u == t) return sum; ll k, flow = 0; for (int i = now[u]; i \u0026amp;\u0026amp; sum \u0026gt; 0; i = edge[i].next) { now[u] = i; int v = edge[i].to; if (edge[i].w \u0026gt; 0 \u0026amp;\u0026amp; (dep[v] == dep[u] + 1)) { k = dfs(v, min(sum, (ll)edge[i].w)); if (k == 0) dep[v] = INF; edge[i].w -= k; edge[i ^ 1].w += k; flow += k; sum -= k; } } return flow; } ll Dinic() { ll ans = 0; while (bfs()) ans += dfs(s, INF); return ans; } 字符串 最小表示法 char str[N]; string mins() { int len = strlen(str + 1); for (int i = 1; i \u0026lt;= len; i++) { str[i + len] = str[i]; } int i = 1, j = 2, k; while (i \u0026lt;= len \u0026amp;\u0026amp; j \u0026lt;= len) { for (k = 0; k \u0026lt;= n \u0026amp;\u0026amp; str[i + k] == str[j + k]; k++); if (k == len) break; if (str[i + k] \u0026gt; str[j + k]) { i = i + k + 1; if (i == j) i++; } else { j = j + k + 1; if (i == j) j++; } } int st = min(i, j); string res = \u0026#34;\u0026#34;; for (int i = st; i \u0026lt;= st + len - 1; i++) { res += str[i]; } return res; } KMP int nxt[N]; char s[N], p[N]; //s为主串,p为模式串 int lenp, lens; void calnxt() { lenp = strlen(p); int j = 0; nxt[0] = nxt[1] = 0; for (int i = 1; i \u0026lt; lenp; i++) { j = nxt[i]; while (j \u0026amp;\u0026amp; p[i] != p[j]) j = nxt[j]; nxt[i + 1] = (p[i] == p[j]) ? j + 1 : 0; } } int KMP() { lens = strlen(s); int ans = 0; int j = 0; for (int i = 0; i \u0026lt; lens; i++) { while (j \u0026amp;\u0026amp; s[i] != p[j]) j = nxt[j]; if (p[j] == s[i]) j++; if (j == lenp) { ans++; j = nxt[j]; //如果子串匹配不可重复则j=0 } } return ans; } 数学 排列数\u0026amp;组合数 const int N = 1005; const ll p = 1e9 + 7; ll fp(ll a, ll n) { ll res = 1; while (n) { if (n \u0026amp; 1) res = (res * a) % p; a = (a * a) % p; n /= 2; } return res; } namespace binom { ll fac[N], ifac[N]; int __ = [] { fac[0] = 1; for (int i = 1; i \u0026lt;= N - 5; i++) fac[i] = fac[i - 1] * i % p; ifac[N - 5] = fp(fac[N - 5], p - 2); for (int i = N - 5; i; i--) ifac[i - 1] = ifac[i] * i % p; return 0; }(); inline ll C(int n, int m) { if (n \u0026lt; m || m \u0026lt; 0)return 0; return fac[n] * ifac[m] % p * ifac[n - m] % p; } inline ll A(int n, int m) { if (n \u0026lt; m || m \u0026lt; 0)return 0; return fac[n] * ifac[n - m] % p; } } 计算几何 //坩埚花菜_lhf_1968225_geometry #include\u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#39;\\n\u0026#39; #define pii pair\u0026lt;int,int\u0026gt; #define pll pair\u0026lt;long long,long long\u0026gt; #define mk make_pair #define pb push_back #define fi first #define se second #define IOS ios::sync_with_stdio(false); using namespace std; typedef long long ll; typedef unsigned long long ull; const int INF=0x3f3f3f3f; const ll inf=0x7fffffff; const double pi=acos(-1.0); const double eps=1e-6; const int maxp=100001; inline ll rd() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (ch ^ 48); ch = getchar(); } return f * x; } int sgn(double x) { if(fabs(x)\u0026lt;eps) return 0; else return x\u0026lt;0?-1:1; } int Dcmp(double x,double y) { if(fabs(x-y)\u0026lt;eps) return 0; else return x\u0026lt;y?-1:1; } struct Point { double x,y; Point() {} Point(double x,double y):x(x),y(y) {} Point operator +(Point B) {return Point(x+B.x,y+B.y);} Point operator -(Point B) {return Point(x-B.x,y-B.y);} Point operator *(double k) {return Point(x*k,y*k);} Point operator /(double k) {return Point(x/k,y/k);} bool operator ==(Point B) {return sgn(x-B.x)==0\u0026amp;\u0026amp;sgn(y-B.y)==0;} bool operator \u0026lt;(Point B) {return sgn(x-B.x)\u0026lt;0||(sgn(x-B.x)==0\u0026amp;\u0026amp;sgn(y-B.y)\u0026lt;0);} }; typedef Point Vector; double Dot(Vector A,Vector B) {return A.x*B.x+A.y*B.y;} double Len(Vector A) {return sqrt(Dot(A,A));} double Len2(Vector A) {return Dot(A,A);} double Angle(Vector A,Vector B) {return acos(Dot(A,B)/Len(A)/Len(B));} double Cross(Vector A,Vector B) {return A.x*B.y-A.y*B.x;} double Area2(Point A,Point B,Point C) {return Cross(B-A,C-A);} double Distance(Point A,Point B) {return hypot(A.x-B.x,A.y-B.y);} double Dist(Point A,Point B) {return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));} Vector Normal(Vector A) {return Vector(-A.y/Len(A),A.x/Len(A));} bool Parallel(Vector A,Vector B) {return sgn(Cross(A,B))==0;} Vector Ratate(Vector A,double rad) {return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));} struct Line { Point p1,p2; Line() {} Line(Point p1,Point p2):p1(p1),p2(p2) {} Line(Point p,double angle) { p1=p; if(sgn(angle-pi/2)==0) { p2=(p1+Point(0,1));}else{p2=(p1+Point(1,tan(angle)));} } Line(double a,double b,double c) { if(sgn(a)==0) { p1=Point(0,-c/b); p2=Point(1,-c/b); } else if(sgn(b)==0) { p1=Point(-c/a,0); p2=Point(-c/a,1); } else { p1=Point(0,-c/b); p2=Point(1,(-c-a)/b); } } }; typedef Line Segment; double Line_angle(Line v) { //返回倾角 [0,pi) double k=atan2(v.p2.y-v.p1.y,v.p2.x-v.p1.x); if(sgn(k)\u0026lt;0) k+=pi; if(sgn(k-pi)==0) k-=pi; return k; } int Point_Line_relation(Point p,Line v) { //点与直线的关系 1为在左侧，2为点再右侧，0为点在直线上 int c=sgn(Cross(p-v.p1,v.p2-v.p1)); if(c\u0026lt;0)return 1; if(c\u0026gt;0)return 2; return 0; } bool Point_on_seg(Point p,Line v) { //点与线段的关系 0为点不在线段上，1为点在线段上 return sgn(Cross(p-v.p1,v.p2-v.p1))==0\u0026amp;\u0026amp;sgn(Dot(p-v.p1,p-v.p2))\u0026lt;=0; } int Line_relation(Line v1,Line v2) { //两直线关系 0平行 1重合 2相交 if(sgn(Cross(v1.p2-v1.p1,v2.p2-v2.p1))==0) { if(Point_Line_relation(v1.p1,v2)==0) return 1; else return 0; } return 2; } double Dis_point_line(Point p,Line v) { return fabs(Cross(p-v.p1,v.p2-v.p1))/Distance(v.p1,v.p2); } Point Point_line_proj(Point p,Line v) { double k=Dot(v.p2-v.p1,p-v.p1)/Len2(v.p2-v.p1); return v.p1+(v.p2-v.p1)*k; } Point Point_line_symmetry(Point p,Line v) { Point q=Point_line_proj(p,v); return Point(2*q.x-p.x,2*q.y-p.y); } double Dis_point_seg(Point p,Segment v) { if(sgn(Dot(p-v.p1,v.p2-v.p1))\u0026lt;0||sgn(Dot(p-v.p2,v.p1-v.p2))\u0026lt;0) return min(Distance(p,v.p1),Distance(p,v.p2)); return Dis_point_line(p,v);\t} Point Cross_point(Point a,Point b,Point c,Point d) { double s1=Cross(b-a,c-a); double s2=Cross(b-a,d-a); return Point(c.x*s2-d.x*s1,c.y*s2-d.y*s1)/(s2-s1); } bool Cross_segment(Point a,Point b,Point c,Point d) { double c1=Cross(b-a,c-a),c2=Cross(b-a,d-a); double d1=Cross(d-c,a-c),d2=Cross(d-c,b-c); return sgn(c1)*sgn(c2)\u0026lt;0\u0026amp;\u0026amp;sgn(d1)*sgn(d2)\u0026lt;0; } struct Polygon { int n; Point p[maxp]; Line v[maxp]; }; int Point_in_polygon(Point pt,vector\u0026lt;Point\u0026gt;p) { //3在点上 2在边上 1在内部 0在外部 int n=p.size(); for(int i=0;i\u0026lt;n;i++) { if(p[i]==pt) return 3; } for(int i=0;i\u0026lt;n;i++) { Line v=Line(p[i],p[(i+1)%n]); if(Point_on_seg(pt,v)) return 2; } int num=0; for(int i=0;i\u0026lt;n;i++) { int j=(i+1)%n; int c=sgn(Cross(pt-p[j],p[i]-p[j])); int u=sgn(p[i].y-pt.y); int v=sgn(p[j].y-pt.y); if(c\u0026gt;0\u0026amp;\u0026amp;u\u0026lt;0\u0026amp;\u0026amp;v\u0026gt;=0) num++; if(c\u0026lt;0\u0026amp;\u0026amp;u\u0026gt;=0\u0026amp;\u0026amp;v\u0026lt;0) num--; } return num!=0; } double Polygon_area(vector\u0026lt;Point\u0026gt;p) { double area=0; int n=p.size(); for(int i=0;i\u0026lt;n;i++) { area+=Cross(p[i],p[(i+1)%n]); } return area/2; } Point Polygon_center(vector\u0026lt;Point\u0026gt;p) { Point ans(0,0); if(Polygon_area(p)==0) return ans; int n=p.size(); for(int i=0;i\u0026lt;n;i++) { ans=ans+(p[i]+p[(i+1)%n])*Cross(p[i],p[(i+1)%n]); } return ans/Polygon_area(p)/6.; } vector\u0026lt;Point\u0026gt; ConvexHull(vector\u0026lt;Point\u0026gt;A, int flag = 1) { //flag =0 not yange flag=1 yange int n=A.size(); vector\u0026lt;Point\u0026gt;ans(n*2); sort(A.begin(),A.end()); int now=-1; for (int i=0; i\u0026lt;n; i++) { while(now\u0026gt;0\u0026amp;\u0026amp;sgn(Cross(ans[now]-ans[now-1],A[i]-ans[now-1]))\u0026lt;flag)now--; ans[++now]=A[i]; } int pre=now; for (int i=n-2;i\u0026gt;=0;i--) { while(now\u0026gt;pre\u0026amp;\u0026amp;sgn(Cross(ans[now]-ans[now-1],A[i]-ans[now-1]))\u0026lt;flag)now--; ans[++now]=A[i]; } ans.resize(now); return ans; } vector\u0026lt;Point\u0026gt; Minkowski(vector\u0026lt;Point\u0026gt;A, vector\u0026lt;Point\u0026gt;B) { vector\u0026lt;Point\u0026gt;C(A.size()+B.size()+1),v1(A.size()),v2(B.size()); for(int i=0;i\u0026lt;(int)A.size();i++)v1[i]=A[(i+1)%A.size()]-A[i]; for(int i=0;i\u0026lt;(int)B.size();i++)v2[i]=B[(i+1)%B.size()]-B[i]; int cnt=0; C[cnt]=(A[0]+B[0]); int p1=0,p2=0; while(p1\u0026lt;(int)A.size()\u0026amp;\u0026amp;p2\u0026lt;(int)B.size()){ ++cnt; if(sgn(Cross(v1[p1],v2[p2]))\u0026gt;=0) C[cnt]=C[cnt-1]+v1[p1++]; else C[cnt]=C[cnt-1]+v2[p2++]; } while(p1\u0026lt;(int)A.size()){ ++cnt;C[cnt]=C[cnt-1]+v1[p1++]; } while(p2\u0026lt;(int)B.size()){ ++cnt;C[cnt]=C[cnt-1]+v2[p2++]; } return C; } struct Circle { Point c; double r; Circle() {} Circle(Point c,double r):c(c),r(r) {} Circle(double x,double y,double _r) {c=Point(x,y);r=_r;} }; int Point_circle_relation(Point p,Circle C) { //0在圆内，1在圆上，2在圆外 double dst=Distance(p,C.c); if(sgn(dst-C.r)\u0026lt;0) return 0; if(sgn(dst-C.r)==0) return 1; return 2; } int Line_circle_relation(Line v,Circle C) { //0在圆内，1相切，2相离 double dst=Dis_point_line(C.c,v); if(sgn(dst-C.r)\u0026lt;0) return 0; if(sgn(dst-C.r)==0) return 1; return 2; } int Seg_Circle_relation(Segment v,Circle C) { //0在圆内，1相切，2相离 double dst=Dis_point_seg(C.c,v); if(sgn(dst-C.r)\u0026lt;0) return 0; if(sgn(dst-C.r)==0) return 1; return 2; } int Line_cross_circle(Line v,Circle C,Point \u0026amp;pa,Point \u0026amp;pb) { //线圆相交点 if(Line_circle_relation(v,C)==2) return 0; Point q=Point_line_proj(C.c,v); double d=Dis_point_line(C.c,v); double k=sqrt(C.r*C.r-d*d); if(sgn(k)==0) { pa=q;pb=q;return 1; } Point n=(v.p2-v.p1)/Len(v.p2-v.p1); pa=q+n*k;pb=q-n*k; return 2; } struct Point3 { double x,y,z; Point3() {} Point3(double x,double y,double z):x(x),y(y),z(z) {} Point3 operator +(Point3 B) {return Point3(x+B.x,y+B.y,z+B.z);} Point3 operator -(Point3 B) {return Point3(x-B.x,y-B.y,z-B.z);} Point3 operator *(double k) {return Point3(k*x,k*y,k*z);} Point3 operator /(double k) {return Point3(x/k,y/k,z/k);} bool operator ==(Point3 B) {return sgn(x-B.x)==0\u0026amp;\u0026amp;sgn(y-B.y)==0\u0026amp;\u0026amp;sgn(z-B.z)==0;} }; typedef Point3 Vector3; double Dot(Vector3 A,Vector3 B) {return A.x*B.x+A.y*B.y+A.z*B.z;} Vector3 Cross(Vector3 A,Vector3 B) {return Point3(A.y*B.z-A.z*B.y,A.z*B.x-A.x*B.z,A.x*B.y-A.y*B.x);} double Len(Vector3 A) {return sqrt(Dot(A,A));} double Len2(Vector3 A) {return Dot(A,A);} double Distance(Point3 A,Point3 B) { return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y)+(A.z-B.z)*(A.z-B.z)); } double Angle(Vector3 A,Vector3 B) {return acos(Dot(A,B)/Len(A)/Len(B));} struct Line3 { Point3 p1,p2; Line3() {} Line3(Point3 p1,Point3 p2):p1(p1),p2(p2) {} }; typedef Line3 Segment3; double Area2(Point3 A,Point3 B,Point3 C) {return Len(Cross(B-A,C-A));} double Dis_point_line(Point3 p,Line3 v) { return Len(Cross(v.p2-v.p1,p-v.p1))/Distance(v.p1,v.p2); } bool Point_Line_relation(Point3 p,Line3 v) { return sgn(Len(Cross(v.p1-p,v.p2-p)))==0\u0026amp;\u0026amp;sgn(Dot(v.p1-p,v.p2-p))==0; } double Dis_point_seg(Point3 p,Segment3 v) { if(sgn(Dot(p-v.p1,v.p2-v.p1))\u0026lt;0||sgn(Dot(p-v.p2,v.p1-v.p2))\u0026lt;0) return min(Distance(p,v.p1),Distance(p,v.p2)); return Dis_point_line(p,v); } Point3 Point_line_proj(Point3 p,Line3 v) { double k=Dot(v.p2-v.p1,p-v.p1)/Len2(v.p2-v.p1); return v.p1+(v.p2-v.p1)*k; } struct Plane { Point3 p1,p2,p3; Plane() {} Plane(Point3 p1,Point3 p2,Point3 p3):p1(p1),p2(p2),p3(p3) {} }; Point3 Prec(Point3 A,Point3 B,Point3 C) {return Cross(B-A,C-A);} Point3 Prec(Plane f) {return Cross(f.p2-f.p1,f.p3-f.p1);} bool Point_on_plane(Point3 A,Point3 B,Point3 C,Point3 D) { return sgn(Dot(Prec(A,B,C),D-A))==0; } int Parallel(Plane f1,Plane f2) { return Len(Cross(Prec(f1),Prec(f2)))\u0026lt;eps; } int Vertical(Plane f1,Plane f2) { return sgn(Dot(Prec(f1),Prec(f2)))==0; } int Line_cross_plane(Line3 u,Plane f,Point3 \u0026amp;p) { //-1线在面上 Point3 v=Prec(f); double x=Dot(v,u.p2-f.p1); double y=Dot(v,u.p1-f.p1); double d=x-y; if(sgn(x)==0\u0026amp;\u0026amp;sgn(y)==0) return -1; if(sgn(d)==0) return 0; p=((u.p1*x)-(u.p2*y))/d; return 1; } //四面体有向体积x6; double volume4(Point3 A,Point3 B,Point3 C,Point3 D) { return Dot(Cross(B-A,C-A),D-A); } double TriAngleCircleInsection(Circle C, Point A, Point B) { Point OA=A-C.c,OB=B-C.c; Point BA=A-B,BC=C.c-B; Point AB=B-A,AC=C.c-A; double DOA=Len(OA),DOB=Len(OB),DAB=Len(AB),r=C.r; if(sgn(Cross(OA, OB)) == 0) return 0; if(sgn(DOA-C.r)\u0026lt;0\u0026amp;\u0026amp;sgn(DOB-C.r)\u0026lt;0)return Cross(OA,OB)*0.5; else if(DOB\u0026lt;r\u0026amp;\u0026amp;DOA\u0026gt;=r) { double x=(Dot(BA,BC)+sqrt(r*r*DAB*DAB-Cross(BA,BC)*Cross(BA,BC)))/DAB; double TS=Cross(OA,OB)*0.5; return asin(TS*(1-x/DAB)*2/r/DOA)*r*r*0.5+TS*x/DAB; } else if(DOB\u0026gt;=r\u0026amp;\u0026amp;DOA\u0026lt;r) { double y=(Dot(AB,AC)+sqrt(r*r*DAB*DAB-Cross(AB,AC)*Cross(AB,AC)))/DAB; double TS=Cross(OA,OB)*0.5; return asin(TS*(1-y/DAB)*2/r/DOB)*r*r*0.5+TS*y/DAB; } else if(fabs(Cross(OA,OB))\u0026gt;=r*DAB||Dot(AB,AC)\u0026lt;=0||Dot(BA,BC)\u0026lt;=0){ if(Dot(OA,OB)\u0026lt;0) { if(Cross(OA,OB)\u0026lt;0)return(-acos(-1.0)-asin(Cross(OA,OB)/DOA/DOB))*r*r*0.5; else return(acos(-1.0)-asin(Cross(OA,OB)/DOA/DOB))*r*r*0.5; } else { return asin(Cross(OA,OB)/DOA/DOB)*r*r*0.5; } } else { double x=(Dot(BA,BC)+sqrt(r*r*DAB*DAB-Cross(BA,BC)*Cross(BA,BC)))/DAB; double y=(Dot(AB,AC)+sqrt(r*r*DAB*DAB-Cross(AB,AC)*Cross(AB,AC)))/DAB; double TS=Cross(OA,OB)*0.5; return (asin(TS*(1-x/DAB)*2/r/DOA)+asin(TS*(1-y/DAB)*2/r/DOB))*r*r*0.5+TS*((x+y)/DAB-1); } } double Polygon_Circle_Union(vector\u0026lt;Point\u0026gt;A, Circle X) { double res = 0.0; int n = (int)A.size(); A.push_back(A[0]); for (int i = 0; i \u0026lt; n; i++) { res += TriAngleCircleInsection(X, A[i], A[i + 1]); } return fabs(res); } int main() { IOS } 杂项 二维差分\u0026amp;前缀和 void inserts(int sx, int sy, int ex, int ey, int c) { a[sx][sy] += c; a[ex + 1][sy] -= c; a[sx][ey + 1] -= c; a[ex + 1][ey + 1] += c; } //单数组形式 for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1]; } } 数组去重 sort(vec.begin(),vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end()); 快读 inline ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (ch ^ 48); ch = getchar(); } return f * x; } 随机数生成 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;random\u0026gt; using namespace std; typedef long long ll; //随机数 int getRand(int a, int b) { return rand() % (b - a + 1) + a; } //随机数long long --version1 ll getRand_LL1(ll a, ll b) { ll rd = (rand() \u0026lt;\u0026lt; 15 | rand()); return rd % (b - a + 1) + a; } //随机数long long --version2 ll getRand_LL2(ll a, ll b) { mt19937_64 rd(time(0)); return rd() % (b - a + 1) + a; } //打乱数组 void getRand_vector(vector\u0026lt;int\u0026gt; \u0026amp;vec) { mt19937 rng(time(0)); shuffle(vec.begin(), vec.end(), rng); } int main() { srand(time(nullptr)); //随机数种子 mt19937 rng(time(0)); //rng即为一个随机函数 vector\u0026lt;int\u0026gt; a; for (int i = 1; i \u0026lt;= 10; i++) { a.push_back(getRand(1, 100)); } getRand_vector(a); return 0; } "}]